<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FLTK 1.3.2: Fl_Gl_Window Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classFl__Gl__Window.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Fl_Gl_Window Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Fl_Gl_Window" --><!-- doxytag: inherits="Fl_Window" -->
<p>The <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> widget sets things up so OpenGL works.  
 <a href="classFl__Gl__Window.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Fl__Gl__Window_8H_source.html">Fl_Gl_Window.H</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Fl_Gl_Window:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classFl__Gl__Window.png" usemap="#Fl_Gl_Window_map" alt=""/>
  <map id="Fl_Gl_Window_map" name="Fl_Gl_Window_map">
<area href="classFl__Window.html" title="This widget produces an actual window." alt="Fl_Window" shape="rect" coords="0,112,103,136"/>
<area href="classFl__Group.html" title="The Fl_Group class is the FLTK container widget." alt="Fl_Group" shape="rect" coords="0,56,103,80"/>
<area href="classFl__Widget.html" title="Fl_Widget is the base class for all widgets in FLTK." alt="Fl_Widget" shape="rect" coords="0,0,103,24"/>
<area href="classFl__Glut__Window.html" title="GLUT is emulated using this window class and these static variables (plus several more static variabl..." alt="Fl_Glut_Window" shape="rect" coords="0,224,103,248"/>
</map>
 </div></div>

<p><a href="classFl__Gl__Window-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFl__Gl__Window.html">Fl_Gl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#afcc185ba5105903e5a1f87def93295c5">as_gl_window</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> pointer if this widget is an <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>.  <a href="#afcc185ba5105903e5a1f87def93295c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a351d72f872e59ac05ca06fd65cdc25c7">can_do</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the hardware supports the given or current OpenGL mode.  <a href="#a351d72f872e59ac05ca06fd65cdc25c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a01a3a32a3c3a58d86c747732b2771c8b">can_do_overlay</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the hardware overlay is possible.  <a href="#a01a3a32a3c3a58d86c747732b2771c8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a446db213805423decdd02e3e71b922c5">context</a> (void *, int destroy_flag=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns or sets a pointer to the GLContext that this window is using.  <a href="#a446db213805423decdd02e3e71b922c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3194a9fd22b0fd52b77428dc3079dc22"></a><!-- doxytag: member="Fl_Gl_Window::context" ref="a3194a9fd22b0fd52b77428dc3079dc22" args="() const " -->
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a3194a9fd22b0fd52b77428dc3079dc22">context</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">void See void <a class="el" href="classFl__Gl__Window.html#a446db213805423decdd02e3e71b922c5" title="Returns or sets a pointer to the GLContext that this window is using.">context(void* v, int destroy_flag)</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa10e44ec7352009c5234b8bbe005222"></a><!-- doxytag: member="Fl_Gl_Window::context_valid" ref="aaa10e44ec7352009c5234b8bbe005222" args="(char v)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#aaa10e44ec7352009c5234b8bbe005222">context_valid</a> (char v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See char <a class="el" href="classFl__Gl__Window.html#af928eefbfe4244068ef1e2c41256cac9" title="Will only be set if the OpenGL context is created or recreated.">Fl_Gl_Window::context_valid() const</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#af928eefbfe4244068ef1e2c41256cac9">context_valid</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Will only be set if the OpenGL context is created or recreated.  <a href="#af928eefbfe4244068ef1e2c41256cac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#aab388aa943f38ff0806f9022191488b7">Fl_Gl_Window</a> (int W, int H, const char *l=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> widget using the given size, and label string.  <a href="#aab388aa943f38ff0806f9022191488b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a7f5d38a9a2518f7b88e337c25bd6e9f8">Fl_Gl_Window</a> (int X, int Y, int W, int H, const char *l=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> widget using the given position, size, and label string.  <a href="#a7f5d38a9a2518f7b88e337c25bd6e9f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#afc1f3b65a2d872fd21049749179a8f2f">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the window to be drawn, this window is also made current and calls <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a>.  <a href="#afc1f3b65a2d872fd21049749179a8f2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72ef76517e337476c36bc8c1ee12863f"></a><!-- doxytag: member="Fl_Gl_Window::handle" ref="a72ef76517e337476c36bc8c1ee12863f" args="(int)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a72ef76517e337476c36bc8c1ee12863f">handle</a> (int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle some FLTK events as needed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1fb7b91338789fe4d09c22b1ba3dd42"></a><!-- doxytag: member="Fl_Gl_Window::hide" ref="ad1fb7b91338789fe4d09c22b1ba3dd42" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#ad1fb7b91338789fe4d09c22b1ba3dd42">hide</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hides the window and destroys the OpenGL context. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a5c1dbdd6b7f3db71cde2dbf473e87fc3">hide_overlay</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hides the window if it is not this window, does nothing in WIN32.  <a href="#a5c1dbdd6b7f3db71cde2dbf473e87fc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1d517b2fe13e344dc07a17db3e0fa69"></a><!-- doxytag: member="Fl_Gl_Window::invalidate" ref="ac1d517b2fe13e344dc07a17db3e0fa69" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#ac1d517b2fe13e344dc07a17db3e0fa69">invalidate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classFl__Gl__Window.html#ac1d517b2fe13e344dc07a17db3e0fa69" title="The invalidate() method turns off valid() and is equivalent to calling value(0).">invalidate()</a> method turns off <a class="el" href="classFl__Gl__Window.html#ad7b2582be98225d1f25deaf31f7965ed" title="Is turned off when FLTK creates a new context for this window or when the window resizes, and is turned on after draw() is called.">valid()</a> and is equivalent to calling value(0). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a4371fab1e41f9ffc7340f8e6eb43ac77">make_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classFl__Gl__Window.html#a4371fab1e41f9ffc7340f8e6eb43ac77" title="The make_current() method selects the OpenGL context for the widget.">make_current()</a> method selects the OpenGL context for the widget.  <a href="#a4371fab1e41f9ffc7340f8e6eb43ac77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a02a3cbaed5d2081da7a077284666efc5">make_overlay_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classFl__Gl__Window.html#a02a3cbaed5d2081da7a077284666efc5" title="The make_overlay_current() method selects the OpenGL context for the widget&#39;s overlay.">make_overlay_current()</a> method selects the OpenGL context for the widget's overlay.  <a href="#a02a3cbaed5d2081da7a077284666efc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37e4b342cf03156ad2aeba672f98405b"></a><!-- doxytag: member="Fl_Gl_Window::mode" ref="a37e4b342cf03156ad2aeba672f98405b" args="(const int *a)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a37e4b342cf03156ad2aeba672f98405b">mode</a> (const int *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See Fl_Mode <a class="el" href="classFl__Gl__Window.html#a39e19bba95c76952c14c5981e52b5722" title="Set or change the OpenGL capabilites of the window.">mode() const</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Enumerations_8H.html#aae982ff3b1a082b1a512b216b98061e0">Fl_Mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a39e19bba95c76952c14c5981e52b5722">mode</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or change the OpenGL capabilites of the window.  <a href="#a39e19bba95c76952c14c5981e52b5722"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae15f083570bcbf260dddf0bf6efbdd6e"></a><!-- doxytag: member="Fl_Gl_Window::mode" ref="ae15f083570bcbf260dddf0bf6efbdd6e" args="(int a)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#ae15f083570bcbf260dddf0bf6efbdd6e">mode</a> (int a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See Fl_Mode <a class="el" href="classFl__Gl__Window.html#a39e19bba95c76952c14c5981e52b5722" title="Set or change the OpenGL capabilites of the window.">mode() const</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#aab409c2e0ff65ceca7671bb8c24118ac">ortho</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the projection so 0,0 is in the lower left of the window and each pixel is 1 unit wide/tall.  <a href="#aab409c2e0ff65ceca7671bb8c24118ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#ae761ac18430e9e172ca5550c0e0d963a">redraw_overlay</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method causes draw_overlay() to be called at a later time.  <a href="#ae761ac18430e9e172ca5550c0e0d963a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#aff3bb62b9ce1d0c35c3df085bb21da92">resize</a> (int, int, int, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size and position of the window.  <a href="#aff3bb62b9ce1d0c35c3df085bb21da92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a604e670af86586d4200a239032eb63e6">show</a> (int a, char **b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the window on the screen and parses command-line arguments.  <a href="#a604e670af86586d4200a239032eb63e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a05f9c5395325f1f5a905207f0ccb994a">show</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the window on the screen.  <a href="#a05f9c5395325f1f5a905207f0ccb994a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a087a8ce705b389453188207ee0487677">swap_buffers</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classFl__Gl__Window.html#a087a8ce705b389453188207ee0487677" title="The swap_buffers() method swaps the back and front buffers.">swap_buffers()</a> method swaps the back and front buffers.  <a href="#a087a8ce705b389453188207ee0487677"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae82f29e1dac5a492a549b50658f0d1d1"></a><!-- doxytag: member="Fl_Gl_Window::valid" ref="ae82f29e1dac5a492a549b50658f0d1d1" args="(char v)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#ae82f29e1dac5a492a549b50658f0d1d1">valid</a> (char v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See char <a class="el" href="classFl__Gl__Window.html#ad7b2582be98225d1f25deaf31f7965ed" title="Is turned off when FLTK creates a new context for this window or when the window resizes, and is turned on after draw() is called.">Fl_Gl_Window::valid() const</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#ad7b2582be98225d1f25deaf31f7965ed">valid</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is turned off when FLTK creates a new context for this window or when the window resizes, and is turned on <em>after</em> <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> is called.  <a href="#ad7b2582be98225d1f25deaf31f7965ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99e9d4d3ae76a4fbac94ac25b05f041f"></a><!-- doxytag: member="Fl_Gl_Window::~Fl_Gl_Window" ref="a99e9d4d3ae76a4fbac94ac25b05f041f" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a99e9d4d3ae76a4fbac94ac25b05f041f">~Fl_Gl_Window</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor removes the widget and destroys the OpenGL context associated with it. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a37b275e946681e1e52c8bb40ce492737">can_do</a> (int m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the hardware supports the given or current OpenGL mode.  <a href="#a37b275e946681e1e52c8bb40ce492737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a92a9529ed8149af246ede5b7ca59643a">can_do</a> (const int *m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the hardware supports the given or current OpenGL mode.  <a href="#a92a9529ed8149af246ede5b7ca59643a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6">draw</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>.  <a href="#a2250b48ed4de1541aac6253b3e02a3d6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02d01c39c758557b7d506a865413ba57"></a><!-- doxytag: member="Fl_Gl_Window::_Fl_Gl_Overlay" ref="a02d01c39c758557b7d506a865413ba57" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>_Fl_Gl_Overlay</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> widget sets things up so OpenGL works. </p>
<p>It also keeps an OpenGL "context" for that window, so that changes to the lighting and projection may be reused between redraws. <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> also flushes the OpenGL streams and swaps buffers after <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> returns.</p>
<p>OpenGL hardware typically provides some overlay bit planes, which are very useful for drawing UI controls atop your 3D graphics. If the overlay hardware is not provided, FLTK tries to simulate the overlay. This works pretty well if your graphics are double buffered, but not very well for single-buffered.</p>
<p>Please note that the FLTK drawing and clipping functions will not work inside an <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>. All drawing should be done using OpenGL calls exclusively. Even though <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> is derived from <a class="el" href="classFl__Group.html" title="The Fl_Group class is the FLTK container widget.">Fl_Group</a>, it is not useful to add other FLTK Widgets as children, unless those widgets are modified to draw using OpenGL calls. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aab388aa943f38ff0806f9022191488b7"></a><!-- doxytag: member="Fl_Gl_Window::Fl_Gl_Window" ref="aab388aa943f38ff0806f9022191488b7" args="(int W, int H, const char *l=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Gl_Window::Fl_Gl_Window </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>l</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> widget using the given size, and label string. </p>
<p>The default boxtype is FL_NO_BOX. The default mode is FL_RGB|FL_DOUBLE|FL_DEPTH. </p>

</div>
</div>
<a class="anchor" id="a7f5d38a9a2518f7b88e337c25bd6e9f8"></a><!-- doxytag: member="Fl_Gl_Window::Fl_Gl_Window" ref="a7f5d38a9a2518f7b88e337c25bd6e9f8" args="(int X, int Y, int W, int H, const char *l=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Gl_Window::Fl_Gl_Window </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>l</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> widget using the given position, size, and label string. </p>
<p>The default boxtype is FL_NO_BOX. The default mode is FL_RGB|FL_DOUBLE|FL_DEPTH. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afcc185ba5105903e5a1f87def93295c5"></a><!-- doxytag: member="Fl_Gl_Window::as_gl_window" ref="afcc185ba5105903e5a1f87def93295c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFl__Gl__Window.html">Fl_Gl_Window</a>* Fl_Gl_Window::as_gl_window </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> pointer if this widget is an <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>. </p>
<p>Use this method if you have a widget (pointer) and need to know whether this widget is derived from <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>. If it returns non-NULL, then the widget in question is derived from <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if this widget is not derived from <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is provided to avoid dynamic_cast. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl__Widget.html#a645c3112dc8c242b099ef8aee45fe7ee" title="Returns an Fl_Group pointer if this widget is an Fl_Group.">Fl_Widget::as_group()</a>, <a class="el" href="classFl__Widget.html#a464c6760c08e56cf53338398e5bc60f4" title="Returns an Fl_Window pointer if this widget is an Fl_Window.">Fl_Widget::as_window()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classFl__Widget.html#a5951fcf543a56357c2375657c7db6314">Fl_Widget</a>.</p>

</div>
</div>
<a class="anchor" id="a37b275e946681e1e52c8bb40ce492737"></a><!-- doxytag: member="Fl_Gl_Window::can_do" ref="a37b275e946681e1e52c8bb40ce492737" args="(int m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl_Gl_Window::can_do </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if the hardware supports the given or current OpenGL mode. </p>

</div>
</div>
<a class="anchor" id="a92a9529ed8149af246ede5b7ca59643a"></a><!-- doxytag: member="Fl_Gl_Window::can_do" ref="a92a9529ed8149af246ede5b7ca59643a" args="(const int *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl_Gl_Window::can_do </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if the hardware supports the given or current OpenGL mode. </p>

</div>
</div>
<a class="anchor" id="a351d72f872e59ac05ca06fd65cdc25c7"></a><!-- doxytag: member="Fl_Gl_Window::can_do" ref="a351d72f872e59ac05ca06fd65cdc25c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Gl_Window::can_do </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if the hardware supports the given or current OpenGL mode. </p>

</div>
</div>
<a class="anchor" id="a01a3a32a3c3a58d86c747732b2771c8b"></a><!-- doxytag: member="Fl_Gl_Window::can_do_overlay" ref="a01a3a32a3c3a58d86c747732b2771c8b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Gl_Window::can_do_overlay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the hardware overlay is possible. </p>
<p>If this is false, FLTK will try to simulate the overlay, with significant loss of update speed. Calling this will cause FLTK to open the display. </p>

</div>
</div>
<a class="anchor" id="a446db213805423decdd02e3e71b922c5"></a><!-- doxytag: member="Fl_Gl_Window::context" ref="a446db213805423decdd02e3e71b922c5" args="(void *, int destroy_flag=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::context </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destroy_flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns or sets a pointer to the GLContext that this window is using. </p>
<p>This is a system-dependent structure, but it is portable to copy the context from one window to another. You can also set it to NULL, which will force FLTK to recreate the context the next time <a class="el" href="classFl__Gl__Window.html#a4371fab1e41f9ffc7340f8e6eb43ac77" title="The make_current() method selects the OpenGL context for the widget.">make_current()</a> is called, this is useful for getting around bugs in OpenGL implementations.</p>
<p>If <em>destroy_flag</em> is true the context will be destroyed by fltk when the window is destroyed, or when the mode() is changed, or the next time context(x) is called. </p>

</div>
</div>
<a class="anchor" id="af928eefbfe4244068ef1e2c41256cac9"></a><!-- doxytag: member="Fl_Gl_Window::context_valid" ref="af928eefbfe4244068ef1e2c41256cac9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Gl_Window::context_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Will only be set if the OpenGL context is created or recreated. </p>
<p>It differs from <a class="el" href="classFl__Gl__Window.html#ad7b2582be98225d1f25deaf31f7965ed" title="Is turned off when FLTK creates a new context for this window or when the window resizes, and is turned on after draw() is called.">Fl_Gl_Window::valid()</a> which is also set whenever the context changes size. </p>

</div>
</div>
<a class="anchor" id="a2250b48ed4de1541aac6253b3e02a3d6"></a><!-- doxytag: member="Fl_Gl_Window::draw" ref="a2250b48ed4de1541aac6253b3e02a3d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::draw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws the <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>. </p>
<p>You <em><b>must</b> subclass</em> <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> and provide an implementation for <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a>.</p>
<p>You <em><b>must</b> override</em> the <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> method.</p>
<p>You may also provide an implementation of draw_overlay() if you want to draw into the overlay planes. You can avoid reinitializing the viewport and lights and other things by checking <a class="el" href="classFl__Gl__Window.html#ad7b2582be98225d1f25deaf31f7965ed" title="Is turned off when FLTK creates a new context for this window or when the window resizes, and is turned on after draw() is called.">valid()</a> at the start of <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> and only doing the initialization if it is false.</p>
<p>The <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> method can <em>only</em> use OpenGL calls. Do not attempt to call X, any of the functions in &lt;<a class="el" href="fl__draw_8H.html" title="utility header to pull drawing functions together">FL/fl_draw.H</a>&gt;, or glX directly. Do not call <a class="el" href="gl_8h.html#a9c922d784b80b39b0e64c8f4cfb5d123" title="Creates an OpenGL context.">gl_start()</a> or <a class="el" href="gl_8h.html#ae459013025f0e487fa75dee3ff738659" title="Releases an OpenGL context.">gl_finish()</a>.</p>
<p>If double-buffering is enabled in the window, the back and front buffers are swapped after this function is completed. </p>

<p>Reimplemented from <a class="el" href="classFl__Window.html#a097d8258fa43a4fc3aa9409daeb97b44">Fl_Window</a>.</p>

<p>Reimplemented in <a class="el" href="classFl__Glut__Window.html#a7bde4cf7e1e95c49c417940719e82de3">Fl_Glut_Window</a>.</p>

</div>
</div>
<a class="anchor" id="afc1f3b65a2d872fd21049749179a8f2f"></a><!-- doxytag: member="Fl_Gl_Window::flush" ref="afc1f3b65a2d872fd21049749179a8f2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forces the window to be drawn, this window is also made current and calls <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a>. </p>

<p>Reimplemented from <a class="el" href="classFl__Window.html#a418cef08cf54f1dd794538501f15f08b">Fl_Window</a>.</p>

</div>
</div>
<a class="anchor" id="a5c1dbdd6b7f3db71cde2dbf473e87fc3"></a><!-- doxytag: member="Fl_Gl_Window::hide_overlay" ref="a5c1dbdd6b7f3db71cde2dbf473e87fc3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::hide_overlay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hides the window if it is not this window, does nothing in WIN32. </p>

</div>
</div>
<a class="anchor" id="a4371fab1e41f9ffc7340f8e6eb43ac77"></a><!-- doxytag: member="Fl_Gl_Window::make_current" ref="a4371fab1e41f9ffc7340f8e6eb43ac77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::make_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="classFl__Gl__Window.html#a4371fab1e41f9ffc7340f8e6eb43ac77" title="The make_current() method selects the OpenGL context for the widget.">make_current()</a> method selects the OpenGL context for the widget. </p>
<p>It is called automatically prior to the <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> method being called and can also be used to implement feedback and/or selection within the <a class="el" href="classFl__Gl__Window.html#a72ef76517e337476c36bc8c1ee12863f" title="Handle some FLTK events as needed.">handle()</a> method. </p>

<p>Reimplemented from <a class="el" href="classFl__Window.html#a65a2499309b3fdd1bed463cefa0cd1e2">Fl_Window</a>.</p>

<p>Reimplemented in <a class="el" href="classFl__Glut__Window.html#a6eaee4035c233ed57a751761c12ec620">Fl_Glut_Window</a>.</p>

</div>
</div>
<a class="anchor" id="a02a3cbaed5d2081da7a077284666efc5"></a><!-- doxytag: member="Fl_Gl_Window::make_overlay_current" ref="a02a3cbaed5d2081da7a077284666efc5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::make_overlay_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="classFl__Gl__Window.html#a02a3cbaed5d2081da7a077284666efc5" title="The make_overlay_current() method selects the OpenGL context for the widget&#39;s overlay.">make_overlay_current()</a> method selects the OpenGL context for the widget's overlay. </p>
<p>It is called automatically prior to the draw_overlay() method being called and can also be used to implement feedback and/or selection within the <a class="el" href="classFl__Gl__Window.html#a72ef76517e337476c36bc8c1ee12863f" title="Handle some FLTK events as needed.">handle()</a> method. </p>

</div>
</div>
<a class="anchor" id="a39e19bba95c76952c14c5981e52b5722"></a><!-- doxytag: member="Fl_Gl_Window::mode" ref="a39e19bba95c76952c14c5981e52b5722" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Enumerations_8H.html#aae982ff3b1a082b1a512b216b98061e0">Fl_Mode</a> Fl_Gl_Window::mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set or change the OpenGL capabilites of the window. </p>
<p>The value can be any of the following OR'd together:</p>
<ul>
<li><code>FL_RGB</code> - RGB color (not indexed)</li>
<li><code>FL_RGB8</code> - RGB color with at least 8 bits of each color</li>
<li><code>FL_INDEX</code> - Indexed mode</li>
<li><code>FL_SINGLE</code> - not double buffered</li>
<li><code>FL_DOUBLE</code> - double buffered</li>
<li><code>FL_ACCUM</code> - accumulation buffer</li>
<li><code>FL_ALPHA</code> - alpha channel in color</li>
<li><code>FL_DEPTH</code> - depth buffer</li>
<li><code>FL_STENCIL</code> - stencil buffer</li>
<li><code>FL_MULTISAMPLE</code> - multisample antialiasing</li>
</ul>
<p>FL_RGB and FL_SINGLE have a value of zero, so they are "on" unless you give FL_INDEX or FL_DOUBLE.</p>
<p>If the desired combination cannot be done, FLTK will try turning off FL_MULTISAMPLE. If this also fails the <a class="el" href="classFl__Gl__Window.html#a05f9c5395325f1f5a905207f0ccb994a" title="Puts the window on the screen.">show()</a> will call <a class="el" href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23" title="FLTK calls Fl::error() to output a normal error message.">Fl::error()</a> and not show the window.</p>
<p>You can change the mode while the window is displayed. This is most useful for turning double-buffering on and off. Under X this will cause the old X window to be destroyed and a new one to be created. If this is a top-level window this will unfortunately also cause the window to blink, raise to the top, and be de-iconized, and the xid() will change, possibly breaking other code. It is best to make the GL window a child of another window if you wish to do this!</p>
<p>mode() must not be called within <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> since it changes the current context. </p>

</div>
</div>
<a class="anchor" id="aab409c2e0ff65ceca7671bb8c24118ac"></a><!-- doxytag: member="Fl_Gl_Window::ortho" ref="aab409c2e0ff65ceca7671bb8c24118ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::ortho </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the projection so 0,0 is in the lower left of the window and each pixel is 1 unit wide/tall. </p>
<p>If you are drawing 2D images, your <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> method may want to call this if <a class="el" href="classFl__Gl__Window.html#ad7b2582be98225d1f25deaf31f7965ed" title="Is turned off when FLTK creates a new context for this window or when the window resizes, and is turned on after draw() is called.">valid()</a> is false. </p>

</div>
</div>
<a class="anchor" id="ae761ac18430e9e172ca5550c0e0d963a"></a><!-- doxytag: member="Fl_Gl_Window::redraw_overlay" ref="ae761ac18430e9e172ca5550c0e0d963a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::redraw_overlay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method causes draw_overlay() to be called at a later time. </p>
<p>Initially the overlay is clear. If you want the window to display something in the overlay when it first appears, you must call this immediately after you <a class="el" href="classFl__Gl__Window.html#a05f9c5395325f1f5a905207f0ccb994a" title="Puts the window on the screen.">show()</a> your window. </p>

</div>
</div>
<a class="anchor" id="aff3bb62b9ce1d0c35c3df085bb21da92"></a><!-- doxytag: member="Fl_Gl_Window::resize" ref="aff3bb62b9ce1d0c35c3df085bb21da92" args="(int, int, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the size and position of the window. </p>
<p>If <a class="el" href="classFl__Window.html#aa09300542b2d8b49fc69a037bdd3b742" title="Returns non-zero if show() has been called (but not hide() ).">shown()</a> is true, these changes are communicated to the window server (which may refuse that size and cause a further resize). If <a class="el" href="classFl__Window.html#aa09300542b2d8b49fc69a037bdd3b742" title="Returns non-zero if show() has been called (but not hide() ).">shown()</a> is false, the size and position are used when <a class="el" href="classFl__Gl__Window.html#a05f9c5395325f1f5a905207f0ccb994a" title="Puts the window on the screen.">show()</a> is called. See <a class="el" href="classFl__Group.html" title="The Fl_Group class is the FLTK container widget.">Fl_Group</a> for the effect of resizing on the child widgets.</p>
<p>You can also call the <a class="el" href="classFl__Widget.html" title="Fl_Widget is the base class for all widgets in FLTK.">Fl_Widget</a> methods size(x,y) and position(w,h), which are inline wrappers for this virtual function.</p>
<p>A top-level window can not force, but merely suggest a position and size to the operating system. The window manager may not be willing or able to display a window at the desired position or with the given dimensions. It is up to the application developer to verify window parameters after the resize request. </p>

<p>Reimplemented from <a class="el" href="classFl__Window.html#adb45dff26b1be92975f0cec58ca3d592">Fl_Window</a>.</p>

</div>
</div>
<a class="anchor" id="a05f9c5395325f1f5a905207f0ccb994a"></a><!-- doxytag: member="Fl_Gl_Window::show" ref="a05f9c5395325f1f5a905207f0ccb994a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::show </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Puts the window on the screen. </p>
<p>Usually (on X) this has the side effect of opening the display.</p>
<p>If the window is already shown then it is restored and raised to the top. This is really convenient because your program can call <a class="el" href="classFl__Gl__Window.html#a05f9c5395325f1f5a905207f0ccb994a" title="Puts the window on the screen.">show()</a> at any time, even if the window is already up. It also means that <a class="el" href="classFl__Gl__Window.html#a05f9c5395325f1f5a905207f0ccb994a" title="Puts the window on the screen.">show()</a> serves the purpose of raise() in other toolkits.</p>
<p><a class="el" href="classFl__Window.html#a0d75dfcdc8fb797f9247482da1e0152b" title="Puts the window on the screen and parses command-line arguments.">Fl_Window::show(int argc, char **argv)</a> is used for top-level windows and allows standard arguments to be parsed from the command-line.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl__Window.html#a0d75dfcdc8fb797f9247482da1e0152b" title="Puts the window on the screen and parses command-line arguments.">Fl_Window::show(int argc, char **argv)</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classFl__Window.html#a908afc4420fd505e958f6ed394a86acc">Fl_Window</a>.</p>

</div>
</div>
<a class="anchor" id="a604e670af86586d4200a239032eb63e6"></a><!-- doxytag: member="Fl_Gl_Window::show" ref="a604e670af86586d4200a239032eb63e6" args="(int a, char **b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::show </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Puts the window on the screen and parses command-line arguments. </p>
<p>Usually (on X) this has the side effect of opening the display.</p>
<p>This form should be used for top-level windows, at least for the first (main) window. It allows standard arguments to be parsed from the command-line. You can use <code>argc</code> and <code>argv</code> from main(int argc, char **argv) for this call.</p>
<p>The first call also sets up some system-specific internal variables like the system colors.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>explain which system parameters are set up.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>command-line argument count, usually from main() </td></tr>
    <tr><td class="paramname">argv</td><td>command-line argument vector, usually from main()</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>virtual void <a class="el" href="classFl__Window.html#a908afc4420fd505e958f6ed394a86acc" title="Puts the window on the screen.">Fl_Window::show()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classFl__Window.html#a0d75dfcdc8fb797f9247482da1e0152b">Fl_Window</a>.</p>

</div>
</div>
<a class="anchor" id="a087a8ce705b389453188207ee0487677"></a><!-- doxytag: member="Fl_Gl_Window::swap_buffers" ref="a087a8ce705b389453188207ee0487677" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Gl_Window::swap_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="classFl__Gl__Window.html#a087a8ce705b389453188207ee0487677" title="The swap_buffers() method swaps the back and front buffers.">swap_buffers()</a> method swaps the back and front buffers. </p>
<p>It is called automatically after the <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> method is called. </p>

</div>
</div>
<a class="anchor" id="ad7b2582be98225d1f25deaf31f7965ed"></a><!-- doxytag: member="Fl_Gl_Window::valid" ref="ad7b2582be98225d1f25deaf31f7965ed" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Gl_Window::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is turned off when FLTK creates a new context for this window or when the window resizes, and is turned on <em>after</em> <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> is called. </p>
<p>You can use this inside your <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> method to avoid unnecessarily initializing the OpenGL context. Just do this: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">mywindow::draw</a>() {
     <span class="keywordflow">if</span> (!<a class="code" href="classFl__Gl__Window.html#ad7b2582be98225d1f25deaf31f7965ed" title="Is turned off when FLTK creates a new context for this window or when the window resizes, and is turned on after draw() is called.">valid</a>()) {
       glViewport(0,0,<a class="code" href="classFl__Widget.html#aec9e0a6f77d93e6f8caffc1b0f6abbda" title="Gets the widget width.">w</a>(),<a class="code" href="classFl__Widget.html#a994f71abd8b39c87cef909713d3347f0" title="Gets the widget height.">h</a>());
       glFrustum(...);
       ...other initialization...
     }
     <span class="keywordflow">if</span> (!<a class="code" href="classFl__Gl__Window.html#af928eefbfe4244068ef1e2c41256cac9" title="Will only be set if the OpenGL context is created or recreated.">context_valid</a>()) {
       ...load textures, etc. ...
     }
     ... <a class="code" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw</a> your geometry here ...
    }
</pre></div><p>You can turn <a class="el" href="classFl__Gl__Window.html#ad7b2582be98225d1f25deaf31f7965ed" title="Is turned off when FLTK creates a new context for this window or when the window resizes, and is turned on after draw() is called.">valid()</a> on by calling valid(1). You should only do this after fixing the transformation inside a <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> or after <a class="el" href="classFl__Gl__Window.html#a4371fab1e41f9ffc7340f8e6eb43ac77" title="The make_current() method selects the OpenGL context for the widget.">make_current()</a>. This is done automatically after <a class="el" href="classFl__Gl__Window.html#a2250b48ed4de1541aac6253b3e02a3d6" title="Draws the Fl_Gl_Window.">draw()</a> returns. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Fl__Gl__Window_8H_source.html">Fl_Gl_Window.H</a></li>
<li>Fl_Gl_Overlay.cxx</li>
<li>Fl_Gl_Window.cxx</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classFl__Gl__Window.html">Fl_Gl_Window</a>      </li>

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>


</body>
</html>
