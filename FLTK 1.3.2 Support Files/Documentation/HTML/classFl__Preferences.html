<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FLTK 1.3.2: Fl_Preferences Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classFl__Preferences.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Fl_Preferences Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Fl_Preferences" -->
<p><a class="el" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> provides methods to store user settings between application starts.  
 <a href="classFl__Preferences.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Fl__Preferences_8H_source.html">Fl_Preferences.H</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Fl_Preferences:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classFl__Preferences.png" usemap="#Fl_Preferences_map" alt=""/>
  <map id="Fl_Preferences_map" name="Fl_Preferences_map">
<area href="classFl__Plugin__Manager.html" title="Fl_Plugin_Manager manages link-time and run-time plugin binaries." alt="Fl_Plugin_Manager" shape="rect" coords="0,56,123,80"/>
</map>
 </div></div>

<p><a href="classFl__Preferences-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFl__Preferences_1_1Entry.html">Entry</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences_1_1Name.html">Name</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">'Name' provides a simple method to create numerical or more complex procedural names for entries and groups on the fly.  <a href="classFl__Preferences_1_1Name.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Node</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>RootNode</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">ID</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every Fl_Preferences-Group has a uniqe ID.  <a href="#a7050f8b1c0cbb70693e61bcfbf4f5853"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">Root</a> { <a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cba057fd9ac75376136f30efb0d700e8db4">SYSTEM</a> = 0, 
<a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cbaaf4354ca5ac4df110c2fd1fc36c61053">USER</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the scope of the preferences.  <a href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0fc8533d4cfb2d8c7e67b71b7080129"></a><!-- doxytag: member="Fl_Preferences::clear" ref="ae0fc8533d4cfb2d8c7e67b71b7080129" args="()" -->
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ae0fc8533d4cfb2d8c7e67b71b7080129">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all groups and all entries. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af73078b80334cc3f43542f4862de402b"></a><!-- doxytag: member="Fl_Preferences::deleteAllEntries" ref="af73078b80334cc3f43542f4862de402b" args="()" -->
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#af73078b80334cc3f43542f4862de402b">deleteAllEntries</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all entries. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d7563cd64c29348cd5c4d4c14e97614"></a><!-- doxytag: member="Fl_Preferences::deleteAllGroups" ref="a9d7563cd64c29348cd5c4d4c14e97614" args="()" -->
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a9d7563cd64c29348cd5c4d4c14e97614">deleteAllGroups</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all groups. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a3a1710633307e8e79ba8fd89a803042e">deleteEntry</a> (const char *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a single name/value pair.  <a href="#a3a1710633307e8e79ba8fd89a803042e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a6602c3104b2c5259160cb7e0fe5dd335">deleteGroup</a> (const char *group)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a group.  <a href="#a6602c3104b2c5259160cb7e0fe5dd335"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a9004c55f8c0c9515943b96853ea17940">entries</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries (name/value pairs) in a group.  <a href="#a9004c55f8c0c9515943b96853ea17940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a> (int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an entry.  <a href="#a61bd91e8c3ee2a3f8bccd00ee2a65b8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a05c3d7cbf364d5d1ed350ef33850f702">entryExists</a> (const char *key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if an entry with this name exists.  <a href="#a05c3d7cbf364d5d1ed350ef33850f702"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a7e2ec1496b7eb3cc5b2b9e8f6584c979">Fl_Preferences</a> (const char *path, const char *vendor, const char *application)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this constructor to create or read a preferences file at an arbitrary position in the file system.  <a href="#a7e2ec1496b7eb3cc5b2b9e8f6584c979"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ae2811816dd028d35d8b6b1cafd4f2e44">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">ID</a> id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dataset access point using a dataset ID.  <a href="#ae2811816dd028d35d8b6b1cafd4f2e44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a402ba68241bfefeabcd3665613d81607">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html">Fl_Preferences</a> *parent, const char *group)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or access a group of preferences using a name.  <a href="#a402ba68241bfefeabcd3665613d81607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#af8418ff8af933d22dbb70a082525a74e">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">Root</a> root, const char *vendor, const char *application)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor creates a group that manages name/value pairs and child groups.  <a href="#af8418ff8af933d22dbb70a082525a74e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ac87308454632a4c0a9feb040f42a1a39">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;parent, int groupIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a child group using a given index.  <a href="#ac87308454632a4c0a9feb040f42a1a39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a44b60d610214f1ff60e9603babdea664">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;parent, const char *group)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate or read a new group of entries within another group.  <a href="#a44b60d610214f1ff60e9603babdea664"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a20b8a66cd9fda6f727e391847653c4df">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html">Fl_Preferences</a> *parent, int groupIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49a5569fb0b4f270ff8b343f34d11eac"></a><!-- doxytag: member="Fl_Preferences::Fl_Preferences" ref="a49a5569fb0b4f270ff8b343f34d11eac" args="(const Fl_Preferences &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a49a5569fb0b4f270ff8b343f34d11eac">Fl_Preferences</a> (const <a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create another reference to a Preferences group. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a4d49e9959bc26fdc20641534497f3792">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all preferences to disk.  <a href="#a4d49e9959bc26fdc20641534497f3792"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0d71373c6af5199bc1bb1fb955cb3a64">get</a> (const char *entry, double &amp;value, double defaultValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a0d71373c6af5199bc1bb1fb955cb3a64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a128339abc1a1ff6bca073de3a62b2cb3">get</a> (const char *entry, float &amp;value, float defaultValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a128339abc1a1ff6bca073de3a62b2cb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a30e9d1ae031b06f501779c8937533740">get</a> (const char *entry, char *&amp;value, const char *defaultValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a30e9d1ae031b06f501779c8937533740"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a4b0188c9976139103b5c49761c8b765a">get</a> (const char *entry, void *&amp;value, const void *defaultValue, int defaultSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a4b0188c9976139103b5c49761c8b765a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ae909187975eefda3c8bbef494296bc9f">get</a> (const char *entry, void *value, const void *defaultValue, int defaultSize, int maxSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#ae909187975eefda3c8bbef494296bc9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a1074a165aa35687955568c7a13ba1462">get</a> (const char *entry, char *value, const char *defaultValue, int maxSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a1074a165aa35687955568c7a13ba1462"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0991a0bea2800ce5cd362ff6a778c0d3">get</a> (const char *entry, int &amp;value, int defaultValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a0991a0bea2800ce5cd362ff6a778c0d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#acf3c545a4006ef50b091ed45b6f7ce2a">getUserdataPath</a> (char *path, int pathlen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path that is related to the preferences file and that is usable for additional application data.  <a href="#acf3c545a4006ef50b091ed45b6f7ce2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a8aeb2bab88aea893c700533c5dea3d41">group</a> (int num_group)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the Nth (<code>num_group</code>) group.  <a href="#a8aeb2bab88aea893c700533c5dea3d41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a4009efec7d5505a8060ca7a95c1bee2e">groupExists</a> (const char *key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if a group with this name exists.  <a href="#a4009efec7d5505a8060ca7a95c1bee2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a70cfbe5245270b772806e085603a7ab8">groups</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of groups that are contained within a group.  <a href="#a70cfbe5245270b772806e085603a7ab8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1170302365aa48fbd04335ca52c20319"></a><!-- doxytag: member="Fl_Preferences::id" ref="a1170302365aa48fbd04335ca52c20319" args="()" -->
<a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a1170302365aa48fbd04335ca52c20319">id</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an ID that can later be reused to open more references to this dataset. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ff11b679bec179ebb211c31f8e46f2e"></a><!-- doxytag: member="Fl_Preferences::name" ref="a6ff11b679bec179ebb211c31f8e46f2e" args="()" -->
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a6ff11b679bec179ebb211c31f8e46f2e">name</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this entry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf2e1a8f1904abb41f3cfa195ae9df41"></a><!-- doxytag: member="Fl_Preferences::path" ref="aaf2e1a8f1904abb41f3cfa195ae9df41" args="()" -->
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#aaf2e1a8f1904abb41f3cfa195ae9df41">path</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full path to this entry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a929db63f2f0d24d11c64ee929688b39e">set</a> (const char *entry, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a929db63f2f0d24d11c64ee929688b39e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a1928e8ca3f21f66304951b757f24d70a">set</a> (const char *entry, int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a1928e8ca3f21f66304951b757f24d70a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a3d06e7b756a9c87acc508b835286d569">set</a> (const char *entry, float value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a3d06e7b756a9c87acc508b835286d569"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a8bd606d0dd993488d149204ee0841925">set</a> (const char *entry, float value, int precision)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a8bd606d0dd993488d149204ee0841925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0b2d3935a8ba462d27d0e3c2c9e33841">set</a> (const char *entry, double value, int precision)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a0b2d3935a8ba462d27d0e3c2c9e33841"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a1bbc84064bf5f2675b10724567505fd5">set</a> (const char *entry, const char *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a1bbc84064bf5f2675b10724567505fd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#acc689e9cdf957f7636992d275498d72b">set</a> (const char *entry, const void *value, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#acc689e9cdf957f7636992d275498d72b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#aca6793ffe782ad4a55c604caed794ea9">size</a> (const char *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the value part of an entry.  <a href="#aca6793ffe782ad4a55c604caed794ea9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0eb024a8350c344303755fedb1582185">~Fl_Preferences</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor removes allocated resources.  <a href="#a0eb024a8350c344303755fedb1582185"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ae357c2136fce436e367b92c0337a4778">newUUID</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UUID as generated by the system.  <a href="#ae357c2136fce436e367b92c0337a4778"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b9960e5ac57a9a9af4cb3bfe422320f"></a><!-- doxytag: member="Fl_Preferences::remove" ref="a7b9960e5ac57a9a9af4cb3bfe422320f" args="(ID id_)" -->
static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a7b9960e5ac57a9a9af4cb3bfe422320f">remove</a> (<a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">ID</a> id_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the group with this ID from a database. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5633500be10cea17e2ffb2791f05b6c"></a><!-- doxytag: member="Fl_Preferences::node" ref="ae5633500be10cea17e2ffb2791f05b6c" args="" -->
Node *&#160;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d05b8bf3baf9255771e7c57aa8620cc"></a><!-- doxytag: member="Fl_Preferences::rootNode" ref="a1d05b8bf3baf9255771e7c57aa8620cc" args="" -->
RootNode *&#160;</td><td class="memItemRight" valign="bottom"><b>rootNode</b></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6db9d28bd448a131448276ee03de1e6d"></a><!-- doxytag: member="Fl_Preferences::Node" ref="a6db9d28bd448a131448276ee03de1e6d" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bb397989a4485545d4d65709ce3c863"></a><!-- doxytag: member="Fl_Preferences::RootNode" ref="a3bb397989a4485545d4d65709ce3c863" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>RootNode</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> provides methods to store user settings between application starts. </p>
<p>It is similar to the Registry on WIN32 and Preferences on MacOS, and provides a simple configuration mechanism for UNIX.</p>
<p><a class="el" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> uses a hierarchy to store data. It bundles similar data into groups and manages entries into those groups as name/value pairs.</p>
<p>Preferences are stored in text files that can be edited manually. The file format is easy to read and relatively forgiving. Preferences files are the same on all platforms. User comments in preference files are preserved. Filenames are unique for each application by using a vendor/application naming scheme. The user must provide default values for all entries to ensure proper operation should preferences be corrupted or not yet exist.</p>
<p>Entries can be of any length. However, the size of each preferences file should be kept small for performance reasons. One application can have multiple preferences files. Extensive binary data however should be stored in separate files: see <a class="el" href="classFl__Preferences.html#acf3c545a4006ef50b091ed45b6f7ce2a" title="Creates a path that is related to the preferences file and that is usable for additional application ...">getUserdataPath()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Starting with FLTK 1.3, preference databases are expected to be in UTF-8 encoding. Previous databases were stored in the current character set or code page which renders them incompatible for text entries using international characters. </dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a7050f8b1c0cbb70693e61bcfbf4f5853"></a><!-- doxytag: member="Fl_Preferences::ID" ref="a7050f8b1c0cbb70693e61bcfbf4f5853" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">Fl_Preferences::ID</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every Fl_Preferences-Group has a uniqe ID. </p>
<p>ID's can be retrieved from an Fl_Preferences-Group and can then be used to create more Fl_Preference references to the same data set, as long as the database remains open. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a0947b73d778ca66b9fbb97b75bbbd7cb"></a><!-- doxytag: member="Fl_Preferences::Root" ref="a0947b73d778ca66b9fbb97b75bbbd7cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">Fl_Preferences::Root</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the scope of the preferences. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0947b73d778ca66b9fbb97b75bbbd7cba057fd9ac75376136f30efb0d700e8db4"></a><!-- doxytag: member="SYSTEM" ref="a0947b73d778ca66b9fbb97b75bbbd7cba057fd9ac75376136f30efb0d700e8db4" args="" -->SYSTEM</em>&nbsp;</td><td>
<p>Preferences are used system-wide. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0947b73d778ca66b9fbb97b75bbbd7cbaaf4354ca5ac4df110c2fd1fc36c61053"></a><!-- doxytag: member="USER" ref="a0947b73d778ca66b9fbb97b75bbbd7cbaaf4354ca5ac4df110c2fd1fc36c61053" args="" -->USER</em>&nbsp;</td><td>
<p>Preferences apply only to the current user. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af8418ff8af933d22dbb70a082525a74e"></a><!-- doxytag: member="Fl_Preferences::Fl_Preferences" ref="af8418ff8af933d22dbb70a082525a74e" args="(Root root, const char *vendor, const char *application)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">Root</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vendor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>application</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constructor creates a group that manages name/value pairs and child groups. </p>
<p>Groups are ready for reading and writing at any time. The root argument is either <a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cbaaf4354ca5ac4df110c2fd1fc36c61053" title="Preferences apply only to the current user.">Fl_Preferences::USER</a> or <a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cba057fd9ac75376136f30efb0d700e8db4" title="Preferences are used system-wide.">Fl_Preferences::SYSTEM</a>.</p>
<p>This constructor creates the <em>base</em> instance for all following entries and reads existing databases into memory. The vendor argument is a unique text string identifying the development team or vendor of an application. A domain name or an EMail address are great unique names, e.g. "researchATmatthiasm.com" or "fltk.org". The application argument can be the working title or final name of your application. Both vendor and application must be valid relative UNIX pathnames and may contain '/'s to create deeper file structures.</p>
<p>A set of Preferences marked "run-time" exists exactly one per application and only as long as the application runs. It can be used as a database for volatile information. FLTK uses it to register plugins at run-time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>can be <code>USER</code> or <code>SYSTEM</code> for user specific or system wide preferences </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vendor</td><td>unique text describing the company or author of this file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">application</td><td>unique text describing the application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e2ec1496b7eb3cc5b2b9e8f6584c979"></a><!-- doxytag: member="Fl_Preferences::Fl_Preferences" ref="a7e2ec1496b7eb3cc5b2b9e8f6584c979" args="(const char *path, const char *vendor, const char *application)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vendor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>application</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this constructor to create or read a preferences file at an arbitrary position in the file system. </p>
<p>The file name is generated in the form <code><em>path</em>/<em>application</em>.prefs</code>. If <code>application</code> is <code>NULL</code>, <code>path</code> must contain the full file name.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>path to the directory that contains the preferences file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vendor</td><td>unique text describing the company or author of this file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">application</td><td>unique text describing the application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44b60d610214f1ff60e9603babdea664"></a><!-- doxytag: member="Fl_Preferences::Fl_Preferences" ref="a44b60d610214f1ff60e9603babdea664" args="(Fl_Preferences &amp;parent, const char *group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate or read a new group of entries within another group. </p>
<p>Use the <code>group</code> argument to name the group that you would like to access. <code>Group</code> can also contain a path to a group further down the hierarchy by separating group names with a forward slash '/'.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>reference object for the new group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>name of the group to access (may contain '/'s) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a402ba68241bfefeabcd3665613d81607"></a><!-- doxytag: member="Fl_Preferences::Fl_Preferences" ref="a402ba68241bfefeabcd3665613d81607" args="(Fl_Preferences *parent, const char *group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html">Fl_Preferences</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create or access a group of preferences using a name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>the parameter parent is a pointer to the parent group. <code>Parent</code> may be <code>NULL</code>. It then refers to an application internal database which exists only once, and remains in RAM only until the application quits. This database is used to manage plugins and other data indexes by strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>a group name that is used as a key into the database </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl__Preferences.html#a44b60d610214f1ff60e9603babdea664" title="Generate or read a new group of entries within another group.">Fl_Preferences( Fl_Preferences&amp;, const char *group )</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac87308454632a4c0a9feb040f42a1a39"></a><!-- doxytag: member="Fl_Preferences::Fl_Preferences" ref="ac87308454632a4c0a9feb040f42a1a39" args="(Fl_Preferences &amp;parent, int groupIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a child group using a given index. </p>
<p>Use the <code>groupIndex</code> argument to find the group that you would like to access. If the given index is invalid (negative or too high), a new group is created with a UUID as a name.</p>
<p>The index needs to be fixed. It is currently backward. Index 0 points to the last member in the 'list' of preferences.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>reference object for the new group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">groupIndex</td><td>zero based index into child groups </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20b8a66cd9fda6f727e391847653c4df"></a><!-- doxytag: member="Fl_Preferences::Fl_Preferences" ref="a20b8a66cd9fda6f727e391847653c4df" args="(Fl_Preferences *parent, int groupIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html">Fl_Preferences</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl__Preferences.html#ac87308454632a4c0a9feb040f42a1a39" title="Open a child group using a given index.">Fl_Preferences( Fl_Preferences&amp;, int groupIndex )</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae2811816dd028d35d8b6b1cafd4f2e44"></a><!-- doxytag: member="Fl_Preferences::Fl_Preferences" ref="ae2811816dd028d35d8b6b1cafd4f2e44" args="(ID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">Fl_Preferences::ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new dataset access point using a dataset ID. </p>
<p>ID's are a great way to remember shortcuts to database entries that are deeply nested in a preferences database, as long as the database root is not deleted. An ID can be retrieved from any <a class="el" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> dataset, and can then be used to create multiple new references to the same dataset.</p>
<p>ID's can be very helpful when put into the <code>user_data()</code> field of widget callbacks. </p>

</div>
</div>
<a class="anchor" id="a0eb024a8350c344303755fedb1582185"></a><!-- doxytag: member="Fl_Preferences::~Fl_Preferences" ref="a0eb024a8350c344303755fedb1582185" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::~Fl_Preferences </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The destructor removes allocated resources. </p>
<p>When used on the <em>base</em> preferences group, the destructor flushes all changes to the preferences file and deletes all internal databases.</p>
<p>The destructor does not remove any data from the database. It merely deletes your reference to the database. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3a1710633307e8e79ba8fd89a803042e"></a><!-- doxytag: member="Fl_Preferences::deleteEntry" ref="a3a1710633307e8e79ba8fd89a803042e" args="(const char *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::deleteEntry </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a single name/value pair. </p>
<p>This function removes the entry <code>key</code> from the database.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if deleting the entry failed </dd></dl>

</div>
</div>
<a class="anchor" id="a6602c3104b2c5259160cb7e0fe5dd335"></a><!-- doxytag: member="Fl_Preferences::deleteGroup" ref="a6602c3104b2c5259160cb7e0fe5dd335" args="(const char *group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::deleteGroup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a group. </p>
<p>Removes a group and all keys and groups within that group from the database.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>name of the group to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if call failed </dd></dl>

</div>
</div>
<a class="anchor" id="a9004c55f8c0c9515943b96853ea17940"></a><!-- doxytag: member="Fl_Preferences::entries" ref="a9004c55f8c0c9515943b96853ea17940" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Preferences::entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of entries (name/value pairs) in a group. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of entries </dd></dl>

</div>
</div>
<a class="anchor" id="a61bd91e8c3ee2a3f8bccd00ee2a65b8d"></a><!-- doxytag: member="Fl_Preferences::entry" ref="a61bd91e8c3ee2a3f8bccd00ee2a65b8d" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Fl_Preferences::entry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name of an entry. </p>
<p>There is no guaranteed order of entry names. The index must be within the range given by <a class="el" href="classFl__Preferences.html#a9004c55f8c0c9515943b96853ea17940" title="Returns the number of entries (name/value pairs) in a group.">entries()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>number indexing the requested entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to value cstring </dd></dl>

</div>
</div>
<a class="anchor" id="a05c3d7cbf364d5d1ed350ef33850f702"></a><!-- doxytag: member="Fl_Preferences::entryExists" ref="a05c3d7cbf364d5d1ed350ef33850f702" args="(const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::entryExists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if an entry with this name exists. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry that is searched for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if entry was not found </dd></dl>

</div>
</div>
<a class="anchor" id="a4d49e9959bc26fdc20641534497f3792"></a><!-- doxytag: member="Fl_Preferences::flush" ref="a4d49e9959bc26fdc20641534497f3792" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Preferences::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes all preferences to disk. </p>
<p>This function works only with the base preferences group. This function is rarely used as deleting the base preferences flushes automatically. </p>

</div>
</div>
<a class="anchor" id="a30e9d1ae031b06f501779c8937533740"></a><!-- doxytag: member="Fl_Preferences::get" ref="a30e9d1ae031b06f501779c8937533740" args="(const char *entry, char *&amp;value, const char *defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0). <a class="el" href="classFl__Preferences.html#a0991a0bea2800ce5cd362ff6a778c0d3" title="Reads an entry from the group.">get()</a> allocates memory of sufficient size to hold the value. The buffer must be free'd by the developer using 'free(value)'.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">text</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a0991a0bea2800ce5cd362ff6a778c0d3"></a><!-- doxytag: member="Fl_Preferences::get" ref="a0991a0bea2800ce5cd362ff6a778c0d3" args="(const char *entry, int &amp;value, int defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a128339abc1a1ff6bca073de3a62b2cb3"></a><!-- doxytag: member="Fl_Preferences::get" ref="a128339abc1a1ff6bca073de3a62b2cb3" args="(const char *entry, float &amp;value, float defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a0d71373c6af5199bc1bb1fb955cb3a64"></a><!-- doxytag: member="Fl_Preferences::get" ref="a0d71373c6af5199bc1bb1fb955cb3a64" args="(const char *entry, double &amp;value, double defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a1074a165aa35687955568c7a13ba1462"></a><!-- doxytag: member="Fl_Preferences::get" ref="a1074a165aa35687955568c7a13ba1462" args="(const char *entry, char *value, const char *defaultValue, int maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0). 'maxSize' is the maximum length of text that will be read. The text buffer must allow for one additional byte for a trailing zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">text</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>maximum length of value plus one byte for a trailing zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a4b0188c9976139103b5c49761c8b765a"></a><!-- doxytag: member="Fl_Preferences::get" ref="a4b0188c9976139103b5c49761c8b765a" args="(const char *entry, void *&amp;value, const void *defaultValue, int defaultSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>defaultValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0). <a class="el" href="classFl__Preferences.html#a0991a0bea2800ce5cd362ff6a778c0d3" title="Reads an entry from the group.">get()</a> allocates memory of sufficient size to hold the value. The buffer must be free'd by the developer using 'free(value)'.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultSize</td><td>size of default value array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="ae909187975eefda3c8bbef494296bc9f"></a><!-- doxytag: member="Fl_Preferences::get" ref="ae909187975eefda3c8bbef494296bc9f" args="(const char *entry, void *value, const void *defaultValue, int defaultSize, int maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>defaultValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0). 'maxSize' is the maximum length of text that will be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>value returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultSize</td><td>size of default value array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>maximum length of value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the default value was used</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>maxSize should receive the number of bytes that were read. </dd></dl>

</div>
</div>
<a class="anchor" id="acf3c545a4006ef50b091ed45b6f7ce2a"></a><!-- doxytag: member="Fl_Preferences::getUserdataPath" ref="acf3c545a4006ef50b091ed45b6f7ce2a" args="(char *path, int pathlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::getUserdataPath </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pathlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a path that is related to the preferences file and that is usable for additional application data. </p>
<p>This function creates a directory that is named after the preferences database without the <code></code>.prefs extension and located in the same directory. It then fills the given buffer with the complete path name.</p>
<p>Exmaple: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> prefs( <a class="code" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cbaaf4354ca5ac4df110c2fd1fc36c61053" title="Preferences apply only to the current user.">USER</a>, <span class="stringliteral">&quot;matthiasm.com&quot;</span>, <span class="stringliteral">&quot;test&quot;</span> );
 <span class="keywordtype">char</span> <a class="code" href="classFl__Preferences.html#aaf2e1a8f1904abb41f3cfa195ae9df41" title="Return the full path to this entry.">path</a>[<a class="code" href="group__filenames.html#ga29253083ed9918c2f9d532bd5ed89cc3" title="all path buffers should use this length">FL_PATH_MAX</a>];
 prefs.getUserdataPath( path );
</pre></div><p> creates the preferences database in (MS Windows): </p>
<div class="fragment"><pre class="fragment"> c:/Documents and Settings/matt/Application Data/matthiasm.com/test.prefs
</pre></div><p> and returns the userdata path: </p>
<div class="fragment"><pre class="fragment"> c:/Documents and Settings/matt/Application Data/matthiasm.com/test/
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>buffer for user data path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathlen</td><td>size of path buffer (should be at least <code>FL_PATH_MAX</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if path was not created or pathname can't fit into buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a8aeb2bab88aea893c700533c5dea3d41"></a><!-- doxytag: member="Fl_Preferences::group" ref="a8aeb2bab88aea893c700533c5dea3d41" args="(int num_group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Fl_Preferences::group </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name of the Nth (<code>num_group</code>) group. </p>
<p>There is no guaranteed order of group names. The index must be within the range given by <a class="el" href="classFl__Preferences.html#a70cfbe5245270b772806e085603a7ab8" title="Returns the number of groups that are contained within a group.">groups()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_group</td><td>number indexing the requested group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>'C' string pointer to the group name </dd></dl>

</div>
</div>
<a class="anchor" id="a4009efec7d5505a8060ca7a95c1bee2e"></a><!-- doxytag: member="Fl_Preferences::groupExists" ref="a4009efec7d5505a8060ca7a95c1bee2e" args="(const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::groupExists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if a group with this name exists. </p>
<p>Group names are relative to the Preferences node and can contain a path. "." describes the current node, "./" describes the topmost node. By preceding a groupname with a "./", its path becomes relative to the topmost node.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of group that is searched for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no group by that name was found </dd></dl>

</div>
</div>
<a class="anchor" id="a70cfbe5245270b772806e085603a7ab8"></a><!-- doxytag: member="Fl_Preferences::groups" ref="a70cfbe5245270b772806e085603a7ab8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Preferences::groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of groups that are contained within a group. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for no groups at all </dd></dl>

</div>
</div>
<a class="anchor" id="ae357c2136fce436e367b92c0337a4778"></a><!-- doxytag: member="Fl_Preferences::newUUID" ref="ae357c2136fce436e367b92c0337a4778" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Fl_Preferences::newUUID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a UUID as generated by the system. </p>
<p>A UUID is a "universally unique identifier" which is commonly used in configuration files to create identities. A UUID in ASCII looks like this: <code>937C4900-51AA-4C11-8DD3-7AB59944F03E</code>. It has always 36 bytes plus a trailing zero.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a static buffer containing the new UUID in ASCII format. The buffer is overwritten during every call to this function! </dd></dl>

</div>
</div>
<a class="anchor" id="a3d06e7b756a9c87acc508b835286d569"></a><!-- doxytag: member="Fl_Preferences::set" ref="a3d06e7b756a9c87acc508b835286d569" args="(const char *entry, float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a0b2d3935a8ba462d27d0e3c2c9e33841"></a><!-- doxytag: member="Fl_Preferences::set" ref="a0b2d3935a8ba462d27d0e3c2c9e33841" args="(const char *entry, double value, int precision)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>number of decimal digits to represent value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a929db63f2f0d24d11c64ee929688b39e"></a><!-- doxytag: member="Fl_Preferences::set" ref="a929db63f2f0d24d11c64ee929688b39e" args="(const char *entry, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a1bbc84064bf5f2675b10724567505fd5"></a><!-- doxytag: member="Fl_Preferences::set" ref="a1bbc84064bf5f2675b10724567505fd5" args="(const char *entry, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>set this entry to <code>value</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="acc689e9cdf957f7636992d275498d72b"></a><!-- doxytag: member="Fl_Preferences::set" ref="acc689e9cdf957f7636992d275498d72b" args="(const char *entry, const void *value, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>set this entry to <code>value</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dsize</td><td>size of data array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a1928e8ca3f21f66304951b757f24d70a"></a><!-- doxytag: member="Fl_Preferences::set" ref="a1928e8ca3f21f66304951b757f24d70a" args="(const char *entry, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a8bd606d0dd993488d149204ee0841925"></a><!-- doxytag: member="Fl_Preferences::set" ref="a8bd606d0dd993488d149204ee0841925" args="(const char *entry, float value, int precision)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>number of decimal digits to represent value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="aca6793ffe782ad4a55c604caed794ea9"></a><!-- doxytag: member="Fl_Preferences::size" ref="aca6793ffe782ad4a55c604caed794ea9" args="(const char *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Preferences::size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the value part of an entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of value </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Fl__Preferences_8H_source.html">Fl_Preferences.H</a></li>
<li>Fl_Preferences.cxx</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classFl__Preferences.html">Fl_Preferences</a>      </li>

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>


</body>
</html>
