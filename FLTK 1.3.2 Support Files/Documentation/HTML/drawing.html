<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FLTK 1.3.2: Drawing Things in FLTK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('drawing.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Drawing Things in FLTK </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>This chapter covers the drawing functions that are provided with FLTK.</p>
<h2><a class="anchor" id="sect_WhenCanYouDraw"></a>
When Can You Draw Things in FLTK?</h2>
<p>There are only certain places you can execute drawing code in FLTK. Calling these functions at other places will result in undefined behavior!</p>
<ul>
<li>The most common place is inside the virtual <a class="el" href="classFl__Widget.html#a1acb38c6b3cb40452ad02ccfeedbac8a" title="Draws the widget.">Fl_Widget::draw()</a> method. To write code here, you must subclass one of the existing <a class="el" href="classFl__Widget.html" title="Fl_Widget is the base class for all widgets in FLTK.">Fl_Widget</a> classes and implement your own version of draw().</li>
</ul>
<ul>
<li>You can also create custom <a class="el" href="common.html#common_boxtypes">boxtypes</a> and <a class="el" href="common.html#common_labeltype">labeltypes</a>. These involve writing small procedures that can be called by existing <a class="el" href="classFl__Widget.html#a1acb38c6b3cb40452ad02ccfeedbac8a" title="Draws the widget.">Fl_Widget::draw()</a> methods. These "types" are identified by an 8-bit index that is stored in the widget's <code>box()</code>, <code>labeltype()</code>, and possibly other properties.</li>
</ul>
<ul>
<li>You can call <a class="el" href="classFl__Window.html#a65a2499309b3fdd1bed463cefa0cd1e2" title="Sets things up so that the drawing functions in &lt;FL/fl_draw.H&gt; will go into this window.">Fl_Window::make_current()</a> to do incremental update of a widget. Use <a class="el" href="classFl__Widget.html#af8834d376878616c66a094cad6fec9d2" title="Returns a pointer to the nearest parent window up the widget hierarchy.">Fl_Widget::window()</a> to find the window.</li>
</ul>
<h2><a class="anchor" id="sect_DrawingFunctions"></a>
Drawing Functions</h2>
<p>To use the drawing functions you must first include the &lt;<a class="el" href="fl__draw_8H.html" title="utility header to pull drawing functions together">FL/fl_draw.H</a>&gt; header file. FLTK provides the following types of drawing functions:</p>
<ul>
<li><a class="el" href="drawing.html#ssect_Boxes">Boxes</a> </li>
<li><a class="el" href="drawing.html#ssect_Clipping">Clipping</a> </li>
<li><a class="el" href="drawing.html#drawing_colors">Colors</a> </li>
<li><a class="el" href="drawing.html#ssect_Lines">Line Dashes and Thickness</a> </li>
<li><a class="el" href="drawing.html#ssect_Fast">Drawing Fast Shapes</a> </li>
<li><a class="el" href="drawing.html#ssect_Complex">Drawing Complex Shapes</a> </li>
<li><a class="el" href="drawing.html#ssect_Text">Drawing Text</a> </li>
<li><a class="el" href="drawing.html#ssect_Fonts">Fonts</a> </li>
<li><a class="el" href="drawing.html#ssect_CharacterEncoding">Character Encoding</a> </li>
<li><a class="el" href="drawing.html#ssect_Overlay">Drawing Overlays</a> </li>
<li><a class="el" href="drawing.html#drawing_images">Drawing Images</a> </li>
<li><a class="el" href="drawing.html#ssect_DirectImageDrawing">Direct Image Drawing</a> </li>
<li><a class="el" href="drawing.html#ssect_DirectImageReading">Direct Image Reading</a> </li>
<li><a class="el" href="drawing.html#ssect_Fl_Image">Image Classes</a> </li>
<li><a class="el" href="drawing.html#ssect_Offscreen">Offscreen Drawing</a></li>
</ul>
<h3><a class="anchor" id="ssect_Boxes"></a>
Boxes</h3>
<p>FLTK provides three functions that can be used to draw boxes for buttons and other UI controls. Each function uses the supplied upper-lefthand corner and width and height to determine where to draw the box.</p>
<p>void <a class="el" href="group__fl__drawings.html#ga475ff2bbcafeb30d4551f635e42d6259" title="Draws a box using given type, position, size and color.">fl_draw_box(Fl_Boxtype b, int x, int y, int w, int h, Fl_Color c)</a>;</p>
<dl class="user"><dt><b></b></dt><dd>The <code>fl_draw_box</code>() function draws a standard boxtype <code>b</code> in the specified color <code>c</code>.</dd></dl>
<p><a class="anchor" id="drawing_fl_frame"></a> void <a class="el" href="group__fl__drawings.html#ga2e109cb030c3f2fbef45156c687b8138" title="Draws a series of line segments around the given box.">fl_frame(const char *s, int x, int y, int w, int h)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gaaae63e60444c66e89a83111132507e16" title="Draws a series of line segments around the given box.">fl_frame2(const char *s, int x, int y, int w, int h)</a></p>
<dl class="user"><dt><b></b></dt><dd>The <code>fl_frame</code>() and <code>fl_frame2</code>() functions draw a series of line segments around the given box. The string <code>s</code> must contain groups of 4 letters which specify one of 24 standard grayscale values, where 'A' is black and 'X' is white. The results of calling these functions with a string that is not a multiple of 4 characters in length are undefined.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The only difference between <code>fl_frame</code>() and <code>fl_frame2</code>() is the order of the line segments:<ul>
<li>For <code>fl_frame</code>() the order of each set of 4 characters is: top, left, bottom, right.</li>
<li>For <code>fl_frame2</code>() the order of each set of 4 characters is: bottom, right, top, left.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that <a class="el" href="common.html#common_fl_frame">fl_frame(Fl_Boxtype b)</a> is described in the <a class="el" href="common.html#common_boxtypes">Box Types</a> section.</dd></dl>
<h3><a class="anchor" id="ssect_Clipping"></a>
Clipping</h3>
<p>You can limit all your drawing to a rectangular region by calling <code>fl_push_clip</code>(), and put the drawings back by using <code>fl_pop_clip</code>(). This rectangle is measured in pixels and is unaffected by the current transformation matrix.</p>
<p>In addition, the system may provide clipping when updating windows which may be more complex than a simple rectangle.</p>
<p>void <a class="el" href="group__fl__drawings.html#gabe60242ba3b975800717b95cb6bc06d2" title="Intersects the current clip region with a rectangle and pushes this new region onto the stack...">fl_push_clip(int x, int y, int w, int h)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga0061bafa4252431de247713975e4c3ef" title="Intersects the current clip region with a rectangle and pushes this new region onto the stack (deprec...">fl_clip(int x, int y, int w, int h)</a></p>
<dl class="user"><dt><b></b></dt><dd>Intersect the current clip region with a rectangle and push this new region onto the stack.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>fl_clip</code>() version is deprecated and will be removed from future releases.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga0fce6c81d69c3a80c8073a338f1346fd" title="Pushes an empty clip region onto the stack so nothing will be clipped.">fl_push_no_clip()</a></p>
<dl class="user"><dt><b></b></dt><dd>Pushes an empty clip region on the stack so nothing will be clipped.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga7abb216a9a87408c8926126cc9efce22" title="Restores the previous clip region.">fl_pop_clip()</a></p>
<dl class="user"><dt><b></b></dt><dd>Restore the previous clip region.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>Note:</b> You must call <code>fl_pop_clip</code>() once for every time you call <code>fl_push_clip</code>(). If you return to FLTK with the clip stack not empty unpredictable results occur.</dd></dl>
<p>int <a class="el" href="group__fl__drawings.html#ga2bd899d466196ffc26cc61542ee10539" title="Does the rectangle intersect the current clip region?">fl_not_clipped(int x, int y, int w, int h)</a></p>
<dl class="user"><dt><b></b></dt><dd>Returns non-zero if any of the rectangle intersects the current clip region. If this returns 0 you don't have to draw the object.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>Note:</b> Under X this returns 2 if the rectangle is partially clipped, and 1 if it is entirely inside the clip region.</dd></dl>
<p>int <a class="el" href="group__fl__drawings.html#ga6ec7356beb51a8f1d2b987f4d00f42d8" title="Intersects the rectangle with the current clip region and returns the bounding box of the result...">fl_clip_box(int x, int y, int w, int h, int &amp;X, int &amp;Y, int &amp;W, int &amp;H)</a></p>
<dl class="user"><dt><b></b></dt><dd>Intersect the rectangle <code>x,y,w,h</code> with the current clip region and returns the bounding box of the result in <code>X,Y,W,H</code>. Returns non-zero if the resulting rectangle is different than the original. This can be used to limit the necessary drawing to a rectangle. <code>W</code> and <code>H</code> are set to zero if the rectangle is completely outside the region.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#gab12cb4aaa22092a0f2ae3d349c57f234" title="Replaces the top of the clipping stack with a clipping region of any shape.">fl_clip_region(Fl_Region r)</a> <br/>
 Fl_Region <a class="el" href="group__fl__drawings.html#gab12cb4aaa22092a0f2ae3d349c57f234" title="Replaces the top of the clipping stack with a clipping region of any shape.">fl_clip_region()</a></p>
<dl class="user"><dt><b></b></dt><dd>Replace the top of the clip stack with a clipping region of any shape. Fl_Region is an operating system specific type. The second form returns the current clipping region.</dd></dl>
<h2><a class="anchor" id="drawing_colors"></a>
Colors</h2>
<p>FLTK manages colors as 32-bit unsigned integers, encoded as RGBI. When the "RGB" bytes are non-zero, the value is treated as RGB. If these bytes are zero, the "I" byte will be used as an index into the colormap. Colors with both "RGB" set and an "I" &gt;0 are reserved for special use.</p>
<p>Values from 0 to 255, i.e. the "I" index value, represent colors from the FLTK 1.3.x standard colormap and are allocated as needed on screens without TrueColor support. The <b>Fl_Color</b> enumeration type defines the standard colors and color cube for the first 256 colors. All of these are named with symbols in <a class="el" href="enumerations.html">&lt;FL/Enumerations.H&gt;</a>. Example:</p>
<div class="image">
<img src="fltk-colormap.png" alt="fltk-colormap.png"/>
<div class="caption">
FLTK default colormap (Fl_Color 0x00 - 0xff)</div></div>
 <p>Color values greater than 255 are treated as 24-bit RGB values. These are mapped to the closest color supported by the screen, either from one of the 256 colors in the FLTK 1.3.x colormap or a direct RGB value on TrueColor screens.</p>
<p>Fl_Color <a class="el" href="Enumerations_8H.html#a7c5acc4633fbab7016bce2fb69046494" title="Returns the 24-bit color value closest to r, g, b.">fl_rgb_color(uchar r, uchar g, uchar b)</a> <br/>
 Fl_Color <a class="el" href="Enumerations_8H.html#af26a6486e65decd723fbe5c1f43deb0b" title="Returns the 24-bit color value closest to g (grayscale).">fl_rgb_color(uchar grayscale)</a></p>
<dl class="user"><dt><b></b></dt><dd>Generate Fl_Color out of specified 8-bit RGB values or one 8-bit grayscale value.</dd></dl>
<p>void <a class="el" href="group__fl__attributes.html#ga974e9f64959aa83cf6f0a36d3f0105aa" title="Sets the color for all subsequent drawing operations.">fl_color(Fl_Color c)</a> <br/>
 void <a class="el" href="group__fl__attributes.html#ga40be3354c55ced3fb119e063cd832716" title="for back compatibility - use fl_color(Fl_Color c) instead">fl_color(int c)</a></p>
<dl class="user"><dt><b></b></dt><dd>Sets the color for all subsequent drawing operations. Please use the first form: the second form is only provided for back compatibility.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>For colormapped displays, a color cell will be allocated out of <code>fl_colormap</code> the first time you use a color. If the colormap fills up then a least-squares algorithm is used to find the closest color.</dd></dl>
<p>Fl_Color <a class="el" href="group__fl__attributes.html#ga974e9f64959aa83cf6f0a36d3f0105aa" title="Sets the color for all subsequent drawing operations.">fl_color()</a></p>
<dl class="user"><dt><b></b></dt><dd>Returns the last color that was set using <code>fl_color</code>(). This can be used for state save/restore.</dd></dl>
<p>void <a class="el" href="group__fl__attributes.html#ga208595f1c4e4bd0c32ee5a56194b405c" title="Sets the color for all subsequent drawing operations.">fl_color(uchar r, uchar g, uchar b)</a></p>
<dl class="user"><dt><b></b></dt><dd>Set the color for all subsequent drawing operations. The closest possible match to the RGB color is used. The RGB color is used directly on TrueColor displays. For colormap visuals the nearest index in the gray ramp or color cube is used.</dd></dl>
<p>unsigned <a class="el" href="group__fl__attributes.html#ga9977c7ef50c9f51efd0d7909020a16da" title="Returns the RGB value(s) for the given FLTK color index.">Fl::get_color(Fl_Color i)</a> <br/>
 void <a class="el" href="group__fl__attributes.html#ga4eb8db6ea9968f546687f89a4ec336a0" title="Returns the RGB value(s) for the given FLTK color index.">Fl::get_color(Fl_Color i, uchar &amp;red, uchar &amp;green, uchar &amp;blue)</a></p>
<dl class="user"><dt><b></b></dt><dd>Generate RGB values from a colormap index value <code>i</code>. The first returns the RGB as a 32-bit unsigned integer, and the second decomposes the RGB into three 8-bit values.</dd></dl>
<p><a class="el" href="classFl.html#aed0a7958eebf1491685040be87490947" title="Read the user preference colors from the system and use them to call Fl::foreground(), Fl::background(), and Fl::background2().">Fl::get_system_colors()</a> <br/>
 <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR).">Fl::foreground()</a> <br/>
 <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a> <br/>
 <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color.">Fl::background2()</a></p>
<dl class="user"><dt><b></b></dt><dd>The first gets color values from the user preferences or the system, and the other routines are used to apply those values.</dd></dl>
<p><a class="el" href="classFl.html#a217dd709bed0d62a652625d505918fc6" title="Makes FLTK use its own colormap.">Fl::own_colormap()</a> <br/>
 <a class="el" href="group__fl__attributes.html#gae68ad6c3474fb71b3db5a44658b60b14" title="Frees the specified color from the colormap, if applicable.">Fl::free_color(Fl_Color i, int overlay)</a> <br/>
 <a class="el" href="group__fl__attributes.html#gaa6a6050ee3979754023eb1e66976240d" title="Sets an entry in the fl_color index table.">Fl::set_color(Fl_Color i, unsigned c)</a></p>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classFl.html#a217dd709bed0d62a652625d505918fc6" title="Makes FLTK use its own colormap.">Fl::own_colormap()</a></code> is used to install a local colormap [X11 only]. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="group__fl__attributes.html#gae68ad6c3474fb71b3db5a44658b60b14" title="Frees the specified color from the colormap, if applicable.">Fl::free_color()</a></code> and <code><a class="el" href="group__fl__attributes.html#gac62f634ba8089a9d0e48bf57154c61b0" title="Sets an entry in the fl_color index table.">Fl::set_color()</a></code> are used to remove and replace entries from the colormap.</dd></dl>
<p>There are two predefined graphical interfaces for choosing colors. The function <a class="el" href="group__fl__attributes.html#ga497a7e059e9f5c89feed24ab0b1338f2" title="Pops up a window to let the user pick a colormap entry.">fl_show_colormap()</a> shows a table of colors and returns an Fl_Color index value. The <a class="el" href="classFl__Color__Chooser.html" title="The Fl_Color_Chooser widget provides a standard RGB color chooser.">Fl_Color_Chooser</a> widget provides a standard RGB color chooser.</p>
<p>As the Fl_Color encoding maps to a 32-bit unsigned integer representing RGBI, it is also possible to specify a color using a hex constant as a color map index: </p>
<pre>
// COLOR MAP INDEX
color(0x000000II)
        ------ |
           |   |
           |   Color map index (8 bits)
           Must be zero
</pre> <div class="fragment"><pre class="fragment">button-&gt;<a class="code" href="classFl__Widget.html#a03c07e0725994cddf9070f9f1cd215c4" title="Gets the background color of the widget.">color</a>(0x000000ff);                  <span class="comment">// colormap index #255 (FL_WHITE)</span>
</pre></div><p>or specify a color using a hex constant for the RGB components: </p>
<pre>
// RGB COLOR ASSIGNMENTS
color(0xRRGGBB00)
         | | | |
         | | | Must be zero
         | | Blue (8 bits)
         | Green (8 bits)
         Red (8 bits)
</pre> <div class="fragment"><pre class="fragment">button-&gt;<a class="code" href="classFl__Widget.html#a03c07e0725994cddf9070f9f1cd215c4" title="Gets the background color of the widget.">color</a>(0xff000000);                  <span class="comment">// RGB: red</span>
button-&gt;<a class="code" href="classFl__Widget.html#a03c07e0725994cddf9070f9f1cd215c4" title="Gets the background color of the widget.">color</a>(0x00ff0000);                  <span class="comment">// RGB: green</span>
button-&gt;<a class="code" href="classFl__Widget.html#a03c07e0725994cddf9070f9f1cd215c4" title="Gets the background color of the widget.">color</a>(0x0000ff00);                  <span class="comment">// RGB: blue</span>
button-&gt;<a class="code" href="classFl__Widget.html#a03c07e0725994cddf9070f9f1cd215c4" title="Gets the background color of the widget.">color</a>(0xffffff00);                  <span class="comment">// RGB: white</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>If TrueColor is not available, any RGB colors will be set to the nearest entry in the colormap.</dd></dl>
<h3><a class="anchor" id="ssect_Lines"></a>
Line Dashes and Thickness</h3>
<p>FLTK supports drawing of lines with different styles and widths. Full functionality is not available under Windows 95, 98, and Me due to the reduced drawing functionality these operating systems provide.</p>
<p>void <a class="el" href="group__fl__drawings.html#ga75ac53c05a97bbb01a22ff56a382f52d" title="Sets how to draw lines (the &quot;pen&quot;).">fl_line_style(int style, int width, char* dashes)</a></p>
<dl class="user"><dt><b></b></dt><dd>Set how to draw lines (the "pen"). If you change this it is your responsibility to set it back to the default with <code>fl_line_style(0)</code>.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>Note:</b> Because of how line styles are implemented on MS Windows systems, you <em>must</em> set the line style <em>after</em> setting the drawing color. If you set the color after the line style you will lose the line style settings!</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>style</code> is a bitmask which is a bitwise-OR of the following values. If you don't specify a dash type you will get a solid line. If you don't specify a cap or join type you will get a system-defined default of whatever value is fastest.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li><code>FL_SOLID&#160;&#160;&#160;&#160;&#160; -------</code> </li>
<li><code>FL_DASH&#160;&#160;&#160;&#160;&#160;&#160; - - - -</code> </li>
<li><code>FL_DOT&#160;&#160;&#160;&#160;&#160;&#160;&#160; .......</code> </li>
<li><code>FL_DASHDOT&#160;&#160;&#160; - . - .</code> </li>
<li><code>FL_DASHDOTDOT - .. -</code> </li>
<li><code>FL_CAP_FLAT</code> </li>
<li><code>FL_CAP_ROUND</code> </li>
<li><code>FL_CAP_SQUARE</code> (extends past end point 1/2 line width) </li>
<li><code>FL_JOIN_MITER</code> (pointed) </li>
<li><code>FL_JOIN_ROUND</code> </li>
<li><code>FL_JOIN_BEVEL</code> (flat)</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>width</code> is the number of pixels thick to draw the lines. Zero results in the system-defined default, which on both X and Windows is somewhat different and nicer than 1.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>dashes</code> is a pointer to an array of dash lengths, measured in pixels. The first location is how long to draw a solid portion, the next is how long to draw the gap, then the solid, etc. It is terminated with a zero-length entry. A <code>NULL</code> pointer or a zero-length array results in a solid line. Odd array sizes are not supported and result in undefined behavior.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>Note:</b> The dashes array does not work under Windows 95, 98, or Me, since those operating systems do not support complex line styles.</dd></dl>
<h3><a class="anchor" id="ssect_Fast"></a>
Drawing Fast Shapes</h3>
<p>These functions are used to draw almost all the FLTK widgets. They draw on exact pixel boundaries and are as fast as possible. Their behavior is duplicated exactly on all platforms FLTK is ported. It is undefined whether these are affected by the <a class="el" href="drawing.html#ssect_Complex">transformation matrix</a>, so you should only call these while the matrix is set to the identity matrix (the default).</p>
<p>void <a class="el" href="group__fl__drawings.html#ga2145abaa848e9ce2da4d566b0dc54f6f" title="Draws a single pixel at the given coordinates.">fl_point(int x, int y)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draw a single pixel at the given coordinates.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga2986a868e9cc8d9141acde94c0fe8ab0" title="Colors with current color a rectangle that exactly fills the given bounding box.">fl_rectf(int x, int y, int w, int h)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gafa5637e67e69fd6ebfc471619d856dab" title="Colors with passed color a rectangle that exactly fills the given bounding box.">fl_rectf(int x, int y, int w, int h, Fl_Color c)</a></p>
<dl class="user"><dt><b></b></dt><dd>Color a rectangle that exactly fills the given bounding box.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga5ef1c09ef349f5fe128536c8434d514d" title="Colors a rectangle with &quot;exactly&quot; the passed r,g,b color.">fl_rectf(int x, int y, int w, int h, uchar r, uchar g, uchar b)</a></p>
<dl class="user"><dt><b></b></dt><dd>Color a rectangle with "exactly" the passed <code>r,g,b</code> color. On screens with less than 24 bits of color this is done by drawing a solid-colored block using <a class="el" href="drawing.html#drawing_fl_draw_image">fl_draw_image()</a> so that the correct color shade is produced.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga690c83e11f49fa837b563f4c0bc4fd1b" title="Draws a 1-pixel border inside the given bounding box.">fl_rect(int x, int y, int w, int h)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gae09f4c1d37871f3530229ede20631d1e" title="Draws with passed color a 1-pixel border inside the given bounding box.">fl_rect(int x, int y, int w, int h, Fl_Color c)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draw a 1-pixel border <em>inside</em> this bounding box.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#gaecc374f163a97ef67c4e58be11c47047" title="Draws a line from (x,y) to (x1,y1)">fl_line(int x, int y, int x1, int y1)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga28cc7813255d063edbd116d51c55fb31" title="Draws a line from (x,y) to (x1,y1) and another from (x1,y1) to (x2,y2)">fl_line(int x, int y, int x1, int y1, int x2, int y2)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draw one or two lines between the given points.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga8043345daebed15378180c5c117930c8" title="Outlines a 3-sided polygon with lines.">fl_loop(int x, int y, int x1, int y1, int x2, int y2)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga0670c9917da81b4fe67da44fd4fb4ab7" title="Outlines a 4-sided polygon with lines.">fl_loop(int x, int y, int x1, int y1, int x2, int y2, int x3, int y3)</a></p>
<dl class="user"><dt><b></b></dt><dd>Outline a 3 or 4-sided polygon with lines.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga821e9db88f1ff6a8d348c80babd7b49c" title="Fills a 3-sided polygon.">fl_polygon(int x, int y, int x1, int y1, int x2, int y2)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gab14ee2f4c5371ab6fe52bf08569e05d9" title="Fills a 4-sided polygon.">fl_polygon(int x, int y, int x1, int y1, int x2, int y2, int x3, int y3)</a></p>
<dl class="user"><dt><b></b></dt><dd>Fill a 3 or 4-sided polygon. The polygon must be convex.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#gacf46b232b6439424cc7f53656c5c2226" title="Draws a horizontal line from (x,y) to (x1,y)">fl_xyline(int x, int y, int x1)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gaadf217672cf4e471ee184fab70736666" title="Draws a horizontal line from (x,y) to (x1,y), then vertical from (x1,y) to (x1,y2)">fl_xyline(int x, int y, int x1, int y2)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga5098d1775b59ece7503a2faded1f1d74" title="Draws a horizontal line from (x,y) to (x1,y), then a vertical from (x1,y) to (x1,y2) and then another...">fl_xyline(int x, int y, int x1, int y2, int x3)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draw horizontal and vertical lines. A horizontal line is drawn first, then a vertical, then a horizontal.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga814eabe0e8adf0a5017299cc2ecc26a1" title="Draws a vertical line from (x,y) to (x,y1)">fl_yxline(int x, int y, int y1)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga9f5600eac117f72dd3fcb758729dab50" title="Draws a vertical line from (x,y) to (x,y1), then a horizontal from (x,y1) to (x2,y1)">fl_yxline(int x, int y, int y1, int x2)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gae2e8c7095fbda86ce7812d7e74f1b153" title="Draws a vertical line from (x,y) to (x,y1) then a horizontal from (x,y1) to (x2,y1), then another vertical from (x2,y1) to (x2,y3)">fl_yxline(int x, int y, int y1, int x2, int y3)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draw vertical and horizontal lines. A vertical line is drawn first, then a horizontal, then a vertical.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga3c1216fb40b6274acff72cca64b86a69" title="Draw ellipse sections using integer coordinates.">fl_arc(int x, int y, int w, int h, double a1, double a2)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gab4085aba3817a699ad98e1c80f91b69a" title="Draw filled ellipse sections using integer coordinates.">fl_pie(int x, int y, int w, int h, double a1, double a2)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draw ellipse sections using integer coordinates. These functions match the rather limited circle drawing code provided by X and MS Windows. The advantage over using <a class="el" href="drawing.html#drawing_fl_arc">fl_arc()</a> with floating point coordinates is that they are faster because they often use the hardware, and they draw much nicer small circles, since the small sizes are often hard-coded bitmaps.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>If a complete circle is drawn it will fit inside the passed bounding box. The two angles are measured in degrees counter-clockwise from 3'oclock and are the starting and ending angle of the arc, <code>a2</code> must be greater or equal to <code>a1</code>.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>fl_arc</code>() draws a series of lines to approximate the arc. Notice that the integer version of <code>fl_arc</code>() has a different number of arguments to the other <a class="el" href="drawing.html#drawing_fl_arc">fl_arc()</a> function described later in this chapter.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>fl_pie</code>() draws a filled-in pie slice. This slice may extend outside the line drawn by <code>fl_arc</code>(); to avoid this use <code>w-1</code> and <code>h-1</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>add an Fl_Draw_Area_Cb typedef to allow fl_scroll(...) to be doxygenated?</dd></dl>
<p>void fl_scroll(int X, int Y, int W, int H, int dx, int dy, void (*draw_area)(void*, int,int,int,int), void* data)</p>
<dl class="user"><dt><b></b></dt><dd>Scroll a rectangle and draw the newly exposed portions. The contents of the rectangular area is first shifted by <code>dx</code> and <code>dy</code> pixels. The callback is then called for every newly exposed rectangular area,</dd></dl>
<h3><a class="anchor" id="ssect_Complex"></a>
Drawing Complex Shapes</h3>
<p>The complex drawing functions let you draw arbitrary shapes with 2-D linear transformations. The functionality matches that found in the Adobe&reg; PostScript&trade; language. The exact pixels that are filled are less defined than for the fast drawing functions so that FLTK can take advantage of drawing hardware. On both X and MS Windows the transformed vertices are rounded to integers before drawing the line segments: this severely limits the accuracy of these functions for complex graphics, so use OpenGL when greater accuracy and/or performance is required.</p>
<p>void <a class="el" href="group__fl__drawings.html#gac6aa24b9ddc4d79a2e357ea812563a91" title="Saves the current transformation matrix on the stack.">fl_push_matrix()</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gab002201c2d4dfd87f82c3bd039d92ecc" title="Restores the current transformation matrix from the stack.">fl_pop_matrix()</a></p>
<dl class="user"><dt><b></b></dt><dd>Save and restore the current transformation. The maximum depth of the stack is 32 entries.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga60522372d52422ab427d540d375a43ad" title="Concatenates scaling transformation onto the current one.">fl_scale(double x,double y)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga055ef231c1621acbd571c12b995676f0" title="Concatenates scaling transformation onto the current one.">fl_scale(double x)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga319d6ba89d8a5a0b375dfbef4f265cd0" title="Concatenates translation transformation onto the current one.">fl_translate(double x,double y)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gab2a13525800bed49c0154562d523717f" title="Concatenates rotation transformation onto the current one.">fl_rotate(double d)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gab9c6ee4a256e888f7a8af0365f40b515" title="Concatenates another transformation onto the current one.">fl_mult_matrix(double a,double b,double c,double d,double x,double y)</a></p>
<dl class="user"><dt><b></b></dt><dd>Concatenate another transformation onto the current one. The rotation angle is in degrees (not radians) and is counter-clockwise.</dd></dl>
<p>double <a class="el" href="group__fl__drawings.html#gabba2c9a8d7598dca64572a63e592a864" title="Transforms coordinate using the current transformation matrix.">fl_transform_x(double x, double y)</a> <br/>
 double <a class="el" href="group__fl__drawings.html#gaf68ee505a886277680f704a86ea7ea86" title="Transforms coordinate using the current transformation matrix.">fl_transform_y(double x, double y)</a> <br/>
 double <a class="el" href="group__fl__drawings.html#ga5982191f71657bff8c38e19206869ea8" title="Transforms distance using current transformation matrix.">fl_transform_dx(double x, double y)</a> <br/>
 double <a class="el" href="group__fl__drawings.html#ga38e48d06963d55b2a3001f09355824a8" title="Transforms distance using current transformation matrix.">fl_transform_dy(double x, double y)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga4069ce7f3661ee913869bf71dbb5d5e7" title="Adds coordinate pair to the vertex list without further transformations.">fl_transformed_vertex(double xf, double yf)</a></p>
<dl class="user"><dt><b></b></dt><dd>Transform a coordinate or a distance using the current transformation matrix. After transforming a coordinate pair, it can be added to the vertex list without any further translations using <code>fl_transformed_vertex</code>().</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga35cac1d422bd2a1c713e0119407086b1" title="Starts drawing a list of points.">fl_begin_points()</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gaf715c7239d76c49737eb514e440490b5" title="Ends list of points, and draws.">fl_end_points()</a></p>
<dl class="user"><dt><b></b></dt><dd>Start and end drawing a list of points. Points are added to the list with <code>fl_vertex</code>().</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#gae6a88cd889c957813dc6dc849876b532" title="Starts drawing a list of lines.">fl_begin_line()</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga9f4bbb29153922288a9eebe25352571b" title="Ends list of lines, and draws.">fl_end_line()</a></p>
<dl class="user"><dt><b></b></dt><dd>Start and end drawing lines.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga3cac8693d88eeec879f909ba03007686" title="Starts drawing a closed sequence of lines.">fl_begin_loop()</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga5b2013850fe739839e437ef942602532" title="Ends closed sequence of lines, and draws.">fl_end_loop()</a></p>
<dl class="user"><dt><b></b></dt><dd>Start and end drawing a closed sequence of lines.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga63b2b306812f12741f271b469e192a8e" title="Starts drawing a convex filled polygon.">fl_begin_polygon()</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gad032c5f7637d440ff545285f2dcc2f44" title="Ends convex filled polygon, and draws.">fl_end_polygon()</a></p>
<dl class="user"><dt><b></b></dt><dd>Start and end drawing a convex filled polygon.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga11c03773e045738994ffa78acc35c51d" title="Starts drawing a complex filled polygon.">fl_begin_complex_polygon()</a> <br/>
 void <a class="el" href="group__fl__drawings.html#ga29448f3a419a65645e3f082c65d1df14" title="Call fl_gap() to separate loops of the path.">fl_gap()</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gaca7783f2d66b9a65a3201516bfd74694" title="Ends complex filled polygon, and draws.">fl_end_complex_polygon()</a></p>
<dl class="user"><dt><b></b></dt><dd>Start and end drawing a complex filled polygon. This polygon may be concave, may have holes in it, or may be several disconnected pieces. Call <code>fl_gap</code>() to separate loops of the path. It is unnecessary but harmless to call <code>fl_gap</code>() before the first vertex, after the last one, or several times in a row.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>fl_gap</code>() should only be called between <code>fl_begin_complex_polygon</code>() and <code>fl_end_complex_polygon</code>(). To outline the polygon, use <code>fl_begin_loop</code>() and replace each <code>fl_gap</code>() with a <code>fl_end_loop</code>();fl_begin_loop() pair.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>Note:</b> For portability, you should only draw polygons that appear the same whether "even/odd" or "non-zero" winding rules are used to fill them. Holes should be drawn in the opposite direction of the outside loop.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga1201f6cfa1422ac8f508bfaccbe497b3" title="Adds a single vertex to the current path.">fl_vertex(double x,double y)</a></p>
<dl class="user"><dt><b></b></dt><dd>Add a single vertex to the current path.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga4c5bf16603ecea25acdf2d86d43580a5" title="Adds a series of points on a Bezier curve to the path.">fl_curve(double X0, double Y0, double X1, double Y1, double X2, double Y2, double X3, double Y3)</a></p>
<dl class="user"><dt><b></b></dt><dd>Add a series of points on a Bezier curve to the path. The curve ends (and two of the points) are at <code>X0,Y0</code> and <code>X3,Y3</code>.</dd></dl>
<p><a class="anchor" id="drawing_fl_arc"></a> void <a class="el" href="group__fl__drawings.html#ga55e75228acb8f4c0febbc72fc9ab50dd" title="Adds a series of points to the current path on the arc of a circle.">fl_arc(double x, double y, double r, double start, double end)</a></p>
<dl class="user"><dt><b></b></dt><dd>Add a series of points to the current path on the arc of a circle; you can get elliptical paths by using scale and rotate before calling <code>fl_arc</code>(). The center of the circle is given by <code>x</code> and <code>y</code>, and <code>r</code> is its radius. <code>fl_arc</code>() takes <code>start</code> and <code>end</code> angles that are measured in degrees counter-clockwise from 3 o'clock. If <code>end</code> is less than <code>start</code> then it draws the arc in a clockwise direction.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#gac4540eaf7b5f23944cf332fc8f81f57e" title="fl_circle() is equivalent to fl_arc(x,y,r,0,360), but may be faster.">fl_circle(double x, double y, double r)</a></p>
<dl class="user"><dt><b></b></dt><dd><code>fl_circle</code>(...) is equivalent to <code>fl_arc</code>(...,0,360) but may be faster. It must be the <em>only</em> thing in the path: if you want a circle as part of a complex polygon you must use <code>fl_arc</code>().</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>Note:</b> <code>fl_circle</code>() draws incorrectly if the transformation is both rotated and non-square scaled.</dd></dl>
<h3><a class="anchor" id="ssect_Text"></a>
Drawing Text</h3>
<p>All text is drawn in the <a class="el" href="drawing.html#drawing_fl_font">current font</a>. It is undefined whether this location or the characters are modified by the current transformation.</p>
<p>void <a class="el" href="group__fl__drawings.html#gacf054f0c5c5d3ab6caa1e8be3d58ec7e" title="Draws a nul-terminated UTF-8 string starting at the given x, y location.">fl_draw(const char *, int x, int y)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gae4ac5a0bc231f239e45dc1552b5ee738" title="Draws starting at the given x, y location a UTF-8 string of length n bytes.">fl_draw(const char *, int n, int x, int y)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draw a nul-terminated string or an array of <code>n</code> characters starting at the given location. Text is aligned to the left and to the baseline of the font. To align to the bottom, subtract <code>fl_descent</code>() from <code>y</code>. To align to the top, subtract <code>fl_descent</code>() and add <code>fl_height</code>(). This version of <code>fl_draw</code>() provides direct access to the text drawing function of the underlying OS. It does not apply any special handling to control characters.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga0c1fe5be700c7b7079caf5dfd9fde9cd" title="Fancy string drawing function which is used to draw all the labels.">fl_draw(const char* str, int x, int y, int w, int h, Fl_Align align, Fl_Image* img, int draw_symbols)</a></p>
<dl class="user"><dt><b></b></dt><dd>Fancy string drawing function which is used to draw all the labels. The string is formatted and aligned inside the passed box. Handles '\t' and '\n', expands all other control characters to ^X, and aligns inside or against the edges of the box described by <code>x</code>, <code>y</code>, <code>w</code> and <code>h</code>. See <a class="el" href="classFl__Widget.html#aad980d813b8a47d777bde7cfa6b85eae" title="Gets the label alignment.">Fl_Widget::align()</a> for values for <code>align</code>. The value <code>FL_ALIGN_INSIDE</code> is ignored, as this function always prints inside the box.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <code>img</code> is provided and is not <code>NULL</code>, the image is drawn above or below the text as specified by the <code>align</code> value.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>draw_symbols</code> argument specifies whether or not to look for symbol names starting with the "@" character.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The text length is limited to 1024 characters per line.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#gaccd92d0c0521b0aac30dcb856d438dcd" title="Measure how wide and tall the string will be when printed by the fl_draw() function with align parame...">fl_measure(const char *str, int&amp; w, int&amp; h, int draw_symbols)</a></p>
<dl class="user"><dt><b></b></dt><dd>Measure how wide and tall the string will be when printed by the <code>fl_draw</code>(...align) function. This includes leading/trailing white space in the string, kerning, etc. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the incoming <code>w</code> is non-zero it will wrap to that width. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Refer to the full documentation for <a class="el" href="group__fl__drawings.html#gaccd92d0c0521b0aac30dcb856d438dcd" title="Measure how wide and tall the string will be when printed by the fl_draw() function with align parame...">fl_measure()</a> for details on usage and how to avoide common pitfalls.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__attributes.html#ga14cb75a92b6cdd576f9512b38a208f8b" title="Determines the minimum pixel dimensions of a nul-terminated string.">fl_text_extents()</a> -- measure the 'inked' area of a string </dd>
<dd>
<a class="el" href="group__fl__attributes.html#ga92c762ce2fc7fa891bac6b7590f967bd" title="Returns the typographical width of a nul-terminated string.">fl_width()</a> -- measure the pixel width of a string or single character </dd>
<dd>
<a class="el" href="group__fl__attributes.html#gac4acb828270adf35bf1d8fc06051f938" title="Returns the recommended minimum line spacing for the current font.">fl_height()</a> -- measure the pixel height of the current font </dd>
<dd>
<a class="el" href="group__fl__attributes.html#ga080e029f6b6fe5e6bf527bbfd890317d" title="Returns the recommended distance above the bottom of a fl_height() tall box to draw the text at so it...">fl_descent()</a> -- the height of the descender for the current font</dd></dl>
<p>int <a class="el" href="group__fl__attributes.html#gac4acb828270adf35bf1d8fc06051f938" title="Returns the recommended minimum line spacing for the current font.">fl_height()</a></p>
<dl class="user"><dt><b></b></dt><dd>Recommended minimum line spacing for the current font. You can also just use the value of <code>size</code> passed to <a class="el" href="drawing.html#drawing_fl_font">fl_font()</a>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__attributes.html#ga14cb75a92b6cdd576f9512b38a208f8b" title="Determines the minimum pixel dimensions of a nul-terminated string.">fl_text_extents()</a>, <a class="el" href="group__fl__drawings.html#gaccd92d0c0521b0aac30dcb856d438dcd" title="Measure how wide and tall the string will be when printed by the fl_draw() function with align parame...">fl_measure()</a>, <a class="el" href="group__fl__attributes.html#ga92c762ce2fc7fa891bac6b7590f967bd" title="Returns the typographical width of a nul-terminated string.">fl_width()</a>, <a class="el" href="group__fl__attributes.html#ga080e029f6b6fe5e6bf527bbfd890317d" title="Returns the recommended distance above the bottom of a fl_height() tall box to draw the text at so it...">fl_descent()</a></dd></dl>
<p>int <a class="el" href="group__fl__attributes.html#ga080e029f6b6fe5e6bf527bbfd890317d" title="Returns the recommended distance above the bottom of a fl_height() tall box to draw the text at so it...">fl_descent()</a></p>
<dl class="user"><dt><b></b></dt><dd>Recommended distance above the bottom of a <code>fl_height</code>() tall box to draw the text at so it looks centered vertically in that box.</dd></dl>
<p>double <a class="el" href="group__fl__attributes.html#ga92c762ce2fc7fa891bac6b7590f967bd" title="Returns the typographical width of a nul-terminated string.">fl_width(const char* txt)</a> <br/>
 double <a class="el" href="group__fl__attributes.html#gae491dc82c611608435ed434e368ef668" title="Returns the typographical width of a sequence of n characters.">fl_width(const char* txt, int n)</a> <br/>
 double <a class="el" href="group__fl__attributes.html#ga4a5b5e4a977299acdc7fcbd3c8a700b5" title="Returns the typographical width of a single character.">fl_width(unsigned int unicode_char)</a></p>
<dl class="user"><dt><b></b></dt><dd>Return the pixel width of a nul-terminated string, a sequence of <code>n</code> characters, or a single character in the current font.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__drawings.html#gaccd92d0c0521b0aac30dcb856d438dcd" title="Measure how wide and tall the string will be when printed by the fl_draw() function with align parame...">fl_measure()</a>, <a class="el" href="group__fl__attributes.html#ga14cb75a92b6cdd576f9512b38a208f8b" title="Determines the minimum pixel dimensions of a nul-terminated string.">fl_text_extents()</a>, <a class="el" href="group__fl__attributes.html#gac4acb828270adf35bf1d8fc06051f938" title="Returns the recommended minimum line spacing for the current font.">fl_height()</a>, <a class="el" href="group__fl__attributes.html#ga080e029f6b6fe5e6bf527bbfd890317d" title="Returns the recommended distance above the bottom of a fl_height() tall box to draw the text at so it...">fl_descent()</a></dd></dl>
<p>void <a class="el" href="group__fl__attributes.html#ga14cb75a92b6cdd576f9512b38a208f8b" title="Determines the minimum pixel dimensions of a nul-terminated string.">fl_text_extents(const char* txt, int&amp; dx, int&amp; dy, int&amp; w, int&amp; h)</a></p>
<dl class="user"><dt><b></b></dt><dd>Determines the minimum pixel dimensions of a nul-terminated string, ie. the 'inked area'. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Given a string "txt" drawn using fl_draw(txt, x, y) you would determine its pixel extents on the display using fl_text_extents(txt, dx, dy, wo, ho) such that a bounding box that exactly fits around the inked area of the text could be drawn with fl_rect(x+dx, y+dy, wo, ho). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Refer to the full documentation for <a class="el" href="group__fl__attributes.html#ga14cb75a92b6cdd576f9512b38a208f8b" title="Determines the minimum pixel dimensions of a nul-terminated string.">fl_text_extents()</a> for details on usage.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__drawings.html#gaccd92d0c0521b0aac30dcb856d438dcd" title="Measure how wide and tall the string will be when printed by the fl_draw() function with align parame...">fl_measure()</a>, <a class="el" href="group__fl__attributes.html#ga92c762ce2fc7fa891bac6b7590f967bd" title="Returns the typographical width of a nul-terminated string.">fl_width()</a>, <a class="el" href="group__fl__attributes.html#gac4acb828270adf35bf1d8fc06051f938" title="Returns the recommended minimum line spacing for the current font.">fl_height()</a>, <a class="el" href="group__fl__attributes.html#ga080e029f6b6fe5e6bf527bbfd890317d" title="Returns the recommended distance above the bottom of a fl_height() tall box to draw the text at so it...">fl_descent()</a></dd></dl>
<p>const char* fl_shortcut_label(int shortcut)</p>
<dl class="user"><dt><b></b></dt><dd>Unparse a shortcut value as used by <a class="el" href="classFl__Button.html" title="Buttons generate callbacks when they are clicked by the user.">Fl_Button</a> or <a class="el" href="structFl__Menu__Item.html" title="The Fl_Menu_Item structure defines a single menu item that is used by the Fl_Menu_ class...">Fl_Menu_Item</a> into a human-readable string like "Alt+N". This only works if the shortcut is a character key or a numbered function key. If the shortcut is zero an empty string is returned. The return value points at a static buffer that is overwritten with each call.</dd></dl>
<h3><a class="anchor" id="ssect_Fonts"></a>
Fonts</h3>
<p>FLTK supports a set of standard fonts based on the Times, Helvetica/Arial, Courier, and Symbol typefaces, as well as custom fonts that your application may load. Each font is accessed by an index into a font table.</p>
<p>Initially only the first 16 faces are filled in. There are symbolic names for them: FL_HELVETICA, FL_TIMES, FL_COURIER, and modifier values FL_BOLD and FL_ITALIC which can be added to these, and FL_SYMBOL and FL_ZAPF_DINGBATS. Faces greater than 255 cannot be used in <a class="el" href="classFl__Widget.html" title="Fl_Widget is the base class for all widgets in FLTK.">Fl_Widget</a> labels, since <a class="el" href="classFl__Widget.html" title="Fl_Widget is the base class for all widgets in FLTK.">Fl_Widget</a> stores the index as a byte.</p>
<p><a class="anchor" id="drawing_fl_font"></a> void <a class="el" href="group__fl__attributes.html#ga80203d2dd1e06550e7a35d6bb72f9bd6" title="Sets the current font, which is then used in various drawing routines.">fl_font(int face, int size)</a></p>
<dl class="user"><dt><b></b></dt><dd>Set the current font, which is then used by the routines described above. You may call this outside a draw context if necessary to call <a class="el" href="group__fl__attributes.html#ga92c762ce2fc7fa891bac6b7590f967bd" title="Returns the typographical width of a nul-terminated string.">fl_width()</a>, but on X this will open the display.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The font is identified by a <code>face</code> and a <code>size</code>. The size of the font is measured in <code>pixels</code> and not "points". Lines should be spaced <code>size</code> pixels apart or more.</dd></dl>
<p>int <a class="el" href="group__fl__attributes.html#ga80203d2dd1e06550e7a35d6bb72f9bd6" title="Sets the current font, which is then used in various drawing routines.">fl_font()</a> <br/>
 int <a class="el" href="group__fl__attributes.html#ga15b0cb282ba6d148f095647731f167b2" title="Returns the size set by the most recent call to fl_font().">fl_size()</a></p>
<dl class="user"><dt><b></b></dt><dd>Returns the face and size set by the most recent call to <code>fl_font(a,b)</code>. This can be used to save/restore the font.</dd></dl>
<h3><a class="anchor" id="ssect_CharacterEncoding"></a>
Character Encoding</h3>
<p>FLTK 1.3 expects all text in Unicode UTF-8 encoding. UTF-8 is ASCII compatible for the first 128 characters. International characters are encoded in multibyte sequences.</p>
<p>FLTK expects individual characters, characters that are not part of a string, in UCS-4 encoding, which is also ASCII compatible, but requires 4 bytes to store a Unicode character.</p>
<p>For more information about character encodings, see the chapter on <a class="el" href="unicode.html">Unicode and UTF-8 Support</a>.</p>
<h3><a class="anchor" id="ssect_Overlay"></a>
Drawing Overlays</h3>
<p>These functions allow you to draw interactive selection rectangles without using the overlay hardware. FLTK will XOR a single rectangle outline over a window.</p>
<p>void <a class="el" href="group__fl__drawings.html#gab0856445ac32f9b4606bca24cce63c7e" title="Draws a selection rectangle, erasing a previous one by XOR&#39;ing it first.">fl_overlay_rect(int x, int y, int w, int h)</a>; <br/>
 void <a class="el" href="group__fl__drawings.html#ga9d2c84bf8448312d165c286458e4984d" title="Erase a selection rectangle without drawing a new one.">fl_overlay_clear()</a>;</p>
<dl class="user"><dt><b></b></dt><dd><code>fl_overlay_rect</code>() draws a selection rectangle, erasing any previous rectangle by XOR'ing it first. <code>fl_overlay_clear</code>() will erase the rectangle without drawing a new one.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Using these functions is tricky. You should make a widget with both a <code>handle()</code> and <code>draw()</code> method. <code>draw()</code> should call <code>fl_overlay_clear</code>() before doing anything else. Your <code>handle()</code> method should call <code>window()-&gt;make_current()</code> and then <code>fl_overlay_rect</code>() after FL_DRAG events, and should call <code>fl_overlay_clear</code>() after a FL_RELEASE event.</dd></dl>
<h2><a class="anchor" id="drawing_images"></a>
Drawing Images</h2>
<p>To draw images, you can either do it directly from data in your memory, or you can create a <a class="el" href="classFl__Image.html" title="Fl_Image is the base class used for caching and drawing all kinds of images in FLTK.">Fl_Image</a> object. The advantage of drawing directly is that it is more intuitive, and it is faster if the image data changes more often than it is redrawn. The advantage of using the object is that FLTK will cache translated forms of the image (on X it uses a server pixmap) and thus redrawing is <em>much</em> faster.</p>
<h3><a class="anchor" id="ssect_DirectImageDrawing"></a>
Direct Image Drawing</h3>
<p>The behavior when drawing images when the current transformation matrix is not the identity is not defined, so you should only draw images when the matrix is set to the identity.</p>
<p><a class="anchor" id="drawing_fl_draw_image"></a> void <a class="el" href="group__fl__drawings.html#gaf9ad52880174bae01461adfa5b4020ff" title="Draws an 8-bit per color RGB or luminance image.">fl_draw_image(const uchar *buf,int X,int Y,int W,int H,int D,int L)</a><br/>
 void <a class="el" href="group__fl__drawings.html#gafb938dc103b5c3d9187a538667237d36" title="Draws a gray-scale (1 channel) image.">fl_draw_image_mono(const uchar *buf,int X,int Y,int W,int H,int D,int L)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draw an 8-bit per color RGB or luminance image. The pointer points at the "r" data of the top-left pixel. Color data must be in <code>r,g,b</code> order. The top left corner is given by <code>X</code> and <code>Y</code> and the size of the image is given by <code>W</code> and <code>H</code>. <code>D</code> is the delta to add to the pointer between pixels, it may be any value greater or equal to <code>3</code>, or it can be negative to flip the image horizontally. <code>L</code> is the delta to add to the pointer between lines (if 0 is passed it uses <code>W*D</code>). and may be larger than <code>W*D</code> to crop data, or negative to flip the image vertically.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is highly recommended that you put the following code before the first show() of <em>any</em> window in your program to get rid of the dithering if possible:</dd></dl>
<div class="fragment"><pre class="fragment"><a class="code" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual</a>(FL_RGB);
</pre></div><dl class="user"><dt><b></b></dt><dd>Gray scale (1-channel) images may be drawn. This is done if <code>abs(D)</code> is less than 3, or by calling <code>fl_draw_image_mono</code>(). Only one 8-bit sample is used for each pixel, and on screens with different numbers of bits for red, green, and blue only gray colors are used. Setting <code>D</code> greater than 1 will let you display one channel of a color image.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>Note:</b> The X version does not support all possible visuals. If FLTK cannot draw the image in the current visual it will abort. FLTK supports any visual of 8 bits or less, and all common TrueColor visuals up to 32 bits.</dd></dl>
<p>typedef void (*Fl_Draw_Image_Cb)(void *data,int x,int y,int w,uchar *buf) <br/>
 void <a class="el" href="group__fl__drawings.html#ga5b8f9bd2d3130529812dcc2c057eee35" title="Draws an image using a callback function to generate image data.">fl_draw_image(Fl_Draw_Image_Cb cb,void *data,int X,int Y,int W,int H,int D)</a> <br/>
 void <a class="el" href="group__fl__drawings.html#gab2a42aceaea722696f9b403473ec16a9" title="Draws a gray-scale image using a callback function to generate image data.">fl_draw_image_mono(Fl_Draw_Image_Cb cb,void *data,int X,int Y,int W,int H,int D)</a></p>
<dl class="user"><dt><b></b></dt><dd>Call the passed function to provide each scan line of the image. This lets you generate the image as it is being drawn, or do arbitrary decompression of stored data, provided it can be decompressed to individual scan lines easily.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The callback is called with the <code>void*</code> user data pointer which can be used to point at a structure of information about the image, and the <code>x</code>, <code>y</code>, and <code>w</code> of the scan line desired from the image. 0,0 is the upper-left corner of the image, <em>not <code>X,Y</code></em>. A pointer to a buffer to put the data into is passed. You must copy <code>w</code> pixels from scanline <code>y</code>, starting at pixel <code>x</code>, to this buffer.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to cropping, less than the whole image may be requested. So <code>x</code> may be greater than zero, the first <code>y</code> may be greater than zero, and <code>w</code> may be less than <code>W</code>. The buffer is long enough to store the entire <code>W*D</code> pixels, this is for convenience with some decompression schemes where you must decompress the entire line at once: decompress it into the buffer, and then if <code>x</code> is not zero, copy the data over so the <code>x'th</code> pixel is at the start of the buffer.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>You can assume the <code>y's</code> will be consecutive, except the first one may be greater than zero.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <code>D</code> is 4 or more, you must fill in the unused bytes with zero.</dd></dl>
<p>int <a class="el" href="group__fl__drawings.html#gaebd9b6111b8a511eff62749f1b756a31" title="Draw XPM image data, with the top-left corner at the given position.">fl_draw_pixmap(char* const* data, int x, int y, Fl_Color bg)</a> <br/>
 int <a class="el" href="group__fl__drawings.html#gab830e417d8f17fcd00acdb96711b9119" title="Draw XPM image data, with the top-left corner at the given position.">fl_draw_pixmap(const char* const* cdata, int x, int y, Fl_Color bg)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draws XPM image data, with the top-left corner at the given position. The image is dithered on 8-bit displays so you won't lose color space for programs displaying both images and pixmaps. This function returns zero if there was any error decoding the XPM data.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>To use an XPM, do:</dd></dl>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;foo.xpm&quot;</span>
...
fl_draw_pixmap(foo, X, Y);
</pre></div><dl class="user"><dt><b></b></dt><dd>Transparent colors are replaced by the optional Fl_Color argument. To draw with true transparency you must use the <a class="el" href="classFl__Pixmap.html" title="The Fl_Pixmap class supports caching and drawing of colormap (pixmap) images, including transparency...">Fl_Pixmap</a> class.</dd></dl>
<p>int <a class="el" href="group__fl__drawings.html#ga1a254e8b7b3699d0d3b9c8e2fb2b5eb6" title="Get the dimensions of a pixmap.">fl_measure_pixmap(char* const* data, int &amp;w, int &amp;h)</a> <br/>
 int <a class="el" href="group__fl__drawings.html#gaedf85a71995496e7cc00b1367d7490b3" title="Get the dimensions of a pixmap.">fl_measure_pixmap(const char* const* cdata, int &amp;w, int &amp;h)</a></p>
<dl class="user"><dt><b></b></dt><dd>An XPM image contains the dimensions in its data. This function finds and returns the width and height. The return value is non-zero if the dimensions were parsed ok and zero if there was any problem.</dd></dl>
<h3><a class="anchor" id="ssect_DirectImageReading"></a>
Direct Image Reading</h3>
<p>FLTK provides a single function for reading from the current window or off-screen buffer into a RGB(A) image buffer.</p>
<p>uchar* <a class="el" href="group__fl__drawings.html#ga0cdc05d3f7689e1c6b8a26fd0bd97233" title="Reads an RGB(A) image from the current window or off-screen buffer.">fl_read_image(uchar *p, int X, int Y, int W, int H, int alpha)</a></p>
<dl class="user"><dt><b></b></dt><dd>Read a RGB(A) image from the current window or off-screen buffer. The <code>p</code> argument points to a buffer that can hold the image and must be at least <code>W*H*3</code> bytes when reading RGB images and <code>W*H*4</code> bytes when reading RGBA images. If <code>NULL</code>, <code>fl_read_image</code>() will create an array of the proper size which can be freed using <code>delete</code>[].</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>alpha</code> parameter controls whether an alpha channel is created and the value that is placed in the alpha channel. If 0, no alpha channel is generated.</dd></dl>
<h3><a class="anchor" id="ssect_Fl_Image"></a>
Image Classes</h3>
<p>FLTK provides a base image class called <a class="el" href="classFl__Image.html" title="Fl_Image is the base class used for caching and drawing all kinds of images in FLTK.">Fl_Image</a> which supports creating, copying, and drawing images of various kinds, along with some basic color operations. Images can be used as labels for widgets using the <code>image()</code> and <code>deimage()</code> methods or drawn directly.</p>
<p>The <a class="el" href="classFl__Image.html" title="Fl_Image is the base class used for caching and drawing all kinds of images in FLTK.">Fl_Image</a> class does almost nothing by itself, but is instead supported by three basic image types:</p>
<ul>
<li><a class="el" href="classFl__Bitmap.html" title="The Fl_Bitmap class supports caching and drawing of mono-color (bitmap) images.">Fl_Bitmap</a> </li>
<li><a class="el" href="classFl__Pixmap.html" title="The Fl_Pixmap class supports caching and drawing of colormap (pixmap) images, including transparency...">Fl_Pixmap</a> </li>
<li><a class="el" href="classFl__RGB__Image.html" title="The Fl_RGB_Image class supports caching and drawing of full-color images with 1 to 4 channels of colo...">Fl_RGB_Image</a></li>
</ul>
<p>The <a class="el" href="classFl__Bitmap.html" title="The Fl_Bitmap class supports caching and drawing of mono-color (bitmap) images.">Fl_Bitmap</a> class encapsulates a mono-color bitmap image. The <code>draw()</code> method draws the image using the current drawing color.</p>
<p>The <a class="el" href="classFl__Pixmap.html" title="The Fl_Pixmap class supports caching and drawing of colormap (pixmap) images, including transparency...">Fl_Pixmap</a> class encapsulates a colormapped image. The <code>draw()</code> method draws the image using the colors in the file, and masks off any transparent colors automatically.</p>
<p>The <a class="el" href="classFl__RGB__Image.html" title="The Fl_RGB_Image class supports caching and drawing of full-color images with 1 to 4 channels of colo...">Fl_RGB_Image</a> class encapsulates a full-color (or grayscale) image with 1 to 4 color components. Images with an even number of components are assumed to contain an alpha channel that is used for transparency. The transparency provided by the draw() method is either a 24-bit blend against the existing window contents or a "screen door" transparency mask, depending on the platform and screen color depth.</p>
<p>char <a class="el" href="group__fl__drawings.html#gabc04f934741e868e3d537761a955bfdb" title="Checks whether platform supports true alpha blending for RGBA images.">fl_can_do_alpha_blending()</a></p>
<dl class="user"><dt><b></b></dt><dd><code>fl_can_do_alpha_blending</code>() will return 1, if your platform supports true alpha blending for RGBA images, or 0, if FLTK will use screen door transparency.</dd></dl>
<p>FLTK also provides several image classes based on the three standard image types for common file formats:</p>
<ul>
<li><a class="el" href="classFl__GIF__Image.html" title="The Fl_GIF_Image class supports loading, caching, and drawing of Compuserve GIFSM images...">Fl_GIF_Image</a> </li>
<li><a class="el" href="classFl__JPEG__Image.html" title="The Fl_JPEG_Image class supports loading, caching, and drawing of Joint Photographic Experts Group (J...">Fl_JPEG_Image</a> </li>
<li><a class="el" href="classFl__PNG__Image.html" title="The Fl_PNG_Image class supports loading, caching, and drawing of Portable Network Graphics (PNG) imag...">Fl_PNG_Image</a> </li>
<li><a class="el" href="classFl__PNM__Image.html" title="The Fl_PNM_Image class supports loading, caching, and drawing of Portable Anymap (PNM, PBM, PGM, PPM) image files.">Fl_PNM_Image</a> </li>
<li><a class="el" href="classFl__XBM__Image.html" title="The Fl_XBM_Image class supports loading, caching, and drawing of X Bitmap (XBM) bitmap files...">Fl_XBM_Image</a> </li>
<li><a class="el" href="classFl__XPM__Image.html" title="The Fl_XPM_Image class supports loading, caching, and drawing of X Pixmap (XPM) images, including transparency.">Fl_XPM_Image</a></li>
</ul>
<p>Each of these image classes load a named file of the corresponding format. The <a class="el" href="classFl__Shared__Image.html" title="This class supports caching, loading, and drawing of image files.">Fl_Shared_Image</a> class can be used to load any type of image file - the class examines the file and constructs an image of the appropriate type.</p>
<p>Finally, FLTK provides a special image class called <a class="el" href="classFl__Tiled__Image.html" title="This class supports tiling of images over a specified area.">Fl_Tiled_Image</a> to tile another image object in the specified area. This class can be used to tile a background image in a <a class="el" href="classFl__Group.html" title="The Fl_Group class is the FLTK container widget.">Fl_Group</a> widget, for example.</p>
<p>virtual void <a class="el" href="classFl__Tiled__Image.html#af091bc61560ef72f68ed9731ef9366db" title="The copy() method creates a copy of the specified image.">Fl_Tiled_Image::copy()</a>; <br/>
 virtual Fl_Image* <a class="el" href="classFl__Tiled__Image.html#a2e484f49ff399ced1c61a080c73243bd" title="The copy() method creates a copy of the specified image.">Fl_Tiled_Image::copy(int w, int h)</a>;</p>
<dl class="user"><dt><b></b></dt><dd>The <code>copy()</code> method creates a copy of the image. The second form specifies the new size of the image - the image is resized using the nearest-neighbor algorithm.</dd></dl>
<p>void <a class="el" href="classFl__Tiled__Image.html#a1b96f7b3ae9eeffabb7ba2504b286c13" title="Draws the image with a bounding box.">Fl_Tiled_Image::draw(int x, int y, int w, int h, int ox, int oy)</a>;</p>
<dl class="user"><dt><b></b></dt><dd>The <code>draw()</code> method draws the image object. <code>x,y,w,h</code> indicates a destination rectangle. <code>ox,oy,w,h</code> is a source rectangle. This source rectangle is copied to the destination. The source rectangle may extend outside the image, i.e. <code>ox</code> and <code>oy</code> may be negative and <code>w</code> and <code>h</code> may be bigger than the image, and this area is left unchanged.</dd></dl>
<p>void <a class="el" href="classFl__Tiled__Image.html#abb21f1b35e3581868d414f8d50dc40bb" title="Draws the image.">Fl_Tiled_Image::draw(int x, int y)</a></p>
<dl class="user"><dt><b></b></dt><dd>Draws the image with the upper-left corner at <code>x,y</code>. This is the same as doing <code>draw</code>(x,y,img-&gt;w(),img-&gt;h(),0,0).</dd></dl>
<h3><a class="anchor" id="ssect_Offscreen"></a>
Offscreen Drawing</h3>
<p>Sometimes it can be very useful to generate a complex drawing in memory first and copy it to the screen at a later point in time. This technique can significantly reduce the amount of repeated drawing. Offscreen drawing functions are declared in &lt;<a class="el" href="x_8H_source.html">FL/x.H</a>&gt;. <a class="el" href="classFl__Double__Window.html" title="The Fl_Double_Window provides a double-buffered window.">Fl_Double_Window</a> uses offscreen rendering to avoid flickering on systems that don't support double-buffering natively.</p>
<p>Fl_Offscreen <a class="el" href="group__fl__drawings.html#ga22259d434be43b30f74bfb3e96c5fdab" title="Creation of an offscreen graphics buffer.">fl_create_offscreen(int w, int h)</a></p>
<dl class="user"><dt><b></b></dt><dd>Create an RGB offscreen buffer with <code>w*h</code> pixels.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga785ac58171dc8843150dd075861a27db" title="Deletion of an offscreen graphics buffer.">fl_delete_offscreen(Fl_Offscreen)</a></p>
<dl class="user"><dt><b></b></dt><dd>Delete a previously created offscreen buffer. All drawings are lost.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga13b7fd0b4efda44b3e5072f43c5ee168" title="Send all subsequent drawing commands to this offscreen buffer.">fl_begin_offscreen(Fl_Offscreen)</a></p>
<dl class="user"><dt><b></b></dt><dd>Send all subsequent drawing commands to this offscreen buffer. FLTK can draw into a buffer at any time. There is no need to wait for an <a class="el" href="classFl__Widget.html#a1acb38c6b3cb40452ad02ccfeedbac8a" title="Draws the widget.">Fl_Widget::draw()</a> to occur.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#gac2195ac3bd679bac0b2810c8ac90faa6" title="Quit sending drawing commands to the current offscreen buffer.">fl_end_offscreen()</a></p>
<dl class="user"><dt><b></b></dt><dd>Quit sending drawing commands to this offscreen buffer.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga853c550da7a614936bf88b9dcc870754" title="Copy a rectangular area of the given offscreen buffer into the current drawing destination.">fl_copy_offscreen(int x, int y, int w, int h, Fl_Offscreen osrc, int srcx, int srcy)</a></p>
<dl class="user"><dt><b></b></dt><dd>Copy a rectangular area of the size <code>w*h</code> from <code>srcx</code>,srcy in the offscreen buffer into the current buffer at <code>x</code>,y.</dd></dl>
 
<hr>
<table summary="navigation bar" width="100%" border="0">
<tr>
  <td width="45%" align="LEFT">
    <a class="el" href="editor.html">
    [Prev]
    Designing a Simple Text Editor
    </a>
  </td>
  <td width="10%" align="CENTER">
    <a class="el" href="index.html">[Index]</a>
  </td>
  <td width="45%" align="RIGHT">
    <a class="el" href="events.html">
    Handling Events
    [Next]
    </a>
  </td>
</tr>
</table>
 </div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="main.html">FLTK Programming Manual</a>      </li>

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>


</body>
</html>
