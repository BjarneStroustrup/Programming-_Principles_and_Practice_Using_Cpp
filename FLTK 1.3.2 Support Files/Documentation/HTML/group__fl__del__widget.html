<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FLTK 1.3.2: Safe widget deletion support functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__fl__del__widget.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Safe widget deletion support functions</div>  </div>
</div>
<div class="contents">

<p>These functions, declared in &lt;<a class="el" href="Fl_8H.html" title="Fl static class.">FL/Fl.H</a>&gt;, support deletion of widgets inside callbacks.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#gad3cbd31083b47836cbe00ffb7006a4d4">Fl::clear_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> const *w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a widget pointer <em>in</em> the watch list.  <a href="#gad3cbd31083b47836cbe00ffb7006a4d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f">Fl::delete_widget</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a widget for deletion at the next call to the event loop.  <a href="#ga609413ac47ba433d1e7da8678a27164f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga838010444986ae57301d6e8289d2dfbb">Fl::do_widget_deletion</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes widgets previously scheduled for deletion.  <a href="#ga838010444986ae57301d6e8289d2dfbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2">Fl::release_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a widget pointer from the watch list.  <a href="#ga1426329d09de561319d4555018d9d1a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9">Fl::watch_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a widget pointer to the widget watch list.  <a href="#ga16ecd6d20b793fd0f3081eaab369caa9"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>These functions, declared in &lt;<a class="el" href="Fl_8H.html" title="Fl static class.">FL/Fl.H</a>&gt;, support deletion of widgets inside callbacks. </p>
<p><a class="el" href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f" title="Schedules a widget for deletion at the next call to the event loop.">Fl::delete_widget()</a> should be called when deleting widgets or complete widget trees (<a class="el" href="classFl__Group.html" title="The Fl_Group class is the FLTK container widget.">Fl_Group</a>, <a class="el" href="classFl__Window.html" title="This widget produces an actual window.">Fl_Window</a>, ...) inside callbacks.</p>
<p>The other functions are intended for internal use. The preferred way to use them is by using the helper class <a class="el" href="classFl__Widget__Tracker.html" title="This class should be used to control safe widget deletion.">Fl_Widget_Tracker</a>.</p>
<p>The following is to show how it works ...</p>
<p>There are three groups of related methods:</p>
<ol type="1">
<li>scheduled widget deletion<ul>
<li><a class="el" href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f" title="Schedules a widget for deletion at the next call to the event loop.">Fl::delete_widget()</a> schedules widgets for deletion</li>
<li><a class="el" href="group__fl__del__widget.html#ga838010444986ae57301d6e8289d2dfbb" title="Deletes widgets previously scheduled for deletion.">Fl::do_widget_deletion()</a> deletes all scheduled widgets</li>
</ul>
</li>
<li>widget watch list ("smart pointers")<ul>
<li><a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9" title="Adds a widget pointer to the widget watch list.">Fl::watch_widget_pointer()</a> adds a widget pointer to the watch list</li>
<li><a class="el" href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2" title="Releases a widget pointer from the watch list.">Fl::release_widget_pointer()</a> removes a widget pointer from the watch list</li>
<li><a class="el" href="group__fl__del__widget.html#gad3cbd31083b47836cbe00ffb7006a4d4" title="Clears a widget pointer in the watch list.">Fl::clear_widget_pointer()</a> clears a widget pointer <em>in</em> the watch list</li>
</ul>
</li>
<li>the class <a class="el" href="classFl__Widget__Tracker.html" title="This class should be used to control safe widget deletion.">Fl_Widget_Tracker</a>:<ul>
<li>the constructor calls <a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9" title="Adds a widget pointer to the widget watch list.">Fl::watch_widget_pointer()</a></li>
<li>the destructor calls <a class="el" href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2" title="Releases a widget pointer from the watch list.">Fl::release_widget_pointer()</a></li>
<li>the access methods can be used to test, if a widget has been deleted <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl__Widget__Tracker.html" title="This class should be used to control safe widget deletion.">Fl_Widget_Tracker</a>. </dd></dl>
</li>
</ul>
</li>
</ol>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad3cbd31083b47836cbe00ffb7006a4d4"></a><!-- doxytag: member="Fl::clear_widget_pointer" ref="gad3cbd31083b47836cbe00ffb7006a4d4" args="(Fl_Widget const *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::clear_widget_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Widget.html">Fl_Widget</a> const *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears a widget pointer <em>in</em> the watch list. </p>
<p>This is called when a widget is destroyed (by its destructor). You should never call this directly.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Internal use only !</dd></dl>
<p>This method searches the widget watch list for pointers to the widget and clears each pointer that points to it. Widget pointers can be added to the widget watch list by calling <a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9" title="Adds a widget pointer to the widget watch list.">Fl::watch_widget_pointer()</a> or by using the helper class <a class="el" href="classFl__Widget__Tracker.html" title="This class should be used to control safe widget deletion.">Fl_Widget_Tracker</a> (recommended).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9" title="Adds a widget pointer to the widget watch list.">Fl::watch_widget_pointer()</a> </dd>
<dd>
class <a class="el" href="classFl__Widget__Tracker.html" title="This class should be used to control safe widget deletion.">Fl_Widget_Tracker</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga609413ac47ba433d1e7da8678a27164f"></a><!-- doxytag: member="Fl::delete_widget" ref="ga609413ac47ba433d1e7da8678a27164f" args="(Fl_Widget *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::delete_widget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td>
          <td class="paramname"><em>wi</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedules a widget for deletion at the next call to the event loop. </p>
<p>Use this method to delete a widget inside a callback function.</p>
<p>To avoid early deletion of widgets, this function should be called toward the end of a callback and only after any call to the event loop (<a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a>, <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a>, <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a>, <a class="el" href="group__group__comdlg.html#gad3800d6fffef60c0153e6befecdfa650" title="Shows a dialog displaying the fmt message, this dialog features 2 yes/no buttons.">fl_ask()</a>, etc.).</p>
<p>When deleting groups or windows, you must only delete the group or window widget and not the individual child widgets.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>FLTK 1.3 it is not necessary to remove widgets from their parent groups or windows before calling this, because it will be done in the widget's destructor, but it is not a failure to do this nevertheless.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In FLTK 1.1 you <b>must</b> remove widgets from their parent group (or window) before deleting them.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl__Widget.html#aca0164a60a96b07007cc1f78bd6d2140" title="Destroys the widget.">Fl_Widget::~Fl_Widget()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga838010444986ae57301d6e8289d2dfbb"></a><!-- doxytag: member="Fl::do_widget_deletion" ref="ga838010444986ae57301d6e8289d2dfbb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::do_widget_deletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes widgets previously scheduled for deletion. </p>
<p>This is for internal use only. You should never call this directly.</p>
<p><a class="el" href="group__fl__del__widget.html#ga838010444986ae57301d6e8289d2dfbb" title="Deletes widgets previously scheduled for deletion.">Fl::do_widget_deletion()</a> is called from the FLTK event loop or whenever you call <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a>. The previously scheduled widgets are deleted in the same order they were scheduled by calling <a class="el" href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f" title="Schedules a widget for deletion at the next call to the event loop.">Fl::delete_widget()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f" title="Schedules a widget for deletion at the next call to the event loop.">Fl::delete_widget(Fl_Widget *wi)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1426329d09de561319d4555018d9d1a2"></a><!-- doxytag: member="Fl::release_widget_pointer" ref="ga1426329d09de561319d4555018d9d1a2" args="(Fl_Widget *&amp;w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::release_widget_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases a widget pointer from the watch list. </p>
<p>This is used to remove a widget pointer that has been added to the watch list with <a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9" title="Adds a widget pointer to the widget watch list.">Fl::watch_widget_pointer()</a>, when it is not needed anymore.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Internal use only, please use class <a class="el" href="classFl__Widget__Tracker.html" title="This class should be used to control safe widget deletion.">Fl_Widget_Tracker</a> instead.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9" title="Adds a widget pointer to the widget watch list.">Fl::watch_widget_pointer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga16ecd6d20b793fd0f3081eaab369caa9"></a><!-- doxytag: member="Fl::watch_widget_pointer" ref="ga16ecd6d20b793fd0f3081eaab369caa9" args="(Fl_Widget *&amp;w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::watch_widget_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a widget pointer to the widget watch list. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Internal use only, please use class <a class="el" href="classFl__Widget__Tracker.html" title="This class should be used to control safe widget deletion.">Fl_Widget_Tracker</a> instead.</dd></dl>
<p>This can be used, if it is possible that a widget might be deleted during a callback or similar function. The widget pointer must be added to the watch list before calling the callback. After the callback the widget pointer can be queried, if it is NULL. <em>If</em> it is NULL, then the widget has been deleted during the callback and must not be accessed anymore. If the widget pointer is <em>not</em> NULL, then the widget has not been deleted and can be accessed safely.</p>
<p>After accessing the widget, the widget pointer must be released from the watch list by calling <a class="el" href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2" title="Releases a widget pointer from the watch list.">Fl::release_widget_pointer()</a>.</p>
<p>Example for a button that is clicked (from its <a class="el" href="group__fl__events.html#ga064a4028b27d7da1238a6e5280582abf" title="Handle events from the window system.">handle()</a> method): </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classFl__Widget.html" title="Fl_Widget is the base class for all widgets in FLTK.">Fl_Widget</a> *wp = <span class="keyword">this</span>;               <span class="comment">// save &#39;this&#39; in a pointer variable</span>
    <a class="code" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9" title="Adds a widget pointer to the widget watch list.">Fl::watch_widget_pointer</a>(wp);       <span class="comment">// add the pointer to the watch list</span>
    set_changed();                      <span class="comment">// set the changed flag</span>
    do_callback();                      <span class="comment">// call the callback</span>
    <span class="keywordflow">if</span> (!wp) {                          <span class="comment">// the widget has been deleted</span>

      <span class="comment">// DO NOT ACCESS THE DELETED WIDGET !</span>

    } <span class="keywordflow">else</span> {                            <span class="comment">// the widget still exists</span>
      clear_changed();                  <span class="comment">// reset the changed flag</span>
    }

    <a class="code" href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2" title="Releases a widget pointer from the watch list.">Fl::release_widget_pointer</a>(wp);     <span class="comment">// remove the pointer from the watch list</span>
</pre></div><p>This works, because all widgets call <a class="el" href="group__fl__del__widget.html#gad3cbd31083b47836cbe00ffb7006a4d4" title="Clears a widget pointer in the watch list.">Fl::clear_widget_pointer()</a> in their destructors.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2" title="Releases a widget pointer from the watch list.">Fl::release_widget_pointer()</a> </dd>
<dd>
<a class="el" href="group__fl__del__widget.html#gad3cbd31083b47836cbe00ffb7006a4d4" title="Clears a widget pointer in the watch list.">Fl::clear_widget_pointer()</a></dd></dl>
<p>An easier and more convenient method to control widget deletion during callbacks is to use the class <a class="el" href="classFl__Widget__Tracker.html" title="This class should be used to control safe widget deletion.">Fl_Widget_Tracker</a> with a local (automatic) variable.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>class <a class="el" href="classFl__Widget__Tracker.html" title="This class should be used to control safe widget deletion.">Fl_Widget_Tracker</a> </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>


</body>
</html>
