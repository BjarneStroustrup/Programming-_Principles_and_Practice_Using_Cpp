<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FLTK 1.3.2: Fl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classFl.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Fl Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Fl" -->
<p>The <a class="el" href="classFl.html" title="The Fl is the FLTK global (static) class containing state information and global methods for the curr...">Fl</a> is the FLTK global (static) class containing state information and global methods for the current application.  
 <a href="classFl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Fl_8H_source.html">Fl.H</a>&gt;</code></p>

<p><a href="classFl-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a> { <br/>
&#160;&#160;<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">OPTION_ARROW_FOCUS</a> =  0, 
<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1dade29f22fc8066222d99ea3ccebc5e655">OPTION_VISIBLE_FOCUS</a>, 
<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da2344bf14f80ecf5971e8aa4493a3858a">OPTION_DND_TEXT</a>, 
<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1dae8214e42f77fe157297d61fdb818be2f">OPTION_SHOW_TOOLTIPS</a>, 
<br/>
&#160;&#160;<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da220ebf62255fc47e5b5f213b410e2bc5">OPTION_LAST</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator for global FLTK options.  <a href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#afff1ee2c6afa6463293a2188a44b00b5">add_awake_handler_</a> (<a class="el" href="group__callback__functions.html#ga13f70685dbd05cf1537f97f6e59c1e58">Fl_Awake_Handler</a>, void *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>.  <a href="#afff1ee2c6afa6463293a2188a44b00b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7b689a9e42582fe6e87f7c7eb1dce94f">add_check</a> (<a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK will call this callback just before it flushes the display and waits for events.  <a href="#a7b689a9e42582fe6e87f7c7eb1dce94f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a799b8278326b3c2db15687c43c11aaf6">add_fd</a> (int fd, int when, <a class="el" href="group__callback__functions.html#gab7d7013178be0e856a3beb0588910704">Fl_FD_Handler</a> cb, void *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds file descriptor fd to listen to.  <a href="#a799b8278326b3c2db15687c43c11aaf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad45d81e99587aa6115cb8a6b3d757517"></a><!-- doxytag: member="Fl::add_fd" ref="ad45d81e99587aa6115cb8a6b3d757517" args="(int fd, Fl_FD_Handler cb, void *=0)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ad45d81e99587aa6115cb8a6b3d757517">add_fd</a> (int fd, <a class="el" href="group__callback__functions.html#gab7d7013178be0e856a3beb0588910704">Fl_FD_Handler</a> cb, void *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See void add_fd(int fd, int when, Fl_FD_Handler cb, void* = 0) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gae2d39bda7362e444afa41166c478b904">add_handler</a> (<a class="el" href="group__callback__functions.html#ga04194d0b454ba4013ff79ba688b594b5">Fl_Event_Handler</a> h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a function to parse unrecognized events.  <a href="group__fl__events.html#gae2d39bda7362e444afa41166c478b904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a4e7a1b5d18c2f073238a8466a62a3e7a">add_idle</a> (<a class="el" href="group__callback__functions.html#ga9d8f4ff50ebb523a35fad2f30cf99768">Fl_Idle_Handler</a> cb, void *data=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback function that is called every time by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> and also makes it act as though the timeout is zero (this makes <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> return immediately, so if it is in a loop it is called repeatedly, and thus the idle fucntion is called repeatedly).  <a href="#a4e7a1b5d18c2f073238a8466a62a3e7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52">add_timeout</a> (double t, <a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a one-shot timeout callback.  <a href="#a23e63eb7cec3a27fa360e66c6e2b2e52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a1576b8c9ca3e900daaa5c36ca0e7ae48">arg</a> (int argc, char **argv, int &amp;i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single switch from <code>argv</code>, starting at word <code>i</code>.  <a href="#a1576b8c9ca3e900daaa5c36ca0e7ae48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a6fb24179ad2642412f4042863fe23645">args</a> (int argc, char **argv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all command line switches matching standard FLTK options only.  <a href="#a6fb24179ad2642412f4042863fe23645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534">args</a> (int argc, char **argv, int &amp;i, <a class="el" href="group__callback__functions.html#gae17a8b5aa56e828c14f0fc7da7766a16">Fl_Args_Handler</a> cb=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command line switches using the <code>cb</code> argument handler.  <a href="#a115903daf3593748cdd36a5e78e74534"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb">awake</a> (void *message=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message pointer to the main thread, causing any pending <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> call to terminate so that the main thread can retrieve the message and any pending redraws can be processed.  <a href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga22a404bcaf6641369e0725627d881556">awake</a> (<a class="el" href="group__callback__functions.html#ga13f70685dbd05cf1537f97f6e59c1e58">Fl_Awake_Handler</a> cb, void *message=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See void awake(void* message=0).  <a href="group__fl__multithread.html#ga22a404bcaf6641369e0725627d881556"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef">background</a> (<a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to black to white.  <a href="#a422da0dfc6aa51721e7c9a6ccf5b90ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2">background2</a> (<a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the alternative background color.  <a href="#a98d4c4557a2127bfc46abe15feed3be2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga5a5c497679a904863019edf5375293bf">belowmouse</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the widget that is below the mouse.  <a href="group__fl__events.html#ga5a5c497679a904863019edf5375293bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga5b55ce634002a2743c24c4c4db7cbdd4">belowmouse</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the widget that is below the mouse.  <a href="group__fl__events.html#ga5b55ce634002a2743c24c4c4db7cbdd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#af739a06d44dc94d09015ed1940b9f066">box_dh</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height offset for the given boxtype.  <a href="#af739a06d44dc94d09015ed1940b9f066"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9a327ed95a8c2533ca4eee659bf3d557">box_dw</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width offset for the given boxtype.  <a href="#a9a327ed95a8c2533ca4eee659bf3d557"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a2971f20fe3595fd8f77fe73d4eb89594">box_dx</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the X offset for the given boxtype.  <a href="#a2971f20fe3595fd8f77fe73d4eb89594"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15">box_dy</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Y offset for the given boxtype.  <a href="#a9fbd0a2a5c43a30893dec05e8d34dc15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#gae5a1f7fcf75353908cc96b0edb928dd9">cairo_autolink_context</a> (bool alink)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">when FLTK_HAVE_CAIRO is defined and <a class="el" href="group__group__cairo.html#ga9a52d25377797666e43a46b520c485ac" title="Gets the current autolink mode for cairo support.">cairo_autolink_context()</a> is true, any current window dc is linked to a current context.  <a href="group__group__cairo.html#gae5a1f7fcf75353908cc96b0edb928dd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#ga9a52d25377797666e43a46b520c485ac">cairo_autolink_context</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current autolink mode for cairo support.  <a href="group__group__cairo.html#ga9a52d25377797666e43a46b520c485ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#ga2bd5ba3321a80408a1460e114e2e5f99">cairo_cc</a> (cairo_t *c, bool own=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current cairo context to <code>c</code>.  <a href="group__group__cairo.html#ga2bd5ba3321a80408a1460e114e2e5f99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static cairo_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#ga71ff6bfde35cd1d8a050d18cdc2f24af">cairo_cc</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current cairo context linked with a fltk window.  <a href="group__group__cairo.html#ga71ff6bfde35cd1d8a050d18cdc2f24af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static cairo_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#gabc793671da89c45c42c32ff7a777b5e8">cairo_make_current</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a corresponding cairo context for window <em>wi</em>.  <a href="group__group__cairo.html#gabc793671da89c45c42c32ff7a777b5e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0">check</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as Fl::wait(0).  <a href="#a1dbb83f1d52001c152ccf8415e3ee6f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#gad3cbd31083b47836cbe00ffb7006a4d4">clear_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> const *w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a widget pointer <em>in</em> the watch list.  <a href="group__fl__del__widget.html#gad3cbd31083b47836cbe00ffb7006a4d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga79b619b0bccac6da8cdc55e6bb8a8d52">compose</a> (int &amp;del)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Any text editing widget should call this for each FL_KEYBOARD event.  <a href="group__fl__events.html#ga79b619b0bccac6da8cdc55e6bb8a8d52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gaee29b04437dacb960cace49e84d62606">compose_reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user moves the cursor, be sure to call <a class="el" href="group__fl__events.html#gaee29b04437dacb960cace49e84d62606" title="If the user moves the cursor, be sure to call Fl::compose_reset().">Fl::compose_reset()</a>.  <a href="group__fl__events.html#gaee29b04437dacb960cace49e84d62606"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gabfc831afe7c4de04c906f82830f54211">copy</a> (const char *stuff, int len, int destination=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data pointed to by <code>stuff</code> to the selection buffer (<code>destination</code> is 0) or the clipboard (<code>destination</code> is 1); <code>len</code> is the number of relevant bytes in <code>stuff</code>.  <a href="group__fl__clipboard.html#gabfc831afe7c4de04c906f82830f54211"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45391ff5a25464a6e40658b58bf3ef98"></a><!-- doxytag: member="Fl::damage" ref="a45391ff5a25464a6e40658b58bf3ef98" args="(int d)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a45391ff5a25464a6e40658b58bf3ef98">damage</a> (int d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If true then <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">flush()</a> will do something. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ac5e4de1119ebb169c8a8de4c81a4cb59">damage</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If true then <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">flush()</a> will do something.  <a href="#ac5e4de1119ebb169c8a8de4c81a4cb59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gadd064730c5ea01306754bc5c35df24f9">default_atclose</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *, void *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback for window widgets.  <a href="group__fl__windows.html#gadd064730c5ea01306754bc5c35df24f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f">delete_widget</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a widget for deletion at the next call to the event loop.  <a href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7c6847e1b7dd9628821656933ca8e79d">display</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the X display to use for all windows.  <a href="#a7c6847e1b7dd9628821656933ca8e79d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga42026e276b8e83312ce58b264d1d4dcc">dnd</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a Drag And Drop operation.  <a href="group__fl__clipboard.html#ga42026e276b8e83312ce58b264d1d4dcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a53430e25b53f3b608193fa4009898463">dnd_text_ops</a> (int v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets whether drag and drop text operations are supported.  <a href="#a53430e25b53f3b608193fa4009898463"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aae157def51e4dabe5f75298b676ddea2">dnd_text_ops</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets whether drag and drop text operations are supported.  <a href="#aae157def51e4dabe5f75298b676ddea2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga838010444986ae57301d6e8289d2dfbb">do_widget_deletion</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes widgets previously scheduled for deletion.  <a href="group__fl__del__widget.html#ga838010444986ae57301d6e8289d2dfbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ad56cf568ee94318b50d2b2da0aa3031b">draw_box_active</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the current draw box is active or inactive.  <a href="#ad56cf568ee94318b50d2b2da0aa3031b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gac7595e274aaebaa23982125a1363d13f">event</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last event that was processed.  <a href="group__fl__events.html#gac7595e274aaebaa23982125a1363d13f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga1ee32cc3de557d5a1cc81a1eab944929">event_alt</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the Alt key is pressed.  <a href="group__fl__events.html#ga1ee32cc3de557d5a1cc81a1eab944929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga7ae6d99ceb1a2afb8a1dc4455ac941cd">event_button</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets which particular mouse button caused the current event.  <a href="group__fl__events.html#ga7ae6d99ceb1a2afb8a1dc4455ac941cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga6ec5fa15a7ea5229cbff8dd507130d46">event_button1</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if mouse button 1 is currently held down.  <a href="group__fl__events.html#ga6ec5fa15a7ea5229cbff8dd507130d46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gad85ae7c11308de6e4653a860729dec77">event_button2</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if button 2 is currently held down.  <a href="group__fl__events.html#gad85ae7c11308de6e4653a860729dec77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga70f54fbed74f801495575939dc787361">event_button3</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if button 3 is currently held down.  <a href="group__fl__events.html#ga70f54fbed74f801495575939dc787361"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gaee06c25589974fafb1c8df8d0e2c7c80">event_buttons</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse buttons state bits; if non-zero, then at least one button is pressed now.  <a href="group__fl__events.html#gaee06c25589974fafb1c8df8d0e2c7c80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga0531622eb47fab712faedd43eab886d9">event_clicks</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually sets the number returned by <a class="el" href="group__fl__events.html#gafa31b53b34bd43ee107806a3bbc640d1" title="Returns non zero if we had a double click event.">Fl::event_clicks()</a>.  <a href="group__fl__events.html#ga0531622eb47fab712faedd43eab886d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafa31b53b34bd43ee107806a3bbc640d1">event_clicks</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non zero if we had a double click event.  <a href="group__fl__events.html#gafa31b53b34bd43ee107806a3bbc640d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga73da625a4d77f730da5e0bd0e8823be9">event_command</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the FL_COMMAND key is pressed, either FL_CTRL or on OSX FL_META.  <a href="group__fl__events.html#ga73da625a4d77f730da5e0bd0e8823be9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gace54a534aad4a88dac170871a5bcbe1a">event_ctrl</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the Control key is pressed.  <a href="group__fl__events.html#gace54a534aad4a88dac170871a5bcbe1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafc8bd62d8fdacef87c56ed3a22cdcebc">event_dispatch</a> (<a class="el" href="group__callback__functions.html#gabec0721f2b151c82c51f3507567face4">Fl_Event_Dispatch</a> d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new event dispatch function.  <a href="group__fl__events.html#gafc8bd62d8fdacef87c56ed3a22cdcebc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafad45688b3e262a38151320a4059e04d"></a><!-- doxytag: member="Fl::event_dispatch" ref="gafad45688b3e262a38151320a4059e04d" args="()" -->
static <a class="el" href="group__callback__functions.html#gabec0721f2b151c82c51f3507567face4">Fl_Event_Dispatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafad45688b3e262a38151320a4059e04d">event_dispatch</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current event dispatch function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gadd50231ad95aaf23a23e9db42cccb42e">event_dx</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current horizontal mouse scrolling associated with the FL_MOUSEWHEEL event.  <a href="group__fl__events.html#gadd50231ad95aaf23a23e9db42cccb42e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga4704bd4e93b6471321d6ac84b0df97e5">event_dy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current vertical mouse scrolling associated with the FL_MOUSEWHEEL event.  <a href="group__fl__events.html#ga4704bd4e93b6471321d6ac84b0df97e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga143c28ca9e41cb919be1c4c72227a475">event_inside</a> (const <a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the mouse event is inside a given child widget.  <a href="group__fl__events.html#ga143c28ca9e41cb919be1c4c72227a475"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga277f38696ffa53b63325b13ac51976bb">event_inside</a> (int, int, int, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the mouse event is inside the given rectangle.  <a href="group__fl__events.html#ga277f38696ffa53b63325b13ac51976bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga08ba811a19462788094768ed98798120">event_is_click</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the value returned by <a class="el" href="group__fl__events.html#gae4f3bafeb9fbae98c3b7cc6f5326e582" title="Returns non-zero if the mouse has not moved far enough and not enough time has passed since the last ...">Fl::event_is_click()</a>.  <a href="group__fl__events.html#ga08ba811a19462788094768ed98798120"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gae4f3bafeb9fbae98c3b7cc6f5326e582">event_is_click</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the mouse has not moved far enough and not enough time has passed since the last FL_PUSH or FL_KEYBOARD event for it to be considered a "drag" rather than a "click".  <a href="group__fl__events.html#gae4f3bafeb9fbae98c3b7cc6f5326e582"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga1ac131e3cd5ca674cc022b1f77233449">event_key</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets which key on the keyboard was last pushed.  <a href="group__fl__events.html#ga1ac131e3cd5ca674cc022b1f77233449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga12be48f03872da009734f557d1e761bc">event_key</a> (int key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>key</code> was held down (or pressed) <em>during</em> the last event.  <a href="group__fl__events.html#ga12be48f03872da009734f557d1e761bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga38f2de89fbdf59ad2cd4dca93f472911">event_length</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the text in <a class="el" href="group__fl__events.html#ga6647c55948fe1d8be9367267529e9c54" title="Returns the text associated with the current event, including FL_PASTE or FL_DND_RELEASE events...">Fl::event_text()</a>.  <a href="group__fl__events.html#ga38f2de89fbdf59ad2cd4dca93f472911"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gadec41d640b647e422b88331015ab660d">event_original_key</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the keycode of the last key event, regardless of the NumLock state.  <a href="group__fl__events.html#gadec41d640b647e422b88331015ab660d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gabd68dc8a592e9a2a41b42cb7e3a30060">event_shift</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the Shift key is pressed.  <a href="group__fl__events.html#gabd68dc8a592e9a2a41b42cb7e3a30060"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafa17a5b4d8d9163631c88142e60447ed">event_state</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a bitfield of what shift states were on and what mouse buttons were held down during the most recent event.  <a href="group__fl__events.html#gafa17a5b4d8d9163631c88142e60447ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ff4a74294e833593504ff6531b6d459"></a><!-- doxytag: member="Fl::event_state" ref="ga1ff4a74294e833593504ff6531b6d459" args="(int i)" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga1ff4a74294e833593504ff6531b6d459">event_state</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See int <a class="el" href="group__fl__events.html#gafa17a5b4d8d9163631c88142e60447ed" title="This is a bitfield of what shift states were on and what mouse buttons were held down during the most...">event_state()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga6647c55948fe1d8be9367267529e9c54">event_text</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the text associated with the current event, including FL_PASTE or FL_DND_RELEASE events.  <a href="group__fl__events.html#ga6647c55948fe1d8be9367267529e9c54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91585fcbaa1e79f7452fd2d16a82136e"></a><!-- doxytag: member="Fl::event_x" ref="ga91585fcbaa1e79f7452fd2d16a82136e" args="()" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga91585fcbaa1e79f7452fd2d16a82136e">event_x</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position of the event relative to the <a class="el" href="classFl__Window.html" title="This widget produces an actual window.">Fl_Window</a> it was passed to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga4c40bd0d2960354c9778fdb65a2b720d">event_x_root</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position on the screen of the event.  <a href="group__fl__events.html#ga4c40bd0d2960354c9778fdb65a2b720d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga192a0c5a37f33b9d117a69f20977c2a1"></a><!-- doxytag: member="Fl::event_y" ref="ga192a0c5a37f33b9d117a69f20977c2a1" args="()" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga192a0c5a37f33b9d117a69f20977c2a1">event_y</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position of the event relative to the <a class="el" href="classFl__Window.html" title="This widget produces an actual window.">Fl_Window</a> it was passed to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga9801003f911eae0e49bf52b875dcaaa5">event_y_root</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position on the screen of the event.  <a href="group__fl__events.html#ga9801003f911eae0e49bf52b875dcaaa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga3130407bc1c11f9b7f2a9c43a87a1599">first_window</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first top-level window in the list of shown() windows.  <a href="group__fl__windows.html#ga3130407bc1c11f9b7f2a9c43a87a1599"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gabac1e48dd4e0fa7431776c1e754e273e">first_window</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the window that is returned by <a class="el" href="group__fl__windows.html#ga3130407bc1c11f9b7f2a9c43a87a1599" title="Returns the first top-level window in the list of shown() windows.">first_window()</a>.  <a href="group__fl__windows.html#gabac1e48dd4e0fa7431776c1e754e273e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes all the windows that need it to be redrawn and graphics forced out through the pipes.  <a href="#a08d29d807ea3874b8bb16f7457f64bdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga7f0e9836db43268979e0b3a999583b7f">focus</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current <a class="el" href="group__fl__events.html#ga7f0e9836db43268979e0b3a999583b7f" title="Gets the current Fl::focus() widget.">Fl::focus()</a> widget.  <a href="group__fl__events.html#ga7f0e9836db43268979e0b3a999583b7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga1f6eb61b05d03838978c6a1a8016ce7a">focus</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the widget that will receive FL_KEYBOARD events.  <a href="group__fl__events.html#ga1f6eb61b05d03838978c6a1a8016ce7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7">foreground</a> (<a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes fl_color(FL_FOREGROUND_COLOR).  <a href="#afbf02f998cce7ebb3331def57fccc8a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gae68ad6c3474fb71b3db5a44658b60b14">free_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i, int overlay=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the specified color from the colormap, if applicable.  <a href="group__fl__attributes.html#gae68ad6c3474fb71b3db5a44658b60b14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a837ed3f58be4ad9ed3949e31678bc8fe">get_awake_handler_</a> (<a class="el" href="group__callback__functions.html#ga13f70685dbd05cf1537f97f6e59c1e58">Fl_Awake_Handler</a> &amp;, void *&amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the last stored awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>.  <a href="#a837ed3f58be4ad9ed3949e31678bc8fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__callback__functions.html#gae409de0010a065c2b325aca0b2d92583">Fl_Box_Draw_F</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a62d53b0d7749d7c3d053e72ee2a5a816">get_boxtype</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current box drawing function for the specified box type.  <a href="#a62d53b0d7749d7c3d053e72ee2a5a816"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga4eb8db6ea9968f546687f89a4ec336a0">get_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &amp;red, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &amp;green, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &amp;blue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RGB value(s) for the given FLTK color index.  <a href="group__fl__attributes.html#ga4eb8db6ea9968f546687f89a4ec336a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga9977c7ef50c9f51efd0d7909020a16da">get_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RGB value(s) for the given FLTK color index.  <a href="group__fl__attributes.html#ga9977c7ef50c9f51efd0d7909020a16da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gac822bdf31f387b4dfc520e8b261b6b1a">get_font</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the string for this face.  <a href="group__fl__attributes.html#gac822bdf31f387b4dfc520e8b261b6b1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga90b30b9bc92f6a263928d028de07fe23">get_font_name</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, int *attributes=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a human-readable string describing the family of this face.  <a href="group__fl__attributes.html#ga90b30b9bc92f6a263928d028de07fe23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga435176ea0a7ed5b8e5eb65792cfbcb20">get_font_sizes</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, int *&amp;sizep)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of sizes in <code>sizep</code>.  <a href="group__fl__attributes.html#ga435176ea0a7ed5b8e5eb65792cfbcb20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gab7049319eed772c8a22cf2c0eb484a39">get_key</a> (int key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>key</code> is held down <em>now</em>.  <a href="group__fl__events.html#gab7049319eed772c8a22cf2c0eb484a39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga79a94c0ac0f71557ef4b6dc7b8d863db">get_mouse</a> (int &amp;, int &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return where the mouse is on the screen by doing a round-trip query to the server.  <a href="group__fl__events.html#ga79a94c0ac0f71557ef4b6dc7b8d863db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aed0a7958eebf1491685040be87490947">get_system_colors</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the user preference colors from the system and use them to call <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR).">Fl::foreground()</a>, <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a>, and <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color.">Fl::background2()</a>.  <a href="#aed0a7958eebf1491685040be87490947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3d21e87ef889306a7be56e94ea0bda10">gl_visual</a> (int, int *alist=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This does the same thing as <a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual(int)</a> but also requires OpenGL drawing to work.  <a href="#a3d21e87ef889306a7be56e94ea0bda10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab59edda7c6a51ff2cb4673f21b739088"></a><!-- doxytag: member="Fl::grab" ref="ab59edda7c6a51ff2cb4673f21b739088" args="(Fl_Window &amp;win)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ab59edda7c6a51ff2cb4673f21b739088">grab</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> &amp;win)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845" title="Selects the window to grab.">grab(Fl_Window*)</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga100705a8107397cfde7318aa34019739">grab</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the window that currently receives all events.  <a href="group__fl__windows.html#ga100705a8107397cfde7318aa34019739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845">grab</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the window to grab.  <a href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84">h</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height in pixels of the main screen work area.  <a href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga064a4028b27d7da1238a6e5280582abf">handle</a> (int, <a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle events from the window system.  <a href="group__fl__events.html#ga064a4028b27d7da1238a6e5280582abf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga9c55e69277a2197ca3763122ff2f78af">handle_</a> (int, <a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle events from the window system.  <a href="group__fl__events.html#ga9c55e69277a2197ca3763122ff2f78af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ab2ac86a4368147c075dd6750b03546"></a><!-- doxytag: member="Fl::has_check" ref="a3ab2ac86a4368147c075dd6750b03546" args="(Fl_Timeout_Handler, void *=0)" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3ab2ac86a4368147c075dd6750b03546">has_check</a> (<a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the check exists and has not been called yet, 0 otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f5d04106f8369655e51bd27e4953cd"></a><!-- doxytag: member="Fl::has_idle" ref="a41f5d04106f8369655e51bd27e4953cd" args="(Fl_Idle_Handler cb, void *data=0)" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a41f5d04106f8369655e51bd27e4953cd">has_idle</a> (<a class="el" href="group__callback__functions.html#ga9d8f4ff50ebb523a35fad2f30cf99768">Fl_Idle_Handler</a> cb, void *data=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified idle callback is currently installed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3164768ec950db81396b81ef42f8ba2"></a><!-- doxytag: member="Fl::has_timeout" ref="ae3164768ec950db81396b81ef42f8ba2" args="(Fl_Timeout_Handler, void *=0)" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae3164768ec950db81396b81ef42f8ba2">has_timeout</a> (<a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the timeout exists and has not been called yet. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2">lock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method blocks the current thread until it can safely access FLTK widgets and data.  <a href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gaf0938156f04e1babebaa8eb75a8d0fce">modal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top-most <a class="el" href="group__fl__windows.html#gaf0938156f04e1babebaa8eb75a8d0fce" title="Returns the top-most modal() window currently shown.">modal()</a> window currently shown.  <a href="group__fl__windows.html#gaf0938156f04e1babebaa8eb75a8d0fce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga46df67455d96ee45e51f59263c6bf0ea">next_window</a> (const <a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next top-level window in the list of shown() windows.  <a href="group__fl__windows.html#ga46df67455d96ee45e51f59263c6bf0ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">option</a> (<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a> opt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK library options management.  <a href="#abc49722be45fb56cad89c7c067eda5e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9b040cad5d6fc04bb139877015091c16">option</a> (<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a> opt, bool val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Override an option while the application is running.  <a href="#a9b040cad5d6fc04bb139877015091c16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a217dd709bed0d62a652625d505918fc6">own_colormap</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes FLTK use its own colormap.  <a href="#a217dd709bed0d62a652625d505918fc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga2514c08b3b2e43f849090cb636f34ce4">paste</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> &amp;receiver, int source)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pastes the data from the selection buffer (<code>source</code> is 0) or the clipboard (<code>source</code> is 1) into <code>receiver</code>.  <a href="group__fl__clipboard.html#ga2514c08b3b2e43f849090cb636f34ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga9d5cf78a03d0d619052dea890d97c71e">paste</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> &amp;receiver)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward compatibility only.  <a href="group__fl__clipboard.html#ga9d5cf78a03d0d619052dea890d97c71e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gadcd24382935bf08b56b1532dfe80da25">pushed</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the widget that is being pushed.  <a href="group__fl__events.html#gadcd24382935bf08b56b1532dfe80da25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga83b269dff4e6b30a876ec46b6f911fac">pushed</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the widget that is being pushed.  <a href="group__fl__events.html#ga83b269dff4e6b30a876ec46b6f911fac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c27ca2833030aa15482bd06dbfc5959"></a><!-- doxytag: member="Fl::readqueue" ref="a3c27ca2833030aa15482bd06dbfc5959" args="()" -->
static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3c27ca2833030aa15482bd06dbfc5959">readqueue</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">All Fl_Widgets that don't have a callback defined use a default callback that puts a pointer to the widget in this queue, and this method reads the oldest widget out of this queue. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f">ready</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is similar to <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> except this does <em>not</em> call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a> or any callbacks, which is useful if your program is in a state where such callbacks are illegal.  <a href="#a41a0cf2dd925cc6c4074d32a36fcf98f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeec5e7939d214882da2d31c894a5bad7"></a><!-- doxytag: member="Fl::redraw" ref="aeec5e7939d214882da2d31c894a5bad7" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aeec5e7939d214882da2d31c894a5bad7">redraw</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Redraws all widgets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a656023b0db49ae9b88e277ccdb27ce1b">release</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the current grabbed window, equals grab(0).  <a href="#a656023b0db49ae9b88e277ccdb27ce1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2">release_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a widget pointer from the watch list.  <a href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3cf6b5b7bfe06b268e8c51ec11acf378">reload_scheme</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by scheme according to scheme name.  <a href="#a3cf6b5b7bfe06b268e8c51ec11acf378"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a43ee3d6bb1c70f5202e7cc9cb87cd515">remove_check</a> (<a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a check callback.  <a href="#a43ee3d6bb1c70f5202e7cc9cb87cd515"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a4254e8bc88b9d4cb3e66152ac4caee86">remove_fd</a> (int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a file descriptor handler.  <a href="#a4254e8bc88b9d4cb3e66152ac4caee86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a1c7766bf3e45e170fe1741e98092e55f">remove_fd</a> (int, int when)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a file descriptor handler.  <a href="#a1c7766bf3e45e170fe1741e98092e55f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga057451b4da1df58193521d8206f29edf">remove_handler</a> (<a class="el" href="group__callback__functions.html#ga04194d0b454ba4013ff79ba688b594b5">Fl_Event_Handler</a> h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added event handler.  <a href="group__fl__events.html#ga057451b4da1df58193521d8206f29edf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43903f998a07e1cca7ba199c8ed25d9b"></a><!-- doxytag: member="Fl::remove_idle" ref="a43903f998a07e1cca7ba199c8ed25d9b" args="(Fl_Idle_Handler cb, void *data=0)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a43903f998a07e1cca7ba199c8ed25d9b">remove_idle</a> (<a class="el" href="group__callback__functions.html#ga9d8f4ff50ebb523a35fad2f30cf99768">Fl_Idle_Handler</a> cb, void *data=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified idle callback, if it is installed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9a950f0585de6416eb4fee2365a1578f">remove_timeout</a> (<a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a timeout callback.  <a href="#a9a950f0585de6416eb4fee2365a1578f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628">repeat_timeout</a> (double t, <a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate timing.  <a href="#ae5373d1d50c2b0ba38280d78bb6d2628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7a3b1236b41800d24267288c564b187a">run</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">As long as any windows are displayed this calls <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> repeatedly.  <a href="#a7a3b1236b41800d24267288c564b187a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48e0d5ea99335d7e4cdcf45d8dbe68b7"></a><!-- doxytag: member="Fl::scheme" ref="a48e0d5ea99335d7e4cdcf45d8dbe68b7" args="()" -->
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a48e0d5ea99335d7e4cdcf45d8dbe68b7">scheme</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See void <a class="el" href="classFl.html#a15a061056c940e811090976cbd733305" title="Gets or sets the current widget scheme.">scheme(const char *name)</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a15a061056c940e811090976cbd733305">scheme</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the current widget scheme.  <a href="#a15a061056c940e811090976cbd733305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa65116ad458fcb4a71c2f374de5dcd9"></a><!-- doxytag: member="Fl::screen_count" ref="gaaa65116ad458fcb4a71c2f374de5dcd9" args="()" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gaaa65116ad458fcb4a71c2f374de5dcd9">screen_count</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of available screens. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga1a2c5b6e73b53eb3d99ae34cd35c07cd">screen_dpi</a> (float &amp;h, float &amp;v, int n=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen resolution in dots-per-inch for the given screen.  <a href="group__fl__screen.html#ga1a2c5b6e73b53eb3d99ae34cd35c07cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gaf5d57c7b30d0b6e8adaa44027b89255e">screen_work_area</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of the work area of the screen that contains the mouse pointer.  <a href="group__fl__screen.html#gaf5d57c7b30d0b6e8adaa44027b89255e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga1b6d4dd670d06cd76ed0f3891ae80219">screen_work_area</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of the work area of the given screen.  <a href="group__fl__screen.html#ga1b6d4dd670d06cd76ed0f3891ae80219"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga0dc1a0cf192a9e4376932a595003a89e">screen_work_area</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int mx, int my)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of the work area of a screen that contains the specified screen position <code>mx</code>, <code>my</code>.  <a href="group__fl__screen.html#ga0dc1a0cf192a9e4376932a595003a89e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga510d26cb2d6ec0688cf1eb8c5d9e5a1e">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of a screen that contains the mouse pointer.  <a href="group__fl__screen.html#ga510d26cb2d6ec0688cf1eb8c5d9e5a1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gaba4caf50886ae88df6a957b8748ea113">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int mx, int my)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of a screen that contains the specified screen position <code>mx</code>, <code>my</code>.  <a href="group__fl__screen.html#gaba4caf50886ae88df6a957b8748ea113"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gab52242843912b524e4a083e3272a2009">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen bounding rect for the given screen.  <a href="group__fl__screen.html#gab52242843912b524e4a083e3272a2009"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gabe29a526a41ffb5df1c5116cf61ead54">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int mx, int my, int mw, int mh)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen bounding rect for the screen which intersects the most with the rectangle defined by <code>mx</code>, <code>my</code>, <code>mw</code>, <code>mh</code>.  <a href="group__fl__screen.html#gabe29a526a41ffb5df1c5116cf61ead54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aa6d2b6e0d640b81c6ec44d0164ec0f91">scrollbar_size</a> (int W)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default scrollbar size that is used by the <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers.">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text.">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window...">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget.">Fl_Text_Display</a> widgets.  <a href="#aa6d2b6e0d640b81c6ec44d0164ec0f91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a82c225037f05d07a7797da5eddafb33a">scrollbar_size</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default scrollbar size used by <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers.">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text.">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window...">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget.">Fl_Text_Display</a> widgets.  <a href="#a82c225037f05d07a7797da5eddafb33a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gac2993c9b0292c636357b1268fb63e827">selection</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> &amp;owner, const char *, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current selection.  <a href="group__fl__clipboard.html#gac2993c9b0292c636357b1268fb63e827"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gab237801bd5deece817c5001e9a72fdef">selection_owner</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">back-compatibility only: Gets the widget owning the current selection  <a href="group__fl__clipboard.html#gab237801bd5deece817c5001e9a72fdef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gaec21e41f0909a27c9906e1a12aee319b">selection_owner</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-compatibility only: The single-argument call can be used to move the selection to another widget or to set the owner to NULL, without changing the actual text of the selection.  <a href="group__fl__clipboard.html#gaec21e41f0909a27c9906e1a12aee319b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa52e562142bd1e8d5ba6915ff5577245"></a><!-- doxytag: member="Fl::set_abort" ref="gaa52e562142bd1e8d5ba6915ff5577245" args="(Fl_Abort_Handler f)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gaa52e562142bd1e8d5ba6915ff5577245">set_abort</a> (<a class="el" href="group__callback__functions.html#gad44ee1da9693f8e429559c811ebeb71e">Fl_Abort_Handler</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For back compatibility, sets the void <a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a" title="FLTK calls Fl::fatal() to output a fatal error message.">Fl::fatal</a> handler callback. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gafe2b995bdaf60c5a5b2326e8845897c9">set_atclose</a> (<a class="el" href="group__callback__functions.html#gae8b076b8ff88ad6e337172333429f38f">Fl_Atclose_Handler</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For back compatibility, sets the <a class="el" href="group__fl__windows.html#gae12b7a5bf8f0db702bd9036497c70623" title="Back compatibility: default window callback handler.">Fl::atclose</a> handler callback.  <a href="group__fl__windows.html#gafe2b995bdaf60c5a5b2326e8845897c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a337397ba0fb948633c83ad7c39a67e00">set_boxtype</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>, <a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a> from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the from boxtype.  <a href="#a337397ba0fb948633c83ad7c39a67e00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a73e0e8fefe8707817ca6fd6437c4869b">set_boxtype</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>, <a class="el" href="group__callback__functions.html#gae409de0010a065c2b325aca0b2d92583">Fl_Box_Draw_F</a> *, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function to call to draw a specific boxtype.  <a href="#a73e0e8fefe8707817ca6fd6437c4869b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gaa6a6050ee3979754023eb1e66976240d">set_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i, unsigned c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry in the fl_color index table.  <a href="group__fl__attributes.html#gaa6a6050ee3979754023eb1e66976240d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gac62f634ba8089a9d0e48bf57154c61b0">set_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry in the fl_color index table.  <a href="group__fl__attributes.html#gac62f634ba8089a9d0e48bf57154c61b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga15dee80a622a9ab2798acfdc0aabcd95">set_font</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, const char *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a face.  <a href="group__fl__attributes.html#ga15dee80a622a9ab2798acfdc0aabcd95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gace5762f829e283f7965eca8d70042a32">set_font</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, <a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one face to another.  <a href="group__fl__attributes.html#gace5762f829e283f7965eca8d70042a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gadfa546e0caa16420399c3202fd75efd4">set_fonts</a> (const char *=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK will open the display, and add every fonts on the server to the face table.  <a href="group__fl__attributes.html#gadfa546e0caa16420399c3202fd75efd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a77955ad2f2b83fc5e3925b94e4533b20">set_idle</a> (<a class="el" href="group__callback__functions.html#ga63ceabf6cd80d8dfcecd1c41184bf9df">Fl_Old_Idle_Handler</a> cb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an idle callback.  <a href="#a77955ad2f2b83fc5e3925b94e4533b20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a2041799ff3f57f4cced52d7e3b3a544a">set_labeltype</a> (<a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>, <a class="el" href="group__callback__functions.html#gac4d39eb6338c82c9ebcc6c25f596191d">Fl_Label_Draw_F</a> *, <a class="el" href="group__callback__functions.html#ga92c6decef7b9cc6a74dcc66573dd22a0">Fl_Label_Measure_F</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the functions to call to draw and measure a specific labeltype.  <a href="#a2041799ff3f57f4cced52d7e3b3a544a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ad1633da3e36598ebe875f0c16fc9f198">set_labeltype</a> (<a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>, <a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a> from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the functions to call to draw and measure a specific labeltype.  <a href="#ad1633da3e36598ebe875f0c16fc9f198"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gab8b767183ac691d4249f599b94dafe78">test_shortcut</a> (<a class="el" href="fl__types_8h.html#a37ec1cd050a604a45dff00efba45609d">Fl_Shortcut</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the current event, which must be an FL_KEYBOARD or FL_SHORTCUT, against a shortcut value (described in <a class="el" href="classFl__Button.html" title="Buttons generate callbacks when they are clicked by the user.">Fl_Button</a>).  <a href="group__fl__events.html#gab8b767183ac691d4249f599b94dafe78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e">thread_message</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">thread_message()</a> method returns the last message that was sent from a child by the <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a> method.  <a href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd">unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> method releases the lock that was set using the <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method.  <a href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ad65803adc5e4936111bd31a52f1d61a7">version</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compiled-in value of the FL_VERSION constant.  <a href="#ad65803adc5e4936111bd31a52f1d61a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ade5fd097d36257dce2b7aff1165e037f">visible_focus</a> (int v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the visible keyboard focus on buttons and other non-text widgets.  <a href="#ade5fd097d36257dce2b7aff1165e037f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae9eaddd02a0aa637078ee2dd80b85b2f">visible_focus</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the visible keyboard focus on buttons and other non-text widgets.  <a href="#ae9eaddd02a0aa637078ee2dd80b85b2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0">visual</a> (int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects a visual so that your graphics are drawn correctly.  <a href="#a6d6deb3d4f76b538d508b36700dfb6b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga4fcd39428db4299026322c91715cf379">w</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width in pixels of the main screen work area.  <a href="group__fl__screen.html#ga4fcd39428db4299026322c91715cf379"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312">wait</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until "something happens" and then returns.  <a href="#a108a84216f0b3fa1cb0c46ab7449a312"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af49654e35a0b636aa751dce5ff88a7f5"></a><!-- doxytag: member="Fl::wait" ref="af49654e35a0b636aa751dce5ff88a7f5" args="(double time)" -->
static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#af49654e35a0b636aa751dce5ff88a7f5">wait</a> (double time)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See int <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9">watch_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a widget pointer to the widget watch list.  <a href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga129f4b9d14ad1d720d60b7881693d6ec">x</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the leftmost x coordinate of the main screen work area.  <a href="group__fl__screen.html#ga129f4b9d14ad1d720d60b7881693d6ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga6c89bea45612ee83941e879b3396d3a5">y</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the topmost y coordinate of the main screen work area.  <a href="group__fl__screen.html#ga6c89bea45612ee83941e879b3396d3a5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gae12b7a5bf8f0db702bd9036497c70623">atclose</a> )(<a class="el" href="classFl__Window.html">Fl_Window</a> *, void *) = default_atclose</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Back compatibility: default window callback handler.  <a href="group__fl__windows.html#gae12b7a5bf8f0db702bd9036497c70623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23">error</a> )(const char *,...) = ::<a class="el" href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23">error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK calls <a class="el" href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23" title="FLTK calls Fl::error() to output a normal error message.">Fl::error()</a> to output a normal error message.  <a href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a">fatal</a> )(const char *,...) = ::<a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a">fatal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK calls <a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a" title="FLTK calls Fl::fatal() to output a fatal error message.">Fl::fatal()</a> to output a fatal error message.  <a href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a64d41edd7d962116d86a9db810210f7b">help</a> = helpmsg+13</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Usage string displayed if <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args()</a> detects an invalid argument.  <a href="#a64d41edd7d962116d86a9db810210f7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a60fb2b446096dd4742511edb459653d3">idle</a> )()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently executing idle callback function: DO NOT USE THIS DIRECTLY!  <a href="#a60fb2b446096dd4742511edb459653d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__comdlg.html#gadec4624fcfc09e75fdaf59c2553fe8a9">warning</a> )(const char *,...) = ::<a class="el" href="group__group__comdlg.html#gadec4624fcfc09e75fdaf59c2553fe8a9">warning</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK calls <a class="el" href="group__group__comdlg.html#gadec4624fcfc09e75fdaf59c2553fe8a9" title="FLTK calls Fl::warning() to output a warning message.">Fl::warning()</a> to output a warning message.  <a href="group__group__comdlg.html#gadec4624fcfc09e75fdaf59c2553fe8a9"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classFl.html" title="The Fl is the FLTK global (static) class containing state information and global methods for the curr...">Fl</a> is the FLTK global (static) class containing state information and global methods for the current application. </p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a43e6e0bbbc03cad134d928d4edd48d1d"></a><!-- doxytag: member="Fl::Fl_Option" ref="a43e6e0bbbc03cad134d928d4edd48d1d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl::Fl_Option</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerator for global FLTK options. </p>
<p>These options can be set system wide, per user, or for the running application only. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl.html#a9b040cad5d6fc04bb139877015091c16" title="Override an option while the application is running.">Fl::option(Fl_Option, bool)</a> </dd>
<dd>
<a class="el" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3" title="FLTK library options management.">Fl::option(Fl_Option)</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6"></a><!-- doxytag: member="OPTION_ARROW_FOCUS" ref="a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6" args="" -->OPTION_ARROW_FOCUS</em>&nbsp;</td><td>
<p>When switched on, moving the text cursor beyond the start or end of a text in a text widget will change focus to the next text widget. </p>
<p>When switched off, the cursor will stop at the end of the text. Pressing Tab or Ctrl-Tab will advance the keyboard focus. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a43e6e0bbbc03cad134d928d4edd48d1dade29f22fc8066222d99ea3ccebc5e655"></a><!-- doxytag: member="OPTION_VISIBLE_FOCUS" ref="a43e6e0bbbc03cad134d928d4edd48d1dade29f22fc8066222d99ea3ccebc5e655" args="" -->OPTION_VISIBLE_FOCUS</em>&nbsp;</td><td>
<p>If visible focus is switched on, FLTK will draw a dotted rectangle inside the widget that will receive the next keystroke. </p>
<p>If switched off, no such indicator will be drawn and keyboard navigation is disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a43e6e0bbbc03cad134d928d4edd48d1da2344bf14f80ecf5971e8aa4493a3858a"></a><!-- doxytag: member="OPTION_DND_TEXT" ref="a43e6e0bbbc03cad134d928d4edd48d1da2344bf14f80ecf5971e8aa4493a3858a" args="" -->OPTION_DND_TEXT</em>&nbsp;</td><td>
<p>If text drag-and-drop is enabled, the user can select and drag text from any text widget. </p>
<p>If disabled, no dragging is possible, however dropping text from other applications still works. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a43e6e0bbbc03cad134d928d4edd48d1dae8214e42f77fe157297d61fdb818be2f"></a><!-- doxytag: member="OPTION_SHOW_TOOLTIPS" ref="a43e6e0bbbc03cad134d928d4edd48d1dae8214e42f77fe157297d61fdb818be2f" args="" -->OPTION_SHOW_TOOLTIPS</em>&nbsp;</td><td>
<p>If tooltips are enabled, hovering the mouse over a widget with a tooltip text will open a little tooltip window until the mouse leaves the widget. </p>
<p>If disabled, no tooltip is shown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a43e6e0bbbc03cad134d928d4edd48d1da220ebf62255fc47e5b5f213b410e2bc5"></a><!-- doxytag: member="OPTION_LAST" ref="a43e6e0bbbc03cad134d928d4edd48d1da220ebf62255fc47e5b5f213b410e2bc5" args="" -->OPTION_LAST</em>&nbsp;</td><td>
<p>For internal use only. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afff1ee2c6afa6463293a2188a44b00b5"></a><!-- doxytag: member="Fl::add_awake_handler_" ref="afff1ee2c6afa6463293a2188a44b00b5" args="(Fl_Awake_Handler, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::add_awake_handler_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga13f70685dbd05cf1537f97f6e59c1e58">Fl_Awake_Handler</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>. </p>

</div>
</div>
<a class="anchor" id="a7b689a9e42582fe6e87f7c7eb1dce94f"></a><!-- doxytag: member="Fl::add_check" ref="a7b689a9e42582fe6e87f7c7eb1dce94f" args="(Fl_Timeout_Handler, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>FLTK will call this callback just before it flushes the display and waits for events. </p>
<p>This is different than an idle callback because it is only called once, then FLTK calls the system and tells it not to return until an event happens.</p>
<p>This can be used by code that wants to monitor the application's state, such as to keep a display up to date. The advantage of using a check callback is that it is called only when no events are pending. If events are coming in quickly, whole blocks of them will be processed before this is called once. This can save significant time and avoid the application falling behind the events.</p>
<p>Sample code:</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> state_changed; <span class="comment">// anything that changes the display turns this on</span>

  <span class="keywordtype">void</span> callback(<span class="keywordtype">void</span>*) {
   <span class="keywordflow">if</span> (!state_changed) <span class="keywordflow">return</span>;
   state_changed = <span class="keyword">false</span>;
   do_expensive_calculation();
   widget-&amp;gt;<a class="code" href="classFl.html#aeec5e7939d214882da2d31c894a5bad7" title="Redraws all widgets.">redraw</a>();
  }

  main() {
   <a class="code" href="classFl.html#a7b689a9e42582fe6e87f7c7eb1dce94f" title="FLTK will call this callback just before it flushes the display and waits for events.">Fl::add_check</a>(callback);
   <span class="keywordflow">return</span> <a class="code" href="classFl.html#a7a3b1236b41800d24267288c564b187a" title="As long as any windows are displayed this calls Fl::wait() repeatedly.">Fl::run</a>();
  }
</pre></div> 
</div>
</div>
<a class="anchor" id="a799b8278326b3c2db15687c43c11aaf6"></a><!-- doxytag: member="Fl::add_fd" ref="a799b8278326b3c2db15687c43c11aaf6" args="(int fd, int when, Fl_FD_Handler cb, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::add_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gab7d7013178be0e856a3beb0588910704">Fl_FD_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds file descriptor fd to listen to. </p>
<p>When the fd becomes ready for reading <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> will call the callback and then return. The callback is passed the fd and the arbitrary void* argument.</p>
<p>The second version takes a when bitfield, with the bits FL_READ, FL_WRITE, and FL_EXCEPT defined, to indicate when the callback should be done.</p>
<p>There can only be one callback of each type for a file descriptor. <a class="el" href="classFl.html#a1c7766bf3e45e170fe1741e98092e55f" title="Removes a file descriptor handler.">Fl::remove_fd()</a> gets rid of <em>all</em> the callbacks for a given file descriptor.</p>
<p>Under UNIX <em>any</em> file descriptor can be monitored (files, devices, pipes, sockets, etc.). Due to limitations in Microsoft Windows, WIN32 applications can only monitor sockets. </p>

</div>
</div>
<a class="anchor" id="a4e7a1b5d18c2f073238a8466a62a3e7a"></a><!-- doxytag: member="Fl::add_idle" ref="a4e7a1b5d18c2f073238a8466a62a3e7a" args="(Fl_Idle_Handler cb, void *data=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga9d8f4ff50ebb523a35fad2f30cf99768">Fl_Idle_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a callback function that is called every time by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> and also makes it act as though the timeout is zero (this makes <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> return immediately, so if it is in a loop it is called repeatedly, and thus the idle fucntion is called repeatedly). </p>
<p>The idle function can be used to get background processing done.</p>
<p>You can have multiple idle callbacks. To remove an idle callback use <a class="el" href="classFl.html#a43903f998a07e1cca7ba199c8ed25d9b" title="Removes the specified idle callback, if it is installed.">Fl::remove_idle()</a>.</p>
<p><a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> and <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> call idle callbacks, but <a class="el" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f" title="This is similar to Fl::check() except this does not call Fl::flush() or any callbacks, which is useful if your program is in a state where such callbacks are illegal.">Fl::ready()</a> does not.</p>
<p>The idle callback can call any FLTK functions, including <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a>, <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a>, and <a class="el" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f" title="This is similar to Fl::check() except this does not call Fl::flush() or any callbacks, which is useful if your program is in a state where such callbacks are illegal.">Fl::ready()</a>.</p>
<p>FLTK will not recursively call the idle callback. </p>

</div>
</div>
<a class="anchor" id="a23e63eb7cec3a27fa360e66c6e2b2e52"></a><!-- doxytag: member="Fl::add_timeout" ref="a23e63eb7cec3a27fa360e66c6e2b2e52" args="(double t, Fl_Timeout_Handler, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_timeout </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a one-shot timeout callback. </p>
<p>The function will be called by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> at <em>t</em> seconds after this function is called. The optional void* argument is passed to the callback.</p>
<p>You can have multiple timeout callbacks. To remove a timeout callback use <a class="el" href="classFl.html#a9a950f0585de6416eb4fee2365a1578f" title="Removes a timeout callback.">Fl::remove_timeout()</a>.</p>
<p>If you need more accurate, repeated timeouts, use <a class="el" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628" title="Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate ti...">Fl::repeat_timeout()</a> to reschedule the subsequent timeouts.</p>
<p>The following code will print "TICK" each second on stdout with a fair degree of accuracy:</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> callback(<span class="keywordtype">void</span>*) {
       puts(<span class="stringliteral">&quot;TICK&quot;</span>);
       <a class="code" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628" title="Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate ti...">Fl::repeat_timeout</a>(1.0, callback);
     }
  
     <span class="keywordtype">int</span> main() {
       <a class="code" href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52" title="Adds a one-shot timeout callback.">Fl::add_timeout</a>(1.0, callback);
       <span class="keywordflow">return</span> <a class="code" href="classFl.html#a7a3b1236b41800d24267288c564b187a" title="As long as any windows are displayed this calls Fl::wait() repeatedly.">Fl::run</a>();
     }
</pre></div> 
</div>
</div>
<a class="anchor" id="a1576b8c9ca3e900daaa5c36ca0e7ae48"></a><!-- doxytag: member="Fl::arg" ref="a1576b8c9ca3e900daaa5c36ca0e7ae48" args="(int argc, char **argv, int &amp;i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a single switch from <code>argv</code>, starting at word <code>i</code>. </p>
<p>Returns the number of words eaten (1 or 2, or 0 if it is not recognized) and adds the same value to <code>i</code>.</p>
<p>This is the default argument handler used internally by <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args</a>(...), but you can use this function if you prefer to step through the standard FLTK switches yourself.</p>
<p>All standard FLTK switches except -bg2 may be abbreviated to just one letter and case is ignored:</p>
<ul>
<li>-bg color or -background color <br/>
 Sets the background color using <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a>.</li>
</ul>
<ul>
<li>-bg2 color or -background2 color <br/>
 Sets the secondary background color using <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color.">Fl::background2()</a>.</li>
</ul>
<ul>
<li>-display host:n.n <br/>
 Sets the X display to use; this option is silently ignored under WIN32 and MacOS.</li>
</ul>
<ul>
<li>-dnd and -nodnd <br/>
 Enables or disables drag and drop text operations using <a class="el" href="classFl.html#aae157def51e4dabe5f75298b676ddea2" title="Gets or sets whether drag and drop text operations are supported.">Fl::dnd_text_ops()</a>.</li>
</ul>
<ul>
<li>-fg color or -foreground color <br/>
 Sets the foreground color using <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR).">Fl::foreground()</a>.</li>
</ul>
<ul>
<li>-geometry WxH+X+Y <br/>
 Sets the initial window position and size according to the standard X geometry string.</li>
</ul>
<ul>
<li>-iconic <br/>
 Iconifies the window using <a class="el" href="classFl__Window.html#a473a9728b4275ce16347e74faafb3cde" title="Iconifies the window.">Fl_Window::iconize()</a>.</li>
</ul>
<ul>
<li>-kbd and -nokbd <br/>
 Enables or disables visible keyboard focus for non-text widgets using <a class="el" href="classFl.html#ae9eaddd02a0aa637078ee2dd80b85b2f" title="Gets or sets the visible keyboard focus on buttons and other non-text widgets.">Fl::visible_focus()</a>.</li>
</ul>
<ul>
<li>-name string <br/>
 Sets the window class using <a class="el" href="classFl__Window.html#aa72d16b01745c1b396a654527012a6db" title="Returns the xclass for this window, or a default.">Fl_Window::xclass()</a>.</li>
</ul>
<ul>
<li>-scheme string <br/>
 Sets the widget scheme using <a class="el" href="classFl.html#a48e0d5ea99335d7e4cdcf45d8dbe68b7" title="See void scheme(const char *name)">Fl::scheme()</a>.</li>
</ul>
<ul>
<li>-title string <br/>
 Sets the window title using <a class="el" href="classFl__Window.html#a51a6665c988138e426fc12b4bf138f7b" title="See void Fl_Window::label(const char*)">Fl_Window::label()</a>.</li>
</ul>
<ul>
<li>-tooltips and -notooltips <br/>
 Enables or disables tooltips using <a class="el" href="classFl__Tooltip.html#aad7ec1340800ab9d883a035118f20995" title="Enables tooltips on all widgets (or disables if b is false).">Fl_Tooltip::enable()</a>.</li>
</ul>
<p>If your program requires other switches in addition to the standard FLTK options, you will need to pass your own argument handler to <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args(int,char**,int&amp;,Fl_Args_Handler)</a> explicitly. </p>

</div>
</div>
<a class="anchor" id="a6fb24179ad2642412f4042863fe23645"></a><!-- doxytag: member="Fl::args" ref="a6fb24179ad2642412f4042863fe23645" args="(int argc, char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse all command line switches matching standard FLTK options only. </p>
<p>It parses all the switches, and if any are not recognized it calls Fl::abort(Fl::help), i.e. unlike the long form, an unrecognized switch generates an error message and causes the program to exit. </p>

</div>
</div>
<a class="anchor" id="a115903daf3593748cdd36a5e78e74534"></a><!-- doxytag: member="Fl::args" ref="a115903daf3593748cdd36a5e78e74534" args="(int argc, char **argv, int &amp;i, Fl_Args_Handler cb=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gae17a8b5aa56e828c14f0fc7da7766a16">Fl_Args_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse command line switches using the <code>cb</code> argument handler. </p>
<p>Returns 0 on error, or the number of words processed.</p>
<p>FLTK provides this as an <em>entirely optional</em> command line switch parser. You don't have to call it if you don't want to. Everything it can do can be done with other calls to FLTK.</p>
<p>To use the switch parser, call <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args</a>(...) near the start of your program. This does <b>not</b> open the display, instead switches that need the display open are stashed into static variables. Then you <b>must</b> display your first window by calling <code>window-&gt;show(argc,argv)</code>, which will do anything stored in the static variables.</p>
<p>Providing an argument handler callback <code>cb</code> lets you define your own switches. It is called with the same <code>argc</code> and <code>argv</code>, and with <code>i</code> set to the index of the switch to be processed. The <code>cb</code> handler should return zero if the switch is unrecognized, and not change <code>i</code>. It should return non-zero to indicate the number of words processed if the switch is recognized, i.e. 1 for just the switch, and more than 1 for the switch plus associated parameters. <code>i</code> should be incremented by the same amount.</p>
<p>The <code>cb</code> handler is called <b>before</b> any other tests, so <em>you can also override any standard FLTK switch</em> (this is why FLTK can use very short switches instead of the long ones all other toolkits force you to use). See <a class="el" href="classFl.html#a1576b8c9ca3e900daaa5c36ca0e7ae48" title="Parse a single switch from argv, starting at word i.">Fl::arg()</a> for descriptions of the standard switches.</p>
<p>On return <code>i</code> is set to the index of the first non-switch. This is either:</p>
<ul>
<li>The first word that does not start with '-'. </li>
<li>The word '-' (used by many programs to name stdin as a file) </li>
<li>The first unrecognized switch (return value is 0). </li>
<li><code>argc</code> </li>
</ul>
<p>The return value is <code>i</code> unless an unrecognized switch is found, in which case it is zero. If your program takes no arguments other than switches you should produce an error if the return value is less than <code>argc</code>.</p>
<p>A usage string is displayed if <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args()</a> detects an invalid argument on the command-line. You can change the message by setting the <a class="el" href="classFl.html#a64d41edd7d962116d86a9db810210f7b" title="Usage string displayed if Fl::args() detects an invalid argument.">Fl::help</a> pointer.</p>
<p>A very simple command line parser can be found in <code>examples/howto-parse-args.cxx</code></p>
<p>The simpler <a class="el" href="classFl.html#a6fb24179ad2642412f4042863fe23645" title="Parse all command line switches matching standard FLTK options only.">Fl::args(int argc, char **argv)</a> form is useful if your program does not have command line switches of its own. </p>

</div>
</div>
<a class="anchor" id="a422da0dfc6aa51721e7c9a6ccf5b90ef"></a><!-- doxytag: member="Fl::background" ref="a422da0dfc6aa51721e7c9a6ccf5b90ef" args="(uchar, uchar, uchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to black to white. </p>
<p>These are the colors used as backgrounds by almost all widgets and used to draw the edges of all the boxtypes. </p>

</div>
</div>
<a class="anchor" id="a98d4c4557a2127bfc46abe15feed3be2"></a><!-- doxytag: member="Fl::background2" ref="a98d4c4557a2127bfc46abe15feed3be2" args="(uchar, uchar, uchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::background2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the alternative background color. </p>
<p>This color is used as a background by <a class="el" href="classFl__Input.html" title="This is the FLTK text input widget.">Fl_Input</a> and other text widgets. </p>
<p>This call may change fl_color(FL_FOREGROUND_COLOR) if it does not provide sufficient contrast to FL_BACKGROUND2_COLOR. </p>

</div>
</div>
<a class="anchor" id="af739a06d44dc94d09015ed1940b9f066"></a><!-- doxytag: member="Fl::box_dh" ref="af739a06d44dc94d09015ed1940b9f066" args="(Fl_Boxtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the height offset for the given boxtype. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype.">box_dy()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a327ed95a8c2533ca4eee659bf3d557"></a><!-- doxytag: member="Fl::box_dw" ref="a9a327ed95a8c2533ca4eee659bf3d557" args="(Fl_Boxtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the width offset for the given boxtype. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype.">box_dy()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2971f20fe3595fd8f77fe73d4eb89594"></a><!-- doxytag: member="Fl::box_dx" ref="a2971f20fe3595fd8f77fe73d4eb89594" args="(Fl_Boxtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the X offset for the given boxtype. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype.">box_dy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9fbd0a2a5c43a30893dec05e8d34dc15"></a><!-- doxytag: member="Fl::box_dy" ref="a9fbd0a2a5c43a30893dec05e8d34dc15" args="(Fl_Boxtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Y offset for the given boxtype. </p>
<p>These functions return the offset values necessary for a given boxtype, useful for computing the area inside a box's borders, to prevent overdrawing the borders.</p>
<p>For instance, in the case of a boxtype like FL_DOWN_BOX where the border width might be 2 pixels all around, the above functions would return 2, 2, 4, and 4 for box_dx, box_dy, box_dw, and box_dh respectively.</p>
<p>An example to compute the area inside a widget's box(): </p>
<div class="fragment"><pre class="fragment">         <span class="keywordtype">int</span> X = yourwidget-&gt;x() + <a class="code" href="classFl.html#a2971f20fe3595fd8f77fe73d4eb89594" title="Returns the X offset for the given boxtype.">Fl::box_dx</a>(yourwidget-&gt;box());
         <span class="keywordtype">int</span> Y = yourwidget-&gt;y() + <a class="code" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype.">Fl::box_dy</a>(yourwidget-&gt;box());
         <span class="keywordtype">int</span> W = yourwidget-&gt;w() - <a class="code" href="classFl.html#a9a327ed95a8c2533ca4eee659bf3d557" title="Returns the width offset for the given boxtype.">Fl::box_dw</a>(yourwidget-&gt;box());
         <span class="keywordtype">int</span> H = yourwidget-&gt;h() - <a class="code" href="classFl.html#af739a06d44dc94d09015ed1940b9f066" title="Returns the height offset for the given boxtype.">Fl::box_dh</a>(yourwidget-&gt;box());
</pre></div><p> These functions are mainly useful in the draw() code for deriving custom widgets, where one wants to avoid drawing over the widget's own border box(). </p>

</div>
</div>
<a class="anchor" id="a1dbb83f1d52001c152ccf8415e3ee6f0"></a><!-- doxytag: member="Fl::check" ref="a1dbb83f1d52001c152ccf8415e3ee6f0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as Fl::wait(0). </p>
<p>Calling this during a big calculation will keep the screen up to date and the interface responsive:</p>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">while</span> (!calculation_done()) {
  calculate();
  <a class="code" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check</a>();
  <span class="keywordflow">if</span> (user_hit_abort_button()) <span class="keywordflow">break</span>;
  }
</pre></div><p>This returns non-zero if any windows are displayed, and 0 if no windows are displayed (this is likely to change in future versions of FLTK). </p>

</div>
</div>
<a class="anchor" id="ac5e4de1119ebb169c8a8de4c81a4cb59"></a><!-- doxytag: member="Fl::damage" ref="ac5e4de1119ebb169c8a8de4c81a4cb59" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::damage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true then <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">flush()</a> will do something. </p>

</div>
</div>
<a class="anchor" id="a7c6847e1b7dd9628821656933ca8e79d"></a><!-- doxytag: member="Fl::display" ref="a7c6847e1b7dd9628821656933ca8e79d" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::display </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the X display to use for all windows. </p>
<p>Actually this just sets the environment variable $DISPLAY to the passed string, so this only works before you show() the first window or otherwise open the display, and does nothing useful under WIN32. </p>

</div>
</div>
<a class="anchor" id="a53430e25b53f3b608193fa4009898463"></a><!-- doxytag: member="Fl::dnd_text_ops" ref="a53430e25b53f3b608193fa4009898463" args="(int v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::dnd_text_ops </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets or sets whether drag and drop text operations are supported. </p>
<p>This specifically affects whether selected text can be dragged from text fields or dragged within a text field as a cut/paste shortcut. </p>

</div>
</div>
<a class="anchor" id="aae157def51e4dabe5f75298b676ddea2"></a><!-- doxytag: member="Fl::dnd_text_ops" ref="aae157def51e4dabe5f75298b676ddea2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::dnd_text_ops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets or sets whether drag and drop text operations are supported. </p>
<p>This specifically affects whether selected text can be dragged from text fields or dragged within a text field as a cut/paste shortcut. </p>

</div>
</div>
<a class="anchor" id="ad56cf568ee94318b50d2b2da0aa3031b"></a><!-- doxytag: member="Fl::draw_box_active" ref="ad56cf568ee94318b50d2b2da0aa3031b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::draw_box_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if the current draw box is active or inactive. </p>
<p>If inactive, the box color is changed by the inactive color. </p>

</div>
</div>
<a class="anchor" id="a08d29d807ea3874b8bb16f7457f64bdc"></a><!-- doxytag: member="Fl::flush" ref="a08d29d807ea3874b8bb16f7457f64bdc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Causes all the windows that need it to be redrawn and graphics forced out through the pipes. </p>
<p>This is what <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">wait()</a> does before looking for events.</p>
<p>Note: in multi-threaded applications you should only call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a> from the main thread. If a child thread needs to trigger a redraw event, it should instead call <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake()</a> to get the main thread to process the event queue. </p>

</div>
</div>
<a class="anchor" id="afbf02f998cce7ebb3331def57fccc8a7"></a><!-- doxytag: member="Fl::foreground" ref="afbf02f998cce7ebb3331def57fccc8a7" args="(uchar, uchar, uchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::foreground </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes fl_color(FL_FOREGROUND_COLOR). </p>

</div>
</div>
<a class="anchor" id="a837ed3f58be4ad9ed3949e31678bc8fe"></a><!-- doxytag: member="Fl::get_awake_handler_" ref="a837ed3f58be4ad9ed3949e31678bc8fe" args="(Fl_Awake_Handler &amp;, void *&amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::get_awake_handler_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga13f70685dbd05cf1537f97f6e59c1e58">Fl_Awake_Handler</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the last stored awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>. </p>

</div>
</div>
<a class="anchor" id="a62d53b0d7749d7c3d053e72ee2a5a816"></a><!-- doxytag: member="Fl::get_boxtype" ref="a62d53b0d7749d7c3d053e72ee2a5a816" args="(Fl_Boxtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__callback__functions.html#gae409de0010a065c2b325aca0b2d92583">Fl_Box_Draw_F</a> * Fl::get_boxtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current box drawing function for the specified box type. </p>

</div>
</div>
<a class="anchor" id="aed0a7958eebf1491685040be87490947"></a><!-- doxytag: member="Fl::get_system_colors" ref="aed0a7958eebf1491685040be87490947" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::get_system_colors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the user preference colors from the system and use them to call <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR).">Fl::foreground()</a>, <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a>, and <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color.">Fl::background2()</a>. </p>
<p>This is done by Fl_Window::show(argc,argv) before applying the -fg and -bg switches.</p>
<p>On X this reads some common values from the Xdefaults database. KDE users can set these values by running the "krdb" program, and newer versions of KDE set this automatically if you check the "apply
    style to other X programs" switch in their control panel. </p>

</div>
</div>
<a class="anchor" id="a3d21e87ef889306a7be56e94ea0bda10"></a><!-- doxytag: member="Fl::gl_visual" ref="a3d21e87ef889306a7be56e94ea0bda10" args="(int, int *alist=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::gl_visual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>alist</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This does the same thing as <a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual(int)</a> but also requires OpenGL drawing to work. </p>
<p>This <em>must</em> be done if you want to draw in normal windows with OpenGL with <a class="el" href="gl_8h.html#a9c922d784b80b39b0e64c8f4cfb5d123" title="Creates an OpenGL context.">gl_start()</a> and gl_end(). It may be useful to call this so your X windows use the same visual as an <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>, which on some servers will reduce colormap flashing.</p>
<p>See <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> for a list of additional values for the argument. </p>

</div>
</div>
<a class="anchor" id="abc49722be45fb56cad89c7c067eda5e3"></a><!-- doxytag: member="Fl::option" ref="abc49722be45fb56cad89c7c067eda5e3" args="(Fl_Option opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Fl::option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a>&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>FLTK library options management. </p>
<p>This function needs to be documented in more detail. It can be used for more optional settings, such as using a native file chooser instead of the FLTK one wherever possible, disabling tooltips, disabling visible focus, disabling FLTK file chooser preview, etc. .</p>
<p>There should be a command line option interface.</p>
<p>There should be an application that manages options system wide, per user, and per application.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">if</span> ( <a class="code" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3" title="FLTK library options management.">Fl::option</a>(<a class="code" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6" title="When switched on, moving the text cursor beyond the start or end of a text in a text widget will chan...">Fl::OPTION_ARROW_FOCUS</a>) )
         { ..on..  }
     <span class="keywordflow">else</span>
         { ..off..  }
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>As of FLTK 1.3.0, options can be managed within fluid, using the menu <em>Edit/Global FLTK Settings</em>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>which option </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true or false </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>enum <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d" title="Enumerator for global FLTK options.">Fl::Fl_Option</a> </dd>
<dd>
<a class="el" href="classFl.html#a9b040cad5d6fc04bb139877015091c16" title="Override an option while the application is running.">Fl::option(Fl_Option, bool)</a></dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>FLTK 1.3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9b040cad5d6fc04bb139877015091c16"></a><!-- doxytag: member="Fl::option" ref="a9b040cad5d6fc04bb139877015091c16" args="(Fl_Option opt, bool val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override an option while the application is running. </p>
<p>This function does not change any system or user settings.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">     <a class="code" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3" title="FLTK library options management.">Fl::option</a>(<a class="code" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6" title="When switched on, moving the text cursor beyond the start or end of a text in a text widget will chan...">Fl::OPTION_ARROW_FOCUS</a>, <span class="keyword">true</span>);     <span class="comment">// on</span>
     <a class="code" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3" title="FLTK library options management.">Fl::option</a>(<a class="code" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6" title="When switched on, moving the text cursor beyond the start or end of a text in a text widget will chan...">Fl::OPTION_ARROW_FOCUS</a>, <span class="keyword">false</span>);    <span class="comment">// off</span>
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>which option </td></tr>
    <tr><td class="paramname">val</td><td>set to true or false </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>enum <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d" title="Enumerator for global FLTK options.">Fl::Fl_Option</a> </dd>
<dd>
bool <a class="el" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3" title="FLTK library options management.">Fl::option(Fl_Option)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a217dd709bed0d62a652625d505918fc6"></a><!-- doxytag: member="Fl::own_colormap" ref="a217dd709bed0d62a652625d505918fc6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::own_colormap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes FLTK use its own colormap. </p>
<p>This may make FLTK display better and will reduce conflicts with other programs that want lots of colors. However the colors may flash as you move the cursor between windows.</p>
<p>This does nothing if the current visual is not colormapped. </p>

</div>
</div>
<a class="anchor" id="a41a0cf2dd925cc6c4074d32a36fcf98f"></a><!-- doxytag: member="Fl::ready" ref="a41a0cf2dd925cc6c4074d32a36fcf98f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is similar to <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> except this does <em>not</em> call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a> or any callbacks, which is useful if your program is in a state where such callbacks are illegal. </p>
<p>This returns true if <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> would do anything (it will continue to return true until you call <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> or <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a>).</p>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">while</span> (!calculation_done()) {
    calculate();
    <span class="keywordflow">if</span> (<a class="code" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f" title="This is similar to Fl::check() except this does not call Fl::flush() or any callbacks, which is useful if your program is in a state where such callbacks are illegal.">Fl::ready</a>()) {
      do_expensive_cleanup();
      <a class="code" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check</a>();
      <span class="keywordflow">if</span> (user_hit_abort_button()) <span class="keywordflow">break</span>;
    }
  }
</pre></div> 
</div>
</div>
<a class="anchor" id="a656023b0db49ae9b88e277ccdb27ce1b"></a><!-- doxytag: member="Fl::release" ref="a656023b0db49ae9b88e277ccdb27ce1b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases the current grabbed window, equals grab(0). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use Fl::grab(0) instead. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845" title="Selects the window to grab.">grab(Fl_Window*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3cf6b5b7bfe06b268e8c51ec11acf378"></a><!-- doxytag: member="Fl::reload_scheme" ref="a3cf6b5b7bfe06b268e8c51ec11acf378" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::reload_scheme </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by scheme according to scheme name. </p>
<p>Loads or reloads the current scheme selection. See void <a class="el" href="classFl.html#a15a061056c940e811090976cbd733305" title="Gets or sets the current widget scheme.">scheme(const char *name)</a> </p>

</div>
</div>
<a class="anchor" id="a43ee3d6bb1c70f5202e7cc9cb87cd515"></a><!-- doxytag: member="Fl::remove_check" ref="a43ee3d6bb1c70f5202e7cc9cb87cd515" args="(Fl_Timeout_Handler, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::remove_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a check callback. </p>
<p>It is harmless to remove a check callback that no longer exists. </p>

</div>
</div>
<a class="anchor" id="a4254e8bc88b9d4cb3e66152ac4caee86"></a><!-- doxytag: member="Fl::remove_fd" ref="a4254e8bc88b9d4cb3e66152ac4caee86" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::remove_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a file descriptor handler. </p>

</div>
</div>
<a class="anchor" id="a1c7766bf3e45e170fe1741e98092e55f"></a><!-- doxytag: member="Fl::remove_fd" ref="a1c7766bf3e45e170fe1741e98092e55f" args="(int, int when)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::remove_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>when</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a file descriptor handler. </p>

</div>
</div>
<a class="anchor" id="a9a950f0585de6416eb4fee2365a1578f"></a><!-- doxytag: member="Fl::remove_timeout" ref="a9a950f0585de6416eb4fee2365a1578f" args="(Fl_Timeout_Handler, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::remove_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a timeout callback. </p>
<p>It is harmless to remove a timeout callback that no longer exists.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version removes all matching timeouts, not just the first one. This may change in the future. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5373d1d50c2b0ba38280d78bb6d2628"></a><!-- doxytag: member="Fl::repeat_timeout" ref="ae5373d1d50c2b0ba38280d78bb6d2628" args="(double t, Fl_Timeout_Handler, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::repeat_timeout </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gaf00cf21170aa3231f6e869a30a036390">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate timing. </p>
<p>You may only call this method inside a timeout callback.</p>
<p>The following code will print "TICK" each second on stdout with a fair degree of accuracy:</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> callback(<span class="keywordtype">void</span>*) {
       puts(<span class="stringliteral">&quot;TICK&quot;</span>);
       <a class="code" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628" title="Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate ti...">Fl::repeat_timeout</a>(1.0, callback);
     }
  
     <span class="keywordtype">int</span> main() {
       <a class="code" href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52" title="Adds a one-shot timeout callback.">Fl::add_timeout</a>(1.0, callback);
       <span class="keywordflow">return</span> <a class="code" href="classFl.html#a7a3b1236b41800d24267288c564b187a" title="As long as any windows are displayed this calls Fl::wait() repeatedly.">Fl::run</a>();
     }
</pre></div> 
</div>
</div>
<a class="anchor" id="a7a3b1236b41800d24267288c564b187a"></a><!-- doxytag: member="Fl::run" ref="a7a3b1236b41800d24267288c564b187a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>As long as any windows are displayed this calls <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> repeatedly. </p>
<p>When all the windows are closed it returns zero (supposedly it would return non-zero on any errors, but FLTK calls exit directly for these). A normal program will end main() with return <a class="el" href="classFl.html#a7a3b1236b41800d24267288c564b187a" title="As long as any windows are displayed this calls Fl::wait() repeatedly.">Fl::run()</a>;. </p>

</div>
</div>
<a class="anchor" id="a15a061056c940e811090976cbd733305"></a><!-- doxytag: member="Fl::scheme" ref="a15a061056c940e811090976cbd733305" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::scheme </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets or sets the current widget scheme. </p>
<p>NULL will use the scheme defined in the FLTK_SCHEME environment variable or the scheme resource under X11. Otherwise, any of the following schemes can be used:</p>
<ul>
<li>"none" - This is the default look-n-feel which resembles old Windows (95/98/Me/NT/2000) and old GTK/KDE</li>
</ul>
<ul>
<li>"plastic" - This scheme is inspired by the Aqua user interface on Mac OS X</li>
</ul>
<ul>
<li>"gtk+" - This scheme is inspired by the Red Hat Bluecurve theme </li>
</ul>

</div>
</div>
<a class="anchor" id="aa6d2b6e0d640b81c6ec44d0164ec0f91"></a><!-- doxytag: member="Fl::scrollbar_size" ref="aa6d2b6e0d640b81c6ec44d0164ec0f91" args="(int W)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::scrollbar_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the default scrollbar size that is used by the <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers.">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text.">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window...">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget.">Fl_Text_Display</a> widgets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>The new default size for widget scrollbars, in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82c225037f05d07a7797da5eddafb33a"></a><!-- doxytag: member="Fl::scrollbar_size" ref="a82c225037f05d07a7797da5eddafb33a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::scrollbar_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the default scrollbar size used by <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers.">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text.">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window...">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget.">Fl_Text_Display</a> widgets. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The default size for widget scrollbars, in pixels. </dd></dl>

</div>
</div>
<a class="anchor" id="a337397ba0fb948633c83ad7c39a67e00"></a><!-- doxytag: member="Fl::set_boxtype" ref="a337397ba0fb948633c83ad7c39a67e00" args="(Fl_Boxtype, Fl_Boxtype from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::set_boxtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the from boxtype. </p>

</div>
</div>
<a class="anchor" id="a73e0e8fefe8707817ca6fd6437c4869b"></a><!-- doxytag: member="Fl::set_boxtype" ref="a73e0e8fefe8707817ca6fd6437c4869b" args="(Fl_Boxtype, Fl_Box_Draw_F *, uchar, uchar, uchar, uchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::set_boxtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gae409de0010a065c2b325aca0b2d92583">Fl_Box_Draw_F</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the function to call to draw a specific boxtype. </p>

</div>
</div>
<a class="anchor" id="a77955ad2f2b83fc5e3925b94e4533b20"></a><!-- doxytag: member="Fl::set_idle" ref="a77955ad2f2b83fc5e3925b94e4533b20" args="(Fl_Old_Idle_Handler cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::set_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga63ceabf6cd80d8dfcecd1c41184bf9df">Fl_Old_Idle_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an idle callback. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This method is obsolete - use the <a class="el" href="classFl.html#a4e7a1b5d18c2f073238a8466a62a3e7a" title="Adds a callback function that is called every time by Fl::wait() and also makes it act as though the ...">add_idle()</a> method instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a2041799ff3f57f4cced52d7e3b3a544a"></a><!-- doxytag: member="Fl::set_labeltype" ref="a2041799ff3f57f4cced52d7e3b3a544a" args="(Fl_Labeltype, Fl_Label_Draw_F *, Fl_Label_Measure_F *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::set_labeltype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gac4d39eb6338c82c9ebcc6c25f596191d">Fl_Label_Draw_F</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga92c6decef7b9cc6a74dcc66573dd22a0">Fl_Label_Measure_F</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the functions to call to draw and measure a specific labeltype. </p>

</div>
</div>
<a class="anchor" id="ad1633da3e36598ebe875f0c16fc9f198"></a><!-- doxytag: member="Fl::set_labeltype" ref="ad1633da3e36598ebe875f0c16fc9f198" args="(Fl_Labeltype, Fl_Labeltype from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::set_labeltype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the functions to call to draw and measure a specific labeltype. </p>

</div>
</div>
<a class="anchor" id="ad65803adc5e4936111bd31a52f1d61a7"></a><!-- doxytag: member="Fl::version" ref="ad65803adc5e4936111bd31a52f1d61a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Fl::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the compiled-in value of the FL_VERSION constant. </p>
<p>This is useful for checking the version of a shared library. </p>

</div>
</div>
<a class="anchor" id="ade5fd097d36257dce2b7aff1165e037f"></a><!-- doxytag: member="Fl::visible_focus" ref="ade5fd097d36257dce2b7aff1165e037f" args="(int v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::visible_focus </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets or sets the visible keyboard focus on buttons and other non-text widgets. </p>
<p>The default mode is to enable keyboard focus for all widgets. </p>

</div>
</div>
<a class="anchor" id="ae9eaddd02a0aa637078ee2dd80b85b2f"></a><!-- doxytag: member="Fl::visible_focus" ref="ae9eaddd02a0aa637078ee2dd80b85b2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::visible_focus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets or sets the visible keyboard focus on buttons and other non-text widgets. </p>
<p>The default mode is to enable keyboard focus for all widgets. </p>

</div>
</div>
<a class="anchor" id="a6d6deb3d4f76b538d508b36700dfb6b0"></a><!-- doxytag: member="Fl::visual" ref="a6d6deb3d4f76b538d508b36700dfb6b0" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::visual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Selects a visual so that your graphics are drawn correctly. </p>
<p>This is only allowed before you call show() on any windows. This does nothing if the default visual satisfies the capabilities, or if no visual satisfies the capabilities, or on systems that don't have such brain-dead notions.</p>
<p>Only the following combinations do anything useful:</p>
<ul>
<li>
Fl::visual(FL_RGB) <br/>
Full/true color (if there are several depths FLTK chooses the largest). Do this if you use fl_draw_image for much better (non-dithered) output. <br/>
&#160;  </li>
<li>
Fl::visual(FL_RGB8) <br/>
Full color with at least 24 bits of color. FL_RGB will always pick this if available, but if not it will happily return a less-than-24 bit deep visual. This call fails if 24 bits are not available. <br/>
&#160;  </li>
<li>
<a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual</a>(FL_DOUBLE|FL_INDEX) <br/>
Hardware double buffering. Call this if you are going to use <a class="el" href="classFl__Double__Window.html" title="The Fl_Double_Window provides a double-buffered window.">Fl_Double_Window</a>. <br/>
&#160;  </li>
<li>
<a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual</a>(FL_DOUBLE|FL_RGB) </li>
<li>
<a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual</a>(FL_DOUBLE|FL_RGB8) <br/>
Hardware double buffering and full color. </li>
</ul>
<p>This returns true if the system has the capabilities by default or FLTK suceeded in turing them on. Your program will still work even if this returns false (it just won't look as good). </p>

</div>
</div>
<a class="anchor" id="a108a84216f0b3fa1cb0c46ab7449a312"></a><!-- doxytag: member="Fl::wait" ref="a108a84216f0b3fa1cb0c46ab7449a312" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits until "something happens" and then returns. </p>
<p>Call this repeatedly to "run" your program. You can also check what happened each time after this returns, which is quite useful for managing program state.</p>
<p>What this really does is call all idle callbacks, all elapsed timeouts, call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a> to get the screen to update, and then wait some time (zero if there are idle callbacks, the shortest of all pending timeouts, or infinity), for any events from the user or any <a class="el" href="classFl.html#a799b8278326b3c2db15687c43c11aaf6" title="Adds file descriptor fd to listen to.">Fl::add_fd()</a> callbacks. It then handles the events and calls the callbacks and then returns.</p>
<p>The return value of <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> is non-zero if there are any visible windows - this may change in future versions of FLTK.</p>
<p>Fl::wait(time) waits a maximum of <em>time</em> seconds. <em>It can return much sooner if something happens.</em></p>
<p>The return value is positive if an event or fd happens before the time elapsed. It is zero if nothing happens (on Win32 this will only return zero if <em>time</em> is zero). It is negative if an error occurs (this will happen on UNIX if a signal happens). </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a64d41edd7d962116d86a9db810210f7b"></a><!-- doxytag: member="Fl::help" ref="a64d41edd7d962116d86a9db810210f7b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char *const <a class="el" href="classFl.html#a64d41edd7d962116d86a9db810210f7b">Fl::help</a> = helpmsg+13<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Usage string displayed if <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args()</a> detects an invalid argument. </p>
<p>This may be changed to point to customized text at run-time. </p>

</div>
</div>
<a class="anchor" id="a60fb2b446096dd4742511edb459653d3"></a><!-- doxytag: member="Fl::idle" ref="a60fb2b446096dd4742511edb459653d3" args=")()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="classFl.html#a60fb2b446096dd4742511edb459653d3">Fl::idle</a>)()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The currently executing idle callback function: DO NOT USE THIS DIRECTLY! </p>
<p>This is now used as part of a higher level system allowing multiple idle callback functions to be called. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFl.html#a4e7a1b5d18c2f073238a8466a62a3e7a" title="Adds a callback function that is called every time by Fl::wait() and also makes it act as though the ...">add_idle()</a>, <a class="el" href="classFl.html#a43903f998a07e1cca7ba199c8ed25d9b" title="Removes the specified idle callback, if it is installed.">remove_idle()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Fl_8H_source.html">Fl.H</a></li>
<li>Fl.cxx</li>
<li>Fl_abort.cxx</li>
<li>Fl_add_idle.cxx</li>
<li>Fl_arg.cxx</li>
<li><a class="el" href="fl__boxtype_8cxx.html">fl_boxtype.cxx</a></li>
<li><a class="el" href="fl__color_8cxx.html">fl_color.cxx</a></li>
<li>fl_color_mac.cxx</li>
<li>fl_color_win32.cxx</li>
<li><a class="el" href="Fl__compose_8cxx.html">Fl_compose.cxx</a></li>
<li>Fl_display.cxx</li>
<li>fl_dnd_win32.cxx</li>
<li>fl_dnd_x.cxx</li>
<li>Fl_get_key.cxx</li>
<li>Fl_get_key_mac.cxx</li>
<li>Fl_get_key_win32.cxx</li>
<li>Fl_get_system_colors.cxx</li>
<li>Fl_grab.cxx</li>
<li>fl_labeltype.cxx</li>
<li>Fl_lock.cxx</li>
<li>Fl_own_colormap.cxx</li>
<li>fl_set_font.cxx</li>
<li>fl_set_fonts_mac.cxx</li>
<li>fl_set_fonts_win32.cxx</li>
<li>fl_set_fonts_x.cxx</li>
<li>fl_set_fonts_xft.cxx</li>
<li>fl_shortcut.cxx</li>
<li>Fl_visual.cxx</li>
<li>Fl_Widget.cxx</li>
<li>Fl_Window.cxx</li>
<li>gl_start.cxx</li>
<li>screen_xywh.cxx</li>
<li>Fl_Cairo.cxx</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classFl.html">Fl</a>      </li>

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>


</body>
</html>
