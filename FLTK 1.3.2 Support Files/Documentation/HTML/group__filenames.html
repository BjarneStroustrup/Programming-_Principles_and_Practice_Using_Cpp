<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FLTK 1.3.2: File names and URI utility functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__filenames.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">File names and URI utility functions</div>  </div>
</div>
<div class="contents">

<p>File names and URI functions defined in &lt;<a class="el" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga611853809ad3600822556b6c9f5b3232"></a><!-- doxytag: member="filenames::fl_dirent_h_cyclic_include" ref="ga611853809ad3600822556b6c9f5b3232" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>fl_dirent_h_cyclic_include</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29253083ed9918c2f9d532bd5ed89cc3"></a><!-- doxytag: member="filenames::FL_PATH_MAX" ref="ga29253083ed9918c2f9d532bd5ed89cc3" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#ga29253083ed9918c2f9d532bd5ed89cc3">FL_PATH_MAX</a>&#160;&#160;&#160;2048</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">all path buffers should use this length <br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#ga8be6b0be30bd3174de4b682e4e38eaf5">Fl_File_Sort_F</a> )(struct dirent **, struct dirent **)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">File sorting function.  <a href="#ga8be6b0be30bd3174de4b682e4e38eaf5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#ga89432eb02e305deede59a43f4ecf83c9">fl_decode_uri</a> (char *uri)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a URL-encoded string.  <a href="#ga89432eb02e305deede59a43f4ecf83c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#ga501ffe4287dfd36c8cb56a42c9c4b34c">fl_filename_absolute</a> (char *to, int tolen, const char *from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a filename absolute from a relative filename.  <a href="#ga501ffe4287dfd36c8cb56a42c9c4b34c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#gabf6091d3cad1ec774ba8d2608994be6c">fl_filename_expand</a> (char *to, int tolen, const char *from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands a filename containing shell variables and tilde (~).  <a href="#gabf6091d3cad1ec774ba8d2608994be6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#gaccd45892153d060516a1571335e60a2a">fl_filename_ext</a> (const char *buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the extensions of a filename.  <a href="#gaccd45892153d060516a1571335e60a2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#gadf310cfdff3e566a7be46f70c66b8c48">fl_filename_free_list</a> (struct dirent ***l, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the list of filenames that is generated by <a class="el" href="group__filenames.html#ga41cd95eb5e898b83d184926e05ad4094" title="Portable and const-correct wrapper for the scandir() function.">fl_filename_list()</a>.  <a href="#gadf310cfdff3e566a7be46f70c66b8c48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#gaf8e5802ecf4af833172c20dd8d22b0e3">fl_filename_isdir</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a file exists and is a directory from its filename.  <a href="#gaf8e5802ecf4af833172c20dd8d22b0e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#ga41cd95eb5e898b83d184926e05ad4094">fl_filename_list</a> (const char *d, struct dirent ***l, <a class="el" href="group__filenames.html#ga8be6b0be30bd3174de4b682e4e38eaf5">Fl_File_Sort_F</a> *s=fl_numericsort)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable and const-correct wrapper for the scandir() function.  <a href="#ga41cd95eb5e898b83d184926e05ad4094"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#gac4b44c55216afb84a7a9e75bd8b65793">fl_filename_match</a> (const char *name, const char *pattern)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a string <code>s</code> matches a pattern <code>p</code>.  <a href="#gac4b44c55216afb84a7a9e75bd8b65793"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#ga0ac0f44a1709c6ff94f56a8954dc8fd6">fl_filename_name</a> (const char *filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file name from a path.  <a href="#ga0ac0f44a1709c6ff94f56a8954dc8fd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#gaf0cfb5d9ee6743caf9ede70032bd2a9b">fl_filename_relative</a> (char *to, int tolen, const char *from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a filename relative to the current working directory.  <a href="#gaf0cfb5d9ee6743caf9ede70032bd2a9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#ga957325ab216ec3290693a737ac8881a3">fl_filename_setext</a> (char *to, int tolen, const char *ext)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the extension in <code>buf</code> of max.  <a href="#ga957325ab216ec3290693a737ac8881a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filenames.html#gaa703a16e265f609bedbaf0930dbcd0d7">fl_open_uri</a> (const char *uri, char *msg, int msglen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the specified Uniform Resource Identifier (URI).  <a href="#gaa703a16e265f609bedbaf0930dbcd0d7"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>File names and URI functions defined in &lt;<a class="el" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt; </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga8be6b0be30bd3174de4b682e4e38eaf5"></a><!-- doxytag: member="filename.H::Fl_File_Sort_F" ref="ga8be6b0be30bd3174de4b682e4e38eaf5" args=")(struct dirent **, struct dirent **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int( <a class="el" href="group__filenames.html#ga8be6b0be30bd3174de4b682e4e38eaf5">Fl_File_Sort_F</a>)(struct dirent **, struct dirent **)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>File sorting function. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__filenames.html#ga41cd95eb5e898b83d184926e05ad4094" title="Portable and const-correct wrapper for the scandir() function.">fl_filename_list()</a> </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga89432eb02e305deede59a43f4ecf83c9"></a><!-- doxytag: member="filename.H::fl_decode_uri" ref="ga89432eb02e305deede59a43f4ecf83c9" args="(char *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_decode_uri </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decodes a URL-encoded string. </p>
<p>In a Uniform Resource Identifier (URI), all non-ASCII bytes and several others (e.g., '&lt;', '%', ' ') are URL-encoded using 3 bytes by "%XY" where XY is the hexadecimal value of the byte. This function decodes the URI restoring its original UTF-8 encoded content. Decoding is done in-place. </p>

</div>
</div>
<a class="anchor" id="ga501ffe4287dfd36c8cb56a42c9c4b34c"></a><!-- doxytag: member="filename.H::fl_filename_absolute" ref="ga501ffe4287dfd36c8cb56a42c9c4b34c" args="(char *to, int tolen, const char *from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT int fl_filename_absolute </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tolen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes a filename absolute from a relative filename. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
    [..]
    chdir(<span class="stringliteral">&quot;/var/tmp&quot;</span>);
    <a class="code" href="group__filenames.html#ga501ffe4287dfd36c8cb56a42c9c4b34c" title="Makes a filename absolute from a relative filename.">fl_filename_absolute</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;foo.txt&quot;</span>);         <span class="comment">// out=&quot;/var/tmp/foo.txt&quot;</span>
    <a class="code" href="group__filenames.html#ga501ffe4287dfd36c8cb56a42c9c4b34c" title="Makes a filename absolute from a relative filename.">fl_filename_absolute</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;./foo.txt&quot;</span>);       <span class="comment">// out=&quot;/var/tmp/foo.txt&quot;</span>
    <a class="code" href="group__filenames.html#ga501ffe4287dfd36c8cb56a42c9c4b34c" title="Makes a filename absolute from a relative filename.">fl_filename_absolute</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;../log/messages&quot;</span>); <span class="comment">// out=&quot;/var/log/messages&quot;</span>
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td>resulting absolute filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolen</td><td>size of the absolute filename buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>relative filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no change, non zero otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gabf6091d3cad1ec774ba8d2608994be6c"></a><!-- doxytag: member="filename.H::fl_filename_expand" ref="gabf6091d3cad1ec774ba8d2608994be6c" args="(char *to, int tolen, const char *from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT int fl_filename_expand </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tolen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands a filename containing shell variables and tilde (~). </p>
<p>Currently handles these variants: </p>
<div class="fragment"><pre class="fragment">    <span class="stringliteral">&quot;~username&quot;</span>               <span class="comment">// if &#39;username&#39; does not exist, result will be unchanged</span>
    <span class="stringliteral">&quot;~/file&quot;</span>
    <span class="stringliteral">&quot;$VARNAME&quot;</span>                <span class="comment">// does NOT handle ${VARNAME}</span>
</pre></div><p><b>Examples:</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
    [..]
    putenv(<span class="stringliteral">&quot;TMPDIR=/var/tmp&quot;</span>);
    <a class="code" href="group__filenames.html#gabf6091d3cad1ec774ba8d2608994be6c" title="Expands a filename containing shell variables and tilde (~).">fl_filename_expand</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;~fred/.cshrc&quot;</span>);     <span class="comment">// out=&quot;/usr/fred/.cshrc&quot;</span>
    <a class="code" href="group__filenames.html#gabf6091d3cad1ec774ba8d2608994be6c" title="Expands a filename containing shell variables and tilde (~).">fl_filename_expand</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;~/.cshrc&quot;</span>);         <span class="comment">// out=&quot;/usr/&lt;yourname&gt;/.cshrc&quot;</span>
    <a class="code" href="group__filenames.html#gabf6091d3cad1ec774ba8d2608994be6c" title="Expands a filename containing shell variables and tilde (~).">fl_filename_expand</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;$TMPDIR/foo.txt&quot;</span>);  <span class="comment">// out=&quot;/var/tmp/foo.txt&quot;</span>
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td>resulting expanded filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolen</td><td>size of the expanded filename buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>filename containing shell variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no change, non zero otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gaccd45892153d060516a1571335e60a2a"></a><!-- doxytag: member="filename.H::fl_filename_ext" ref="gaccd45892153d060516a1571335e60a2a" args="(const char *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT const char* fl_filename_ext </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the extensions of a filename. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
   [..]
   <span class="keyword">const</span> <span class="keywordtype">char</span> *out;
   out = <a class="code" href="group__filenames.html#gaccd45892153d060516a1571335e60a2a" title="Gets the extensions of a filename.">fl_filename_ext</a>(<span class="stringliteral">&quot;/some/path/foo.txt&quot;</span>);        <span class="comment">// result: &quot;.txt&quot;</span>
   out = <a class="code" href="group__filenames.html#gaccd45892153d060516a1571335e60a2a" title="Gets the extensions of a filename.">fl_filename_ext</a>(<span class="stringliteral">&quot;/some/path/foo&quot;</span>);            <span class="comment">// result: NULL</span>
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the filename to be parsed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the extension (including '.') if any or NULL otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gadf310cfdff3e566a7be46f70c66b8c48"></a><!-- doxytag: member="filename.H::fl_filename_free_list" ref="gadf310cfdff3e566a7be46f70c66b8c48" args="(struct dirent ***l, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT void fl_filename_free_list </td>
          <td>(</td>
          <td class="paramtype">struct dirent ***&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the list of filenames that is generated by <a class="el" href="group__filenames.html#ga41cd95eb5e898b83d184926e05ad4094" title="Portable and const-correct wrapper for the scandir() function.">fl_filename_list()</a>. </p>
<p>Free everything that was allocated by a previous call to <a class="el" href="group__filenames.html#ga41cd95eb5e898b83d184926e05ad4094" title="Portable and const-correct wrapper for the scandir() function.">fl_filename_list()</a>. Use the return values as parameters for this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>table containing the resulting directory listing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of entries in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf8e5802ecf4af833172c20dd8d22b0e3"></a><!-- doxytag: member="filename.H::fl_filename_isdir" ref="gaf8e5802ecf4af833172c20dd8d22b0e3" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT int fl_filename_isdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if a file exists and is a directory from its filename. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
   [..]
   <a class="code" href="group__filenames.html#gaf8e5802ecf4af833172c20dd8d22b0e3" title="Determines if a file exists and is a directory from its filename.">fl_filename_isdir</a>(<span class="stringliteral">&quot;/etc&quot;</span>);           <span class="comment">// returns non-zero</span>
   <a class="code" href="group__filenames.html#gaf8e5802ecf4af833172c20dd8d22b0e3" title="Determines if a file exists and is a directory from its filename.">fl_filename_isdir</a>(<span class="stringliteral">&quot;/etc/hosts&quot;</span>);     <span class="comment">// returns 0</span>
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the filename to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero if file exists and is a directory, zero otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga41cd95eb5e898b83d184926e05ad4094"></a><!-- doxytag: member="filename.H::fl_filename_list" ref="ga41cd95eb5e898b83d184926e05ad4094" args="(const char *d, struct dirent ***l, Fl_File_Sort_F *s=fl_numericsort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT int fl_filename_list </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dirent ***&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__filenames.html#ga8be6b0be30bd3174de4b682e4e38eaf5">Fl_File_Sort_F</a> *&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Portable and const-correct wrapper for the scandir() function. </p>
<p>For each file in that directory a "dirent" structure is created. The only portable thing about a dirent is that dirent.d_name is the nul-terminated file name. An pointers array to these dirent's is created and a pointer to the array is returned in *list. The number of entries is given as a return value. If there is an error reading the directory a number less than zero is returned, and errno has the reason; errno does not work under WIN32.</p>
<p><b>Include:</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>the name of the directory to list. It does not matter if it has a trailing slash. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">list</td><td>table containing the resulting directory listing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sort</td><td>sorting functor:<ul>
<li>fl_alphasort: The files are sorted in ascending alphabetical order; upper and lowercase letters are compared according to their ASCII ordering uppercase before lowercase.</li>
<li>fl_casealphasort: The files are sorted in ascending alphabetical order; upper and lowercase letters are compared equally case is not significant.</li>
<li>fl_casenumericsort: The files are sorted in ascending "alphanumeric" order, where an attempt is made to put unpadded numbers in consecutive order; upper and lowercase letters are compared equally case is not significant.</li>
<li>fl_numericsort: The files are sorted in ascending "alphanumeric" order, where an attempt is made to put unpadded numbers in consecutive order; upper and lowercase letters are compared according to their ASCII ordering - uppercase before lowercase. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of entries if no error, a negative value otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4b44c55216afb84a7a9e75bd8b65793"></a><!-- doxytag: member="filename.H::fl_filename_match" ref="gac4b44c55216afb84a7a9e75bd8b65793" args="(const char *name, const char *pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT int fl_filename_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a string <code>s</code> matches a pattern <code>p</code>. </p>
<p>The following syntax is used for the pattern:</p>
<ul>
<li>* matches any sequence of 0 or more characters.</li>
<li>? matches any single character.</li>
<li>[set] matches any character in the set. Set can contain any single characters, or a-z to represent a range. To match ] or - they must be the first characters. To match ^ or ! they must not be the first characters.</li>
<li>[^set] or [!set] matches any character not in the set.</li>
<li>{X|Y|Z} or {X,Y,Z} matches any one of the subexpressions literally.</li>
<li>\x quotes the character x so it has no special meaning.</li>
<li>x all other characters must be matched exactly.</li>
</ul>
<p><b>Include:</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>the string to check for a match </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the string pattern </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero if the string matches the pattern </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ac0f44a1709c6ff94f56a8954dc8fd6"></a><!-- doxytag: member="filename.H::fl_filename_name" ref="ga0ac0f44a1709c6ff94f56a8954dc8fd6" args="(const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT const char* fl_filename_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the file name from a path. </p>
<p>Similar to basename(3), exceptions shown below. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
    [..]
    <span class="keyword">const</span> <span class="keywordtype">char</span> *out;
    out = <a class="code" href="group__filenames.html#ga0ac0f44a1709c6ff94f56a8954dc8fd6" title="Gets the file name from a path.">fl_filename_name</a>(<span class="stringliteral">&quot;/usr/lib&quot;</span>);     <span class="comment">// out=&quot;lib&quot;</span>
    out = <a class="code" href="group__filenames.html#ga0ac0f44a1709c6ff94f56a8954dc8fd6" title="Gets the file name from a path.">fl_filename_name</a>(<span class="stringliteral">&quot;/usr/&quot;</span>);        <span class="comment">// out=&quot;&quot;      (basename(3) returns &quot;usr&quot; instead)</span>
    out = <a class="code" href="group__filenames.html#ga0ac0f44a1709c6ff94f56a8954dc8fd6" title="Gets the file name from a path.">fl_filename_name</a>(<span class="stringliteral">&quot;/usr&quot;</span>);         <span class="comment">// out=&quot;usr&quot;</span>
    out = <a class="code" href="group__filenames.html#ga0ac0f44a1709c6ff94f56a8954dc8fd6" title="Gets the file name from a path.">fl_filename_name</a>(<span class="stringliteral">&quot;/&quot;</span>);            <span class="comment">// out=&quot;&quot;      (basename(3) returns &quot;/&quot; instead)</span>
    out = <a class="code" href="group__filenames.html#ga0ac0f44a1709c6ff94f56a8954dc8fd6" title="Gets the file name from a path.">fl_filename_name</a>(<span class="stringliteral">&quot;.&quot;</span>);            <span class="comment">// out=&quot;.&quot;</span>
    out = <a class="code" href="group__filenames.html#ga0ac0f44a1709c6ff94f56a8954dc8fd6" title="Gets the file name from a path.">fl_filename_name</a>(<span class="stringliteral">&quot;..&quot;</span>);           <span class="comment">// out=&quot;..&quot;</span>
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the char after the last slash, or to <code>filename</code> if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0cfb5d9ee6743caf9ede70032bd2a9b"></a><!-- doxytag: member="filename.H::fl_filename_relative" ref="gaf0cfb5d9ee6743caf9ede70032bd2a9b" args="(char *to, int tolen, const char *from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT int fl_filename_relative </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tolen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes a filename relative to the current working directory. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
    [..]
    chdir(<span class="stringliteral">&quot;/var/tmp/somedir&quot;</span>);       <span class="comment">// set cwd to /var/tmp/somedir</span>
    [..]
    <span class="keywordtype">char</span> out[<a class="code" href="group__filenames.html#ga29253083ed9918c2f9d532bd5ed89cc3" title="all path buffers should use this length">FL_PATH_MAX</a>];
    <a class="code" href="group__filenames.html#gaf0cfb5d9ee6743caf9ede70032bd2a9b" title="Makes a filename relative to the current working directory.">fl_filename_relative</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;/var/tmp/somedir/foo.txt&quot;</span>);  <span class="comment">// out=&quot;foo.txt&quot;,    return=1</span>
    <a class="code" href="group__filenames.html#gaf0cfb5d9ee6743caf9ede70032bd2a9b" title="Makes a filename relative to the current working directory.">fl_filename_relative</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;/var/tmp/foo.txt&quot;</span>);          <span class="comment">// out=&quot;../foo.txt&quot;, return=1</span>
    <a class="code" href="group__filenames.html#gaf0cfb5d9ee6743caf9ede70032bd2a9b" title="Makes a filename relative to the current working directory.">fl_filename_relative</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;foo.txt&quot;</span>);                   <span class="comment">// out=&quot;foo.txt&quot;,    return=0 (no change)</span>
    <a class="code" href="group__filenames.html#gaf0cfb5d9ee6743caf9ede70032bd2a9b" title="Makes a filename relative to the current working directory.">fl_filename_relative</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;./foo.txt&quot;</span>);                 <span class="comment">// out=&quot;./foo.txt&quot;,  return=0 (no change)</span>
    <a class="code" href="group__filenames.html#gaf0cfb5d9ee6743caf9ede70032bd2a9b" title="Makes a filename relative to the current working directory.">fl_filename_relative</a>(out, <span class="keyword">sizeof</span>(out), <span class="stringliteral">&quot;../foo.txt&quot;</span>);                <span class="comment">// out=&quot;../foo.txt&quot;, return=0 (no change)</span>
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td>resulting relative filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolen</td><td>size of the relative filename buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>absolute filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no change, non zero otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga957325ab216ec3290693a737ac8881a3"></a><!-- doxytag: member="filename.H::fl_filename_setext" ref="ga957325ab216ec3290693a737ac8881a3" args="(char *to, int tolen, const char *ext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FL_EXPORT char* fl_filename_setext </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the extension in <code>buf</code> of max. </p>
<p><br/>
 size <code>buflen</code> with the extension in <code>ext</code>.<br/>
 If there's no '.' in <code>buf</code>, <code>ext</code> is appended.<br/>
 If <code>ext</code> is NULL, behaves as if it were an empty string ("").</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
   [..]
   <span class="keywordtype">char</span> buf[<a class="code" href="group__filenames.html#ga29253083ed9918c2f9d532bd5ed89cc3" title="all path buffers should use this length">FL_PATH_MAX</a>] = <span class="stringliteral">&quot;/path/myfile.cxx&quot;</span>;
   <a class="code" href="group__filenames.html#ga957325ab216ec3290693a737ac8881a3" title="Replaces the extension in buf of max.">fl_filename_setext</a>(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;.txt&quot;</span>);      <span class="comment">// buf[] becomes &quot;/path/myfile.txt&quot;</span>
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>buf itself for calling convenience. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa703a16e265f609bedbaf0930dbcd0d7"></a><!-- doxytag: member="filename.H::fl_open_uri" ref="gaa703a16e265f609bedbaf0930dbcd0d7" args="(const char *uri, char *msg, int msglen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_open_uri </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msglen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens the specified Uniform Resource Identifier (URI). </p>
<p>Uses an operating-system dependent program or interface. For URIs using the "ftp", "http", or "https" schemes, the system default web browser is used to open the URI, while "mailto" and "news" URIs are typically opened using the system default mail reader and "file" URIs are opened using the file system navigator.</p>
<p>On success, the (optional) msg buffer is filled with the command that was run to open the URI; on Windows, this will always be "open uri".</p>
<p>On failure, the msg buffer is filled with an English error message.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="filename_8H.html" title="File names and URI utility functions.">FL/filename.H</a>&gt;</span>
 [..]
 <span class="keywordtype">char</span> errmsg[512];
 <span class="keywordflow">if</span> ( !<a class="code" href="group__filenames.html#gaa703a16e265f609bedbaf0930dbcd0d7" title="Opens the specified Uniform Resource Identifier (URI).">fl_open_uri</a>(<span class="stringliteral">&quot;http://google.com/&quot;</span>, errmsg, <span class="keyword">sizeof</span>(errmsg)) ) {
     <span class="keywordtype">char</span> warnmsg[768];
     sprintf(warnmsg, <span class="stringliteral">&quot;Error: %s&quot;</span>, errmsg);
     <a class="code" href="group__group__comdlg.html#gae998e9cd38954bfde24bd20e550e9b8a" title="Shows an alert message dialog box.">fl_alert</a>(warnmsg);
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The URI to open </td></tr>
    <tr><td class="paramname">msg</td><td>Optional buffer which contains the command or error message </td></tr>
    <tr><td class="paramname">msglen</td><td>Length of optional buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>


</body>
</html>
