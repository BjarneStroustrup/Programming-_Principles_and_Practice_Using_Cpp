<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FLTK 1.3.2: Unicode and UTF-8 Support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('unicode.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Unicode and UTF-8 Support </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>This chapter explains how FLTK handles international text via Unicode and UTF-8.</p>
<p>Unicode support was only recently added to FLTK and is still incomplete. This chapter is Work in Progress, reflecting the current state of Unicode support.</p>
<h2><a class="anchor" id="unicode_about"></a>
About Unicode, ISO 10646 and UTF-8</h2>
<p>The summary of Unicode, ISO 10646 and UTF-8 given below is deliberately brief, and provides just enough information for the rest of this chapter. For further information, please see:</p>
<ul>
<li><a href="http://www.unicode.org">http://www.unicode.org</a></li>
<li><a href="http://www.iso.org">http://www.iso.org</a></li>
<li><a href="http://en.wikipedia.org/wiki/Unicode">http://en.wikipedia.org/wiki/Unicode</a></li>
<li><a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html">http://www.cl.cam.ac.uk/~mgk25/unicode.html</a></li>
<li><a href="http://www.apps.ietf.org/rfc/rfc3629.html">http://www.apps.ietf.org/rfc/rfc3629.html</a></li>
</ul>
<dl class="user"><dt><b>The Unicode Standard</b></dt><dd></dd></dl>
<p>The Unicode Standard was originally developed by a consortium of mainly US computer manufacturers and developers of multi-lingual software. It has now become a defacto standard for character encoding, and is supported by most of the major computing companies in the world.</p>
<p>Before Unicode, many different systems, on different platforms, had been developed for encoding characters for different languages, but no single encoding could satisfy all languages. Unicode provides access to over 100,000 characters used in all the major languages written today, and is independent of platform and language.</p>
<p>Unicode also provides higher-level concepts needed for text processing and typographic publishing systems, such as algorithms for sorting and comparing text, composite character and text rendering, right-to-left and bi-directional text handling.</p>
<p><em>There are currently no plans to add this extra functionality to FLTK.</em></p>
<dl class="user"><dt><b>ISO 10646</b></dt><dd></dd></dl>
<p>The International Organisation for Standardization (ISO) had also been trying to develop a single unified character set. Although both ISO and the Unicode Consortium continue to publish their own standards, they have agreed to coordinate their work so that specific versions of the Unicode and ISO 10646 standards are compatible with each other.</p>
<p>The international standard ISO 10646 defines the <b>Universal Character Set</b> (UCS) which contains the characters required for almost all known languages. The standard also defines three different implementation levels specifying how these characters can be combined.</p>
<p><em>There are currently no plans for handling the different implementation levels or the combining characters in FLTK.</em></p>
<p>In UCS, characters have a unique numerical code and an official name, and are usually shown using 'U+' and the code in hexadecimal, e.g. U+0041 is the "Latin capital letter A". The UCS characters U+0000 to U+007F correspond to US-ASCII, and U+0000 to U+00FF correspond to ISO 8859-1 (Latin1).</p>
<p>ISO 10646 was originally designed to handle a 31-bit character set from U+00000000 to U+7FFFFFFF, but the current idea is that 21-bits will be sufficient for all future needs, giving characters up to U+10FFFF. The complete character set is sub-divided into <em>planes</em>. <em>Plane 0</em>, also known as the <b>Basic Multilingual Plane</b> (BMP), ranges from U+0000 to U+FFFD and consists of the most commonly used characters from previous encoding standards. Other planes contain characters for specialist applications. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Do we need this info about planes?</dd></dl>
<p>The UCS also defines various methods of encoding characters as a sequence of bytes. UCS-2 encodes Unicode characters into two bytes, which is wasteful if you are only dealing with ASCII or Latin1 text, and insufficient if you need characters above U+00FFFF. UCS-4 uses four bytes, which lets it handle higher characters, but this is even more wasteful for ASCII or Latin1.</p>
<dl class="user"><dt><b>UTF-8</b></dt><dd></dd></dl>
<p>The Unicode standard defines various UCS Transformation Formats. UTF-16 and UTF-32 are based on units of two and four bytes. UCS characters requiring more than 16-bits are encoded using "surrogate pairs" in UTF-16.</p>
<p>UTF-8 encodes all Unicode characters into variable length sequences of bytes. Unicode characters in the 7-bit ASCII range map to the same value and are represented as a single byte, making the transformation to Unicode quick and easy.</p>
<p>All UCS characters above U+007F are encoded as a sequence of several bytes. The top bits of the first byte are set to show the length of the byte sequence, and subseqent bytes are always in the range 0x80 to 0x8F. This combination provides some level of synchronisation and error detection.</p>
<table  summary="Unicode character byte sequences" align="center">
<tr>
<td>Unicode range </td><td>Byte sequences  </td></tr>
<tr>
<td><code>U+00000000 - U+0000007F</code> </td><td><code>0xxxxxxx</code>  </td></tr>
<tr>
<td><code>U+00000080 - U+000007FF</code> </td><td><code>110xxxxx 10xxxxxx</code>  </td></tr>
<tr>
<td><code>U+00000800 - U+0000FFFF</code> </td><td><code>1110xxxx 10xxxxxx 10xxxxxx</code>  </td></tr>
<tr>
<td><code>U+00010000 - U+001FFFFF</code> </td><td><code>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code>  </td></tr>
<tr>
<td><code>U+00200000 - U+03FFFFFF</code> </td><td><code>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</code>  </td></tr>
<tr>
<td><code>U+04000000 - U+7FFFFFFF</code> </td><td><code>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</code>  </td></tr>
</table>
<p>Moving from ASCII encoding to Unicode will allow all new FLTK applications to be easily internationalized and used all over the world. By choosing UTF-8 encoding, FLTK remains largely source-code compatible to previous iteration of the library.</p>
<h2><a class="anchor" id="unicode_in_fltk"></a>
Unicode in FLTK</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Work through the code and this documentation to harmonize the [<b>OksiD</b>] and [<b>fltk2</b>] functions.</dd></dl>
<p>FLTK will be entirely converted to Unicode using UTF-8 encoding. If a different encoding is required by the underlying operating system, FLTK will convert the string as needed.</p>
<p>It is important to note that the initial implementation of Unicode and UTF-8 in FLTK involves three important areas:</p>
<ul>
<li>provision of Unicode character tables and some simple related functions;</li>
</ul>
<ul>
<li>conversion of char* variables and function parameters from single byte per character representation to UTF-8 variable length sequences;</li>
</ul>
<ul>
<li>modifications to the display font interface to accept general Unicode character or UCS code numbers instead of just ASCII or Latin1 characters.</li>
</ul>
<p>The current implementation of Unicode / UTF-8 in FLTK will impose the following limitations:</p>
<ul>
<li>An implementation note in the [<b>OksiD</b>] code says that all functions are LIMITED to 24 bit Unicode values, but also says that only 16 bits are really used under linux and win32. <b>[Can we verify this?]</b></li>
</ul>
<ul>
<li>The [<b>fltk2</b>] fl_utf8encode() and fl_utf8decode() functions are designed to handle Unicode characters in the range U+000000 to U+10FFFF inclusive, which covers all UTF-16 characters, as specified in RFC 3629. <em>Note that the user must first convert UTF-16 surrogate pairs to UCS.</em></li>
</ul>
<ul>
<li>FLTK will only handle single characters, so composed characters consisting of a base character and floating accent characters will be treated as multiple characters;</li>
</ul>
<ul>
<li>FLTK will only compare or sort strings on a byte by byte basis and not on a general Unicode character basis;</li>
</ul>
<ul>
<li>FLTK will not handle right-to-left or bi-directional text;</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Verify 16/24 bit Unicode limit for different character sets? OksiD's code appears limited to 16-bit whereas the FLTK2 code appears to handle a wider set. What about illegal characters? See comments in fl_utf8fromwc() and fl_utf8toUtf16().</dd></dl>
<h2><a class="anchor" id="unicode_illegals"></a>
Illegal Unicode and UTF-8 sequences</h2>
<p>Three pre-processor variables are defined in the source code that determine how fl_utf8decode() handles illegal UTF-8 sequences:</p>
<ul>
<li>if ERRORS_TO_CP1252 is set to 1 (the default), fl_utf8decode() will assume that a byte sequence starting with a byte in the range 0x80 to 0x9f represents a Microsoft CP1252 character, and will instead return the value of an equivalent UCS character. Otherwise, it will be processed as an illegal byte value as described below.</li>
</ul>
<ul>
<li>if STRICT_RFC3629 is set to 1 (not the default!) then UTF-8 sequences that correspond to illegal UCS values are treated as errors. Illegal UCS values include those above U+10FFFF, or corresponding to UTF-16 surrogate pairs. Illegal byte values are handled as described below.</li>
</ul>
<ul>
<li>if ERRORS_TO_ISO8859_1 is set to 1 (the default), the illegal byte value is returned unchanged, otherwise 0xFFFD, the Unicode REPLACEMENT CHARACTER, is returned instead.</li>
</ul>
<p>fl_utf8encode() is less strict, and only generates the UTF-8 sequence for 0xFFFD, the Unicode REPLACEMENT CHARACTER, if it is asked to encode a UCS value above U+10FFFF.</p>
<p>Many of the [<b>fltk2</b>] functions below use fl_utf8decode() and fl_utf8encode() in their own implementation, and are therefore somewhat protected from bad UTF-8 sequences.</p>
<p>The [<b>OksiD</b>] fl_utf8len() function assumes that the byte it is passed is the first byte in a UTF-8 sequence, and returns the length of the sequence. Trailing bytes in a UTF-8 sequence will return -1.</p>
<ul>
<li><b>WARNING:</b> fl_utf8len() can not distinguish between single bytes representing Microsoft CP1252 characters 0x80-0x9f and those forming part of a valid UTF-8 sequence. You are strongly advised not to use fl_utf8len() in your own code unless you know that the byte sequence contains only valid UTF-8 sequences.</li>
</ul>
<ul>
<li><b>WARNING:</b> Some of the [OksiD] functions below use still use fl_utf8len() in their implementations. These may need further validation.</li>
</ul>
<p>Please see the individual function description for further details about error handling and return values.</p>
<h2><a class="anchor" id="unicode_fltk_calls"></a>
FLTK Unicode and UTF-8 functions</h2>
<p>This section currently provides a brief overview of the functions. For more details, consult the main text for each function via its link.</p>
<p>int <a class="el" href="group__fl__unicode.html#gad26770d13761b82a68c5bcc5f9de196b">fl_utf8locale()</a> <b>FLTK2</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd><code>fl_utf8locale</code>() returns true if the "locale" seems to indicate that UTF-8 encoding is used. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>It is highly recommended that your change your system so this does return true!</em></dd></dl>
<p>int <a class="el" href="group__fl__unicode.html#ga9db7a23fb75a6a76d3118704806918ea">fl_utf8test(const char *src, unsigned len)</a> <b>FLTK2</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd><code>fl_utf8test</code>() examines the first <code>len</code> bytes of <code>src</code>. It returns 0 if there are any illegal UTF-8 sequences; 1 if <code>src</code> contains plain ASCII or if <code>len</code> is zero; or 2, 3 or 4 to indicate the range of Unicode characters found.</dd></dl>
<p>int <a class="el" href="group__fl__unicode.html#gaff5ccdf22c2cb46125cc9a152542e63b" title="returns the number of Unicode chars in the UTF-8 string">fl_utf_nb_char(const unsigned char *buf, int len)</a> <b>OksiD</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd>Returns the number of UTF-8 character in the first <code>len</code> bytes of <code>buf</code>.</dd></dl>
<p>int fl_unichar_to_utf8_size(Fl_Unichar) <br/>
 int <a class="el" href="group__fl__unicode.html#ga3e25d5c315ce7f0acf87c3662e331468" title="Return the number of bytes needed to encode the given UCS4 character in UTF8.">fl_utf8bytes(unsigned ucs)</a> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd>Returns the number of bytes needed to encode <code>ucs</code> in UTF-8.</dd></dl>
<p>int <a class="el" href="group__fl__unicode.html#ga3eedf721bef934868002eb94d247d834" title="return the byte length of the UTF-8 sequence with first byte c, or -1 if c is not valid...">fl_utf8len(char c)</a> <b>OksiD</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd>If <code>c</code> is a valid first byte of a UTF-8 encoded character sequence, <code>fl_utf8len</code>() will return the number of bytes in that sequence. It returns -1 if <code>c</code> is not a valid first byte.</dd></dl>
<p>unsigned int <a class="el" href="group__fl__unicode.html#ga75d310d956bedf6129c5ef6c1e868a8f" title="returns true if the character is non-spacing.">fl_nonspacing(unsigned int ucs)</a> <b>OksiD</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd>Returns true if <code>ucs</code> is a non-spacing character. <b>[What are non-spacing characters?]</b></dd></dl>
<p>const char* <a class="el" href="group__fl__unicode.html#gad28ab9ec404eed36008de0ddcf95db0f">fl_utf8back(const char *p, const char *start, const char *end)</a> <b>FLTK2</b> <br/>
 const char* <a class="el" href="group__fl__unicode.html#ga881af6d9537e0aadb1ab7ab3f35bd3bc">fl_utf8fwd(const char *p, const char *start, const char *end)</a> <b>FLTK2</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd>If <code>p</code> already points to the start of a UTF-8 character sequence, these functions will return <code>p</code>. Otherwise <code>fl_utf8back</code>() searches backwards from <code>p</code> and <code>fl_utf8fwd</code>() searches forwards from <code>p</code>, within the <code>start</code> and <code>end</code> limits, looking for the start of a UTF-8 character.</dd></dl>
<p>unsigned int <a class="el" href="group__fl__unicode.html#gad80ac8abaa3ed7b8c245447d6b3aab95">fl_utf8decode(const char *p, const char *end, int *len)</a> <b>FLTK2</b> <br/>
 int <a class="el" href="group__fl__unicode.html#gae608a28bc43f10014343483ed3d5e99c">fl_utf8encode(unsigned ucs, char *buf)</a> <b>FLTK2</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd><code>fl_utf8decode</code>() attempts to decode the UTF-8 character that starts at <code>p</code> and may not extend past <code>end</code>. It returns the Unicode value, and the length of the UTF-8 character sequence is returned via the <code>len</code> argument. <code>fl_utf8encode</code>() writes the UTF-8 encoding of <code>ucs</code> into <code>buf</code> and returns the number of bytes in the sequence. See the main documentation for the treatment of illegal Unicode and UTF-8 sequences.</dd></dl>
<p>unsigned int <a class="el" href="group__fl__unicode.html#gae652006e11dcea72e9ae23e8fb606ff1">fl_utf8froma(char *dst, unsigned dstlen, const char *src, unsigned srclen)</a> <b>FLTK2</b> <br/>
 unsigned int <a class="el" href="group__fl__unicode.html#ga12eec84f8d118aac87eaabaedfcd4154">fl_utf8toa(const char *src, unsigned srclen, char *dst, unsigned dstlen)</a> <b>FLTK2</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd><code>fl_utf8froma</code>() converts a character string containing single bytes per character (i.e. ASCII or ISO-8859-1) into UTF-8. If the <code>src</code> string contains only ASCII characters, the return value will be the same as <code>srclen</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>fl_utf8toa</code>() converts a string containing UTF-8 characters into single byte characters. UTF-8 characters do not correspond to ASCII or ISO-8859-1 characters below 0xFF are replaced with '?'.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Both functions return the number of bytes that would be written, not counting the null terminator. <code>destlen</code> provides a means of limiting the number of bytes written, so setting <code>destlen</code> to zero is a means of measuring how much storage would be needed before doing the real conversion.</dd></dl>
<p>char* <a class="el" href="group__fl__unicode.html#ga8d5e4047416055e55c5b6b9d0e78a8fd" title="converts UTF8 to a local multi-byte character string.">fl_utf2mbcs(const char *src)</a> <b>OksiD</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd>converts a UTF-8 string to a local multi-byte character string. <b>[More info required here!]</b></dd></dl>
<p>unsigned int <a class="el" href="group__fl__unicode.html#ga56a6296024debb49690b81addda7589b">fl_utf8fromwc(char *dst, unsigned dstlen, const wchar_t *src, unsigned srclen)</a> <b>FLTK2</b> <br/>
 unsigned int <a class="el" href="group__fl__unicode.html#gac483f43232e4444086487d3417236209" title="Converts a UTF-8 string into a wide character string.">fl_utf8towc(const char *src, unsigned srclen, wchar_t *dst, unsigned dstlen)</a> <b>FLTK2</b> <br/>
 unsigned int <a class="el" href="group__fl__unicode.html#ga6b537f15e29c1eb78bee7c24483dc759">fl_utf8toUtf16(const char *src, unsigned srclen, unsigned short *dst, unsigned dstlen)</a> <b>FLTK2</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd>These routines convert between UTF-8 and <code>wchar_t</code> or "wide character" strings. The difficulty lies in the fact <code>sizeof(wchar_t)</code> is 2 on Windows and 4 on Linux and most other systems. Therefore some "wide characters" on Windows may be represented as "surrogate pairs" of more than one <code>wchar_t</code>.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>fl_utf8fromwc</code>() converts from a "wide character" string to UTF-8. Note that <code>srclen</code> is the number of <code>wchar_t</code> elements in the source string and on Windows and this might be larger than the number of characters. <code>dstlen</code> specifies the maximum number of <b>bytes</b> to copy, including the null terminator.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>fl_utf8towc</code>() converts a UTF-8 string into a "wide character" string. Note that on Windows, some "wide characters" might result in "surrogate
pairs" and therefore the return value might be more than the number of characters. <code>dstlen</code> specifies the maximum number of <b>wchar_t</b> elements to copy, including a zero terminating element. <b>[Is this all worded correctly?]</b></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>fl_utf8toUtf16</code>() converts a UTF-8 string into a "wide character" string using UTF-16 encoding to handle the "surrogate pairs" on Windows. <code>dstlen</code> specifies the maximum number of <b>wchar_t</b> elements to copy, including a zero terminating element. <b>[Is this all worded correctly?]</b></dd></dl>
<dl class="user"><dt><b></b></dt><dd>These routines all return the number of elements that would be required for a full conversion of the <code>src</code> string, including the zero terminator. Therefore setting <code>dstlen</code> to zero is a way of measuring how much storage would be needed before doing the real conversion.</dd></dl>
<p>unsigned int <a class="el" href="group__fl__unicode.html#gae39a1895b879cc7bde01adc073f15e32">fl_utf8from_mb(char *dst, unsigned dstlen, const char *src, unsigned srclen)</a> <b>FLTK2</b> <br/>
 unsigned int <a class="el" href="group__fl__unicode.html#ga7140599647f4494b4c636e87cf9083b0">fl_utf8to_mb(const char *src, unsigned srclen, char *dst, unsigned dstlen)</a> <b>FLTK2</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd>These functions convert between UTF-8 and the locale-specific multi-byte encodings used on some systems for filenames, etc. If <a class="el" href="group__fl__unicode.html#gad26770d13761b82a68c5bcc5f9de196b">fl_utf8locale()</a> returns true, these functions don't do anything useful. <b>[Is this all worded correctly?]</b></dd></dl>
<p>int <a class="el" href="group__fl__unicode.html#ga740fa37418471ca5be990c7cda17633a" title="return the Unicode lower case value of ucs ">fl_tolower(unsigned int ucs)</a> <b>OksiD</b> <br/>
 int <a class="el" href="group__fl__unicode.html#gaa89f0f2a9adf00a1b6b73776b8f01cd0" title="return the Unicode upper case value of ucs ">fl_toupper(unsigned int ucs)</a> <b>OksiD</b> <br/>
 int <a class="el" href="group__fl__unicode.html#gacf76050fa9f74aac6bf174bd3872742d" title="converts the str string to the lower case equivalent into buf.">fl_utf_tolower(const unsigned char *str, int len, char *buf)</a> <b>OksiD</b> <br/>
 int <a class="el" href="group__fl__unicode.html#ga4f601b637b94506eaa17056ba20ce25d" title="converts the str string to the upper case equivalent into buf.">fl_utf_toupper(const unsigned char *str, int len, char *buf)</a> <b>OksiD</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd><code>fl_tolower</code>() and <code>fl_toupper</code>() convert a single Unicode character from upper to lower case, and vice versa. <code>fl_utf_tolower</code>() and <code>fl_utf_toupper</code>() convert a string of bytes, some of which may be multi-byte UTF-8 encodings of Unicode characters, from upper to lower case, and vice versa. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Warning: to be safe, <code>buf</code> length must be at least <code>3*len</code> [for 16-bit Unicode]</dd></dl>
<p>int <a class="el" href="group__fl__unicode.html#gad63a1c56de1f2ebbe4c1e125386d2e60" title="UTF-8 aware strcasecmp - converts to Unicode and tests.">fl_utf_strcasecmp(const char *s1, const char *s2)</a> <b>OksiD</b> <br/>
 int <a class="el" href="group__fl__unicode.html#ga3b2222dd56379bd207aa43008599ea09" title="UTF-8 aware strncasecmp - converts to lower case Unicode and tests.">fl_utf_strncasecmp(const char *s1, const char *s2, int n)</a> <b>OksiD</b> <br/>
 </p>
<dl class="user"><dt><b></b></dt><dd><code>fl_utf_strcasecmp</code>() is a UTF-8 aware string comparison function that converts the strings to lower case Unicode as part of the comparison. <code>flt_utf_strncasecmp</code>() only compares the first <code>n</code> characters [bytes?]</dd></dl>
<h2><a class="anchor" id="unicode_system_calls"></a>
FLTK Unicode versions of system calls</h2>
<ul>
<li>int fl_access(const char* f, int mode) <b>OksiD</b> </li>
<li>int fl_chmod(const char* f, int mode) <b>OksiD</b> </li>
<li>int fl_execvp(const char* file, char* const* argv) <b>OksiD</b> </li>
<li>FILE* fl_fopen(cont char* f, const char* mode) <b>OksiD</b> </li>
<li>char* fl_getcwd(char* buf, int maxlen) <b>OksiD</b> </li>
<li>char* fl_getenv(const char* name) <b>OksiD</b> </li>
<li>char fl_make_path(const char* path) - returns char ? <b>OksiD</b> </li>
<li>void fl_make_path_for_file(const char* path) <b>OksiD</b> </li>
<li>int fl_mkdir(const char* f, int mode) <b>OksiD</b> </li>
<li>int fl_open(const char* f, int o, ...) <b>OksiD</b> </li>
<li>int fl_rename(const char* f, const char* t) <b>OksiD</b> </li>
<li>int fl_rmdir(const char* f) <b>OksiD</b> </li>
<li>int fl_stat(const char* path, struct stat* buffer) <b>OksiD</b> </li>
<li>int fl_system(const char* f) <b>OksiD</b> </li>
<li>int fl_unlink(const char* f) <b>OksiD</b> </li>
</ul>
<dl class="user"><dt><b>TODO:</b></dt><dd></dd></dl>
<ul>
<li>more doc on unicode, add links </li>
<li>write something about filename encoding on OS X... </li>
<li>explain the fl_utf8_... commands </li>
<li>explain issues with <a class="el" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> </li>
<li>why FLTK has no Fl_String class</li>
</ul>
 
<hr>
<table summary="navigation bar" width="100%" border="0">
<tr>
  <td width="45%" align="LEFT">
    <a class="el" href="advanced.html">
    [Prev]
    Advanced FLTK
    </a>
  </td>
  <td width="10%" align="CENTER">
    <a class="el" href="index.html">[Index]</a>
  </td>
  <td width="45%" align="RIGHT">
    <a class="el" href="enumerations.html">
    FLTK Enumerations
    [Next]
    </a>
  </td>
</tr>
</table>
 </div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="main.html">FLTK Programming Manual</a>      </li>

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>


</body>
</html>
