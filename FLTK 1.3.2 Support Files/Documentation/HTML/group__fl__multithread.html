<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FLTK 1.3.2: Multithreading support functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__fl__multithread.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Multithreading support functions</div>  </div>
</div>
<div class="contents">

<p>fl multithreading support functions declared in &lt;<a class="el" href="Fl_8H.html" title="Fl static class.">FL/Fl.H</a>&gt;  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb">Fl::awake</a> (void *message=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message pointer to the main thread, causing any pending <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> call to terminate so that the main thread can retrieve the message and any pending redraws can be processed.  <a href="#gae9e8f440ce2ca05b047c620f75af13cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga22a404bcaf6641369e0725627d881556">Fl::awake</a> (<a class="el" href="group__callback__functions.html#ga13f70685dbd05cf1537f97f6e59c1e58">Fl_Awake_Handler</a> cb, void *message=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See void awake(void* message=0).  <a href="#ga22a404bcaf6641369e0725627d881556"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2">Fl::lock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method blocks the current thread until it can safely access FLTK widgets and data.  <a href="#gaf6f46de66cc183bc5b38cd364aca4cf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e">Fl::thread_message</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">thread_message()</a> method returns the last message that was sent from a child by the <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a> method.  <a href="#ga82258694ec1baf11c3756c965b2c501e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd">Fl::unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> method releases the lock that was set using the <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method.  <a href="#ga2b9375cc078d9d39161e2cba520829fd"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>fl multithreading support functions declared in &lt;<a class="el" href="Fl_8H.html" title="Fl static class.">FL/Fl.H</a>&gt; </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae9e8f440ce2ca05b047c620f75af13cb"></a><!-- doxytag: member="Fl::awake" ref="gae9e8f440ce2ca05b047c620f75af13cb" args="(void *message=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::awake </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em> = <code>0</code></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a message pointer to the main thread, causing any pending <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> call to terminate so that the main thread can retrieve the message and any pending redraws can be processed. </p>
<p>Multiple calls to <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake()</a> will queue multiple pointers for the main thread to process, up to a system-defined (typically several thousand) depth. The default message handler saves the last message which can be accessed using the <a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">Fl::thread_message()</a> function.</p>
<p>In the context of a threaded application, a call to <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake()</a> with no argument will trigger event loop handling in the main thread. Since it is not possible to call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a> from a subsidiary thread, <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake()</a> is the best (and only, really) substitute.</p>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
<a class="anchor" id="ga22a404bcaf6641369e0725627d881556"></a><!-- doxytag: member="Fl::awake" ref="ga22a404bcaf6641369e0725627d881556" args="(Fl_Awake_Handler cb, void *message=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::awake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga13f70685dbd05cf1537f97f6e59c1e58">Fl_Awake_Handler</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See void awake(void* message=0). </p>
<p>Let the main thread know an update is pending and have it call a specific function.</p>
<p>Registers a function that will be called by the main thread during the next message handling cycle. Returns 0 if the callback function was registered, and -1 if registration failed. Over a thousand awake callbacks can be registered simultaneously.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake</a>(void* message=0) </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6f46de66cc183bc5b38cd364aca4cf2"></a><!-- doxytag: member="Fl::lock" ref="gaf6f46de66cc183bc5b38cd364aca4cf2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method blocks the current thread until it can safely access FLTK widgets and data. </p>
<p>Child threads should call this method prior to updating any widgets or accessing data. The main thread must call <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> to initialize the threading support in FLTK. <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> will return non-zero if threading is not available on the platform.</p>
<p>Child threads must call <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> when they are done accessing FLTK.</p>
<p>When the <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">wait()</a> method is waiting for input or timeouts, child threads are given access to FLTK. Similarly, when the main thread needs to do processing, it will wait until all child threads have called <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> before processing additional data.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if threading is available on the platform; non-zero otherwise.</dd></dl>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
<a class="anchor" id="ga82258694ec1baf11c3756c965b2c501e"></a><!-- doxytag: member="Fl::thread_message" ref="ga82258694ec1baf11c3756c965b2c501e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Fl::thread_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">thread_message()</a> method returns the last message that was sent from a child by the <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a> method. </p>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
<a class="anchor" id="ga2b9375cc078d9d39161e2cba520829fd"></a><!-- doxytag: member="Fl::unlock" ref="ga2b9375cc078d9d39161e2cba520829fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> method releases the lock that was set using the <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method. </p>
<p>Child threads should call this method as soon as they are finished accessing FLTK.</p>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>


</body>
</html>
