<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FLTK 1.3.2: Fl_Text_Display Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classFl__Text__Display.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Fl_Text_Display Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Fl_Text_Display" --><!-- doxytag: inherits="Fl_Group" -->
<p>Rich text display widget.  
 <a href="classFl__Text__Display.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Fl__Text__Display_8H_source.html">Fl_Text_Display.H</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Fl_Text_Display:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classFl__Text__Display.png" usemap="#Fl_Text_Display_map" alt=""/>
  <map id="Fl_Text_Display_map" name="Fl_Text_Display_map">
<area href="classFl__Group.html" title="The Fl_Group class is the FLTK container widget." alt="Fl_Group" shape="rect" coords="0,56,102,80"/>
<area href="classFl__Widget.html" title="Fl_Widget is the base class for all widgets in FLTK." alt="Fl_Widget" shape="rect" coords="0,0,102,24"/>
<area href="classFl__Text__Editor.html" title="This is the FLTK text editor widget." alt="Fl_Text_Editor" shape="rect" coords="0,168,102,192"/>
</map>
 </div></div>

<p><a href="classFl__Text__Display-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFl__Text__Display_1_1Style__Table__Entry.html">Style_Table_Entry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure associates the color, font, andsize of a string to draw with an attribute mask matching attr.  <a href="structFl__Text__Display_1_1Style__Table__Entry.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84faa2a0731bec785c14eeb50bfdee224b6e">NORMAL_CURSOR</a>, 
<a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84fa620b34373d9910508bcba51710122435">CARET_CURSOR</a>, 
<a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84fa44c221fb4a13dda486e5d94279f7933c">DIM_CURSOR</a>, 
<a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84fa0b298a0a850266321159bf9aff7517f6">BLOCK_CURSOR</a>, 
<br/>
&#160;&#160;<a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84faf91b386f9d018b5dfe3f42c5ae2207f4">HEAVY_CURSOR</a>, 
<a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84faaaeb2657c5fc8b5f51a3c43c2143c744">SIMPLE_CURSOR</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">text display cursor shapes enumeration  <a href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84f">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CURSOR_POS</b>, 
<b>CHARACTER_POS</b>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the character position is the left edge of a character, whereas the cursor is thought to be between the centers of two consecutive characters. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>DRAG_NONE</b> =  -2, 
<b>DRAG_START_DND</b> =  -1, 
<b>DRAG_CHAR</b> =  0, 
<b>DRAG_WORD</b> =  1, 
<br/>
&#160;&#160;<b>DRAG_LINE</b> =  2
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">drag types - they match <a class="el" href="group__fl__events.html#gafa31b53b34bd43ee107806a3bbc640d1" title="Returns non zero if we had a double click event.">Fl::event_clicks()</a> so that single clicking to start a collection selects by character, double clicking selects by word and triple clicking selects by line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classFl__Text__Display.html#a27dd400a525f9ae397450488e5030c8eaa4c885d60a9b96851f7af56befe886a5">WRAP_NONE</a>, 
<a class="el" href="classFl__Text__Display.html#a27dd400a525f9ae397450488e5030c8ea2c56d51b13b897f186f6c50f25a77f05">WRAP_AT_COLUMN</a>, 
<a class="el" href="classFl__Text__Display.html#a27dd400a525f9ae397450488e5030c8eacc749e9434872faa99a6b33e352e8605">WRAP_AT_PIXEL</a>, 
<a class="el" href="classFl__Text__Display.html#a27dd400a525f9ae397450488e5030c8ea4d86a239285c1070d6381e678f2a9e59">WRAP_AT_BOUNDS</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">wrap types - used in <a class="el" href="classFl__Text__Display.html#ab9378d48b949f8fc7da04c6be4142c54" title="Set the new text wrap mode.">wrap_mode()</a>  <a href="classFl__Text__Display.html#a27dd400a525f9ae397450488e5030c8e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a400175488d5219657716223ee925d135"></a><!-- doxytag: member="Fl_Text_Display::Unfinished_Style_Cb" ref="a400175488d5219657716223ee925d135" args=")(int, void *)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>Unfinished_Style_Cb</b> )(int, void *)</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a0244a43078c78af8f528f933a6719490">buffer</a> (<a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> *buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a text buffer to display, replacing the current buffer (if any)  <a href="#a0244a43078c78af8f528f933a6719490"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ae5a312a54d2f4bcbeb91e0ad76717eaa">buffer</a> (<a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current text buffer associated with the text widget.  <a href="#ae5a312a54d2f4bcbeb91e0ad76717eaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a4f7aa5306cf532bcadddf95697ef2a4e">buffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current text buffer associated with the text widget.  <a href="#a4f7aa5306cf532bcadddf95697ef2a4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a90d8bbadca12c9403b3cc3041ffe9a07">col_to_x</a> (double col) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a column number into an x pixel position.  <a href="#a90d8bbadca12c9403b3cc3041ffe9a07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a4e72304db704275f1d9df60407d366c5">count_lines</a> (int start, int end, bool start_pos_is_line_start) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of lines between two positions.  <a href="#a4e72304db704275f1d9df60407d366c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a1c6e9f81d0dfa49606fe5c2794313c2b">cursor_color</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the text cursor color.  <a href="#a1c6e9f81d0dfa49606fe5c2794313c2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a17bfc3af03f82c18c7ebb6ef34ed2139">cursor_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the text cursor color.  <a href="#a17bfc3af03f82c18c7ebb6ef34ed2139"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a6f4751931de885d4907e659d97acab30">cursor_style</a> (int style)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the text cursor style.  <a href="#a6f4751931de885d4907e659d97acab30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a42c6300eda2d0eaca52d20f137530197">Fl_Text_Display</a> (int X, int Y, int W, int H, const char *l=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new text display widget.  <a href="#a42c6300eda2d0eaca52d20f137530197"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48649283f44cb7eacfbdc1e58bb9a73d"></a><!-- doxytag: member="Fl_Text_Display::handle" ref="a48649283f44cb7eacfbdc1e58bb9a73d" args="(int e)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a48649283f44cb7eacfbdc1e58bb9a73d">handle</a> (int e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handling. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04ba6677e453106781e28f4fc75dcef8"></a><!-- doxytag: member="Fl_Text_Display::hide_cursor" ref="a04ba6677e453106781e28f4fc75dcef8" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a04ba6677e453106781e28f4fc75dcef8">hide_cursor</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hides the text cursor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ae09d61739b737a32868ffe0295a25dec">highlight_data</a> (<a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> *styleBuffer, const <a class="el" href="structFl__Text__Display_1_1Style__Table__Entry.html">Style_Table_Entry</a> *styleTable, int nStyles, char unfinishedStyle, Unfinished_Style_Cb unfinishedHighlightCB, void *cbArg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach (or remove) highlight information in text display and redisplay.  <a href="#ae09d61739b737a32868ffe0295a25dec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#aaf32ac6b607867a251aa91cf2f13aca9">in_selection</a> (int x, int y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a pixel position is within the primary selection.  <a href="#aaf32ac6b607867a251aa91cf2f13aca9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a9a813cdf8fd1f142882a4c8b6a9d2bbf">insert</a> (const char *text)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts "text" at the current cursor location.  <a href="#a9a813cdf8fd1f142882a4c8b6a9d2bbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#aa18e615713b30b870045fc370758b510">insert_position</a> (int newPos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the text insertion cursor for text display.  <a href="#aa18e615713b30b870045fc370758b510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ae5e458b9b9d23caba4204313977b52f5">insert_position</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the text insertion cursor for text display.  <a href="#ae5e458b9b9d23caba4204313977b52f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a4197811e367c6752f8638fca4306cd27">line_end</a> (int startPos, bool startPosIsLineStart) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the end of a line.  <a href="#a4197811e367c6752f8638fca4306cd27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a9e03500119c9fbfb6c8a65bcbaf15b52">line_start</a> (int pos) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the beginning of a line.  <a href="#a9e03500119c9fbfb6c8a65bcbaf15b52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a1fe1ed3d39556253238235fd0a57d2bd">move_down</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the current insert position down one line.  <a href="#a1fe1ed3d39556253238235fd0a57d2bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a41c90322a2be857fb6362c783a9d3450">move_left</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the current insert position left one character.  <a href="#a41c90322a2be857fb6362c783a9d3450"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a43532a8c0a8698087cb349b0b3e5f192">move_right</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the current insert position right one character.  <a href="#a43532a8c0a8698087cb349b0b3e5f192"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a62d586abbef6563adbf06c40eaa71c7d">move_up</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the current insert position up one line.  <a href="#a62d586abbef6563adbf06c40eaa71c7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb9d0b39bfcb5724db615f328b3acd7a"></a><!-- doxytag: member="Fl_Text_Display::next_word" ref="abb9d0b39bfcb5724db615f328b3acd7a" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#abb9d0b39bfcb5724db615f328b3acd7a">next_word</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the current insert position right one word. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ae612b71447f03a6ad1f46ae8c1cc9f38">overstrike</a> (const char *text)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces text at the current insert position.  <a href="#ae612b71447f03a6ad1f46ae8c1cc9f38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a2d404e6e08bc81c351c58452f204cf65">position_style</a> (int lineStartPos, int lineLen, int lineIndex) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the correct style for a character.  <a href="#a2d404e6e08bc81c351c58452f204cf65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ad7a473cf89362a9c44788451d8f6bdcb">position_to_xy</a> (int pos, int *x, int *y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character index into a pixel position.  <a href="#ad7a473cf89362a9c44788451d8f6bdcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83c23e74c58e01e61259a6bbaf632ed3"></a><!-- doxytag: member="Fl_Text_Display::previous_word" ref="a83c23e74c58e01e61259a6bbaf632ed3" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a83c23e74c58e01e61259a6bbaf632ed3">previous_word</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the current insert position left one word. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a6ec6a8ca047a45805522efbc301c786a">redisplay_range</a> (int start, int end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks text from start to end as needing a redraw.  <a href="#a6ec6a8ca047a45805522efbc301c786a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#af7f084870d9d94439520886008fcdddd">resize</a> (int X, int Y, int W, int H)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of the displayed text area.  <a href="#af7f084870d9d94439520886008fcdddd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ab979d92ae92c3209cabd187028d61029">rewind_lines</a> (int startPos, int nLines)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip a number of lines back.  <a href="#ab979d92ae92c3209cabd187028d61029"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#aa6705c216c0626763f3f34d3e318d465">scroll</a> (int topLineNum, int horizOffset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scrolls the current buffer to start at the specified line and column.  <a href="#aa6705c216c0626763f3f34d3e318d465"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Enumerations_8H.html#a44e8bcd1e030e65e4f88cbae64a7c3e3">Fl_Align</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a2111071b2535ddc7f10e6c46fcd9829c">scrollbar_align</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scrollbar alignment type.  <a href="#a2111071b2535ddc7f10e6c46fcd9829c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a4b14388f53b951244edcfab51c2a1e18">scrollbar_align</a> (<a class="el" href="Enumerations_8H.html#a44e8bcd1e030e65e4f88cbae64a7c3e3">Fl_Align</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scrollbar alignment type.  <a href="#a4b14388f53b951244edcfab51c2a1e18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#adec55f9b0265039ecb39de3b3de3106c">scrollbar_width</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the width/height of the scrollbars.  <a href="#adec55f9b0265039ecb39de3b3de3106c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a3947903141cbc6f4b125e9aef5f5d388">scrollbar_width</a> (int W)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the width/height of the scrollbars.  <a href="#a3947903141cbc6f4b125e9aef5f5d388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a769f409cf39034170ff1e30f1cd40603">shortcut</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a3ec453b6dc9cc468619688c5bdf3dc95">shortcut</a> (int s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a2e19af56aacc79cbefe426ca6255099d">show_cursor</a> (int b=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the text cursor.  <a href="#a2e19af56aacc79cbefe426ca6255099d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#aadc28a301981f02edc3d57913f56b766">show_insert_position</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scrolls the text buffer to show the current insert position.  <a href="#aadc28a301981f02edc3d57913f56b766"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#adf4a0d3ffb4ebdd34954d1781516653c">skip_lines</a> (int startPos, int nLines, bool startPosIsLineStart)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip a number of lines forward.  <a href="#adf4a0d3ffb4ebdd34954d1781516653c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a488d0c6fd2b649129ef8afb3cdbfdacf">textcolor</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default color of text in the widget.  <a href="#a488d0c6fd2b649129ef8afb3cdbfdacf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a2572e2a4e5bccd59fb94e46b1329e4cf">textcolor</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default color of text in the widget.  <a href="#a2572e2a4e5bccd59fb94e46b1329e4cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ab9f3a2baf49a29d5824d1fa8f379b12f">textfont</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default font used when drawing text in the widget.  <a href="#ab9f3a2baf49a29d5824d1fa8f379b12f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a8bcd59e82106e198bae05ca073cacdf1">textfont</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default font used when drawing text in the widget.  <a href="#a8bcd59e82106e198bae05ca073cacdf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a00f7c0a58a3efd71a8379762dd20c299">textsize</a> (<a class="el" href="Enumerations_8H.html#ad58927f5c691454480f7cd28362502f1">Fl_Fontsize</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default size of text in the widget.  <a href="#a00f7c0a58a3efd71a8379762dd20c299"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Enumerations_8H.html#ad58927f5c691454480f7cd28362502f1">Fl_Fontsize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#acd9c2020efb6c323cb0099634564114d">textsize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default size of text in the widget.  <a href="#acd9c2020efb6c323cb0099634564114d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#aced100368efe93b732e85d3c40e39f57">word_end</a> (int pos) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the insert position to the end of the current word.  <a href="#aced100368efe93b732e85d3c40e39f57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a32bd1f0db8cacae6d499e02657b81e0c">word_start</a> (int pos) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the insert position to the beginning of the current word.  <a href="#a32bd1f0db8cacae6d499e02657b81e0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ab9378d48b949f8fc7da04c6be4142c54">wrap_mode</a> (int wrap, int wrap_margin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new text wrap mode.  <a href="#ab9378d48b949f8fc7da04c6be4142c54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a9692b3f913292d43c63436fd87d49353">wrapped_column</a> (int row, int column) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Nobody knows what this function does.  <a href="#a9692b3f913292d43c63436fd87d49353"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a33f4ffada5a80e4a1d339cd224f05a29">wrapped_row</a> (int row) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Nobody knows what this function does.  <a href="#a33f4ffada5a80e4a1d339cd224f05a29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#aa2999f9788fbee4e9de826725cd63e7a">x_to_col</a> (double x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an x pixel position into a column number.  <a href="#aa2999f9788fbee4e9de826725cd63e7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#aa473b5387fd9f06daea61036b8271b05">~Fl_Text_Display</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a text display and release its associated memory.  <a href="#aa473b5387fd9f06daea61036b8271b05"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>DRAW_LINE</b>, 
<b>FIND_INDEX</b>, 
<b>FIND_INDEX_FROM_ZERO</b>, 
<b>GET_WIDTH</b>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a28a7977a99ba473260863c7dcb3a6baa">absolute_top_line_number</a> (int oldFirstChar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Line numbering stuff, currently unused.  <a href="#a28a7977a99ba473260863c7dcb3a6baa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ac1b0ca46ee02ec0c59d1df188fc48f7d">calc_last_char</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update last display character index.  <a href="#ac1b0ca46ee02ec0c59d1df188fc48f7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#af2d8e613a81bfea815288b9d77874b4b">calc_line_starts</a> (int startLine, int endLine)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the line start arrays.  <a href="#af2d8e613a81bfea815288b9d77874b4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a7c43b4952161ceede34f9637d780ca22">clear_rect</a> (int style, int x, int y, int width, int height) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a rectangle with the appropriate background color for <code>style</code>.  <a href="#a7c43b4952161ceede34f9637d780ca22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ac5de2af1a6744d3f7be1fc7c53343f75">display_insert</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scroll the display to bring insertion cursor into view.  <a href="#ac5de2af1a6744d3f7be1fc7c53343f75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#aed2bc401bcb2effc9cf175499f960637">draw</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the widget.  <a href="#aed2bc401bcb2effc9cf175499f960637"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a5e5d522b89d167554ad059bc9a39b9b4">draw_cursor</a> (int, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a cursor with top center at <code>X</code>, <code>Y</code>.  <a href="#a5e5d522b89d167554ad059bc9a39b9b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#afc77f4bedb15408180b704a91252af80">draw_line_numbers</a> (bool clearAll)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh the line number area.  <a href="#afc77f4bedb15408180b704a91252af80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a63df8b065f442f04eb0653318e048612">draw_range</a> (int start, int end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a range of text.  <a href="#a63df8b065f442f04eb0653318e048612"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ade98444bcc2c735d0c842c36ac753261">draw_string</a> (int style, int x, int y, int toX, const char *string, int nChars) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a text segment in a single style.  <a href="#ade98444bcc2c735d0c842c36ac753261"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a8a03d48ca14949b0a1933fbee2c0e347">draw_text</a> (int X, int Y, int W, int H)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh a rectangle of the text display.  <a href="#a8a03d48ca14949b0a1933fbee2c0e347"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ad6288a3a93930c706c154ea065308c9d">draw_vline</a> (int visLineNum, int leftClip, int rightClip, int leftCharIndex, int rightCharIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single line of text.  <a href="#ad6288a3a93930c706c154ea065308c9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#afae8c3242c762a29abbbe046c0b04c0b">empty_vlines</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are lines visible with no corresponding buffer text.  <a href="#afae8c3242c762a29abbbe046c0b04c0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ade1e3e8a41e7b7bb2d2cd0141b494419">extend_range_for_styles</a> (int *start, int *end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">I don't know what this does!  <a href="#ade1e3e8a41e7b7bb2d2cd0141b494419"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a4f32e3296254adb4482ebb6cd94a8776">find_line_end</a> (int pos, bool start_pos_is_line_start, int *lineEnd, int *nextLineStart) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds both the end of the current line and the start of the next line.  <a href="#a4f32e3296254adb4482ebb6cd94a8776"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a825d640ec72904f7fe27cae8881a0e5a">find_wrap_range</a> (const char *deletedText, int pos, int nInserted, int nDeleted, int *modRangeStart, int *modRangeEnd, int *linesInserted, int *linesDeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapping calculations.  <a href="#a825d640ec72904f7fe27cae8881a0e5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a62c197577fe49f99a8e9444dc55abee3">find_x</a> (const char *s, int len, int style, int x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the character that lies at the given x position.  <a href="#a62c197577fe49f99a8e9444dc55abee3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a143a93578e3e0154f0c91883f668edcb">get_absolute_top_line_number</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Line numbering stuff, currently unused.  <a href="#a143a93578e3e0154f0c91883f668edcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a196ac7e28c59f672b19ddf59a3045495">handle_vline</a> (int mode, int lineStart, int lineLen, int leftChar, int rightChar, int topClip, int bottomClip, int leftClip, int rightClip) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Universal pixel machine.  <a href="#a196ac7e28c59f672b19ddf59a3045495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#aaf897728ed0a1951d481f67121686c08">longest_vline</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the longest line of all visible lines.  <a href="#aaf897728ed0a1951d481f67121686c08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a5cdad865b3cf584ac4e1f6c023361f40">maintain_absolute_top_line_number</a> (int state)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Line numbering stuff, currently unused.  <a href="#a5cdad865b3cf584ac4e1f6c023361f40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a8863dc5a072667a1c1f8f32d15ea61eb">maintaining_absolute_top_line_number</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Line numbering stuff, currently unused.  <a href="#a8863dc5a072667a1c1f8f32d15ea61eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a6ad436a0dfea7f5f69476e570492873d">measure_deleted_lines</a> (int pos, int nDeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapping calculations.  <a href="#a6ad436a0dfea7f5f69476e570492873d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ab8960753a62e1179935732d7e53379b6">measure_proportional_character</a> (const char *s, int colNum, int pos) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapping calculations.  <a href="#ab8960753a62e1179935732d7e53379b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ab2a1b7f4dc1a2b8b9adb2af95067042e">measure_vline</a> (int visLineNum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width in pixels of the displayed line pointed to by "visLineNum".  <a href="#ab2a1b7f4dc1a2b8b9adb2af95067042e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a5c79f7dacb4d5e15925a276876661620">offset_line_starts</a> (int newTopLineNum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset line start counters for a new vertical scroll position.  <a href="#a5c79f7dacb4d5e15925a276876661620"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a880bd82c591f21d433b297165d423993">position_to_line</a> (int pos, int *lineNum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a position index into a line number offset.  <a href="#a880bd82c591f21d433b297165d423993"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a5f1f409a0f725f993788095e20ff9e64">position_to_linecol</a> (int pos, int *lineNum, int *column) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the line and column number of position <code>pos</code>.  <a href="#a5f1f409a0f725f993788095e20ff9e64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a29cca6a03ac20b1af20913c5a0e25fe7">reset_absolute_top_line_number</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Line numbering stuff, probably unused.  <a href="#a29cca6a03ac20b1af20913c5a0e25fe7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ac59b0199f494e20eae3fb270bd20b0f9">scroll_</a> (int topLineNum, int horizOffset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scrolls the current buffer to start at the specified line and column.  <a href="#ac59b0199f494e20eae3fb270bd20b0f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a5655bc66b7e94fa4c3aea557dc38829f">string_width</a> (const char *string, int length, int style) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the width of a string in the font of a particular style.  <a href="#a5655bc66b7e94fa4c3aea557dc38829f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a392b252cf45bc123e58c2542578637d7">update_h_scrollbar</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update vertical scrollbar.  <a href="#a392b252cf45bc123e58c2542578637d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#af80c4c92503b0b713e666b9c1a9742f1">update_line_starts</a> (int pos, int charsInserted, int charsDeleted, int linesInserted, int linesDeleted, int *scrolled)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update line start arrays and variables.  <a href="#af80c4c92503b0b713e666b9c1a9742f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a261e2e626a6448307fe718c7868b24d9">update_v_scrollbar</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update vertical scrollbar.  <a href="#a261e2e626a6448307fe718c7868b24d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a92718ec9315484ff7f8a20f045b04a9f">vline_length</a> (int visLineNum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of bytes in a visible line.  <a href="#a92718ec9315484ff7f8a20f045b04a9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a7528dcb2c809f4b74ab7fe6c7f25afd3">wrap_uses_character</a> (int lineEndPos) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the line break is caused by a \n or by line wrapping.  <a href="#a7528dcb2c809f4b74ab7fe6c7f25afd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ac5f548980bf86c92e24274aeecfadd19">wrapped_line_counter</a> (<a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> *buf, int startPos, int maxPos, int maxLines, bool startPosIsLineStart, int styleBufOffset, int *retPos, int *retLines, int *retLineStart, int *retLineEnd, bool countLastLineMissingNewLine=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapping calculations.  <a href="#ac5f548980bf86c92e24274aeecfadd19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a53327590afe31328051d4daa4cc5af75">xy_to_position</a> (int x, int y, int PosType=CHARACTER_POS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a pixel position into a character index.  <a href="#a53327590afe31328051d4daa4cc5af75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a15a1515596be691c897f88ff1cac5f8f">xy_to_rowcol</a> (int x, int y, int *row, int *column, int PosType=CHARACTER_POS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate pixel coordinates into row and column.  <a href="#a15a1515596be691c897f88ff1cac5f8f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a517a780e90c5e8bdfd63590dd42feaee">buffer_modified_cb</a> (int pos, int nInserted, int nDeleted, int nRestyled, const char *deletedText, void *cbArg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called whenever the buffer is modified.  <a href="#a517a780e90c5e8bdfd63590dd42feaee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a250fa53b47bafa8cce35c05720e42787">buffer_predelete_cb</a> (int pos, int nDeleted, void *cbArg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called before any characters are deleted.  <a href="#a250fa53b47bafa8cce35c05720e42787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3270b487f5973f200ac7854720c8cb5d"></a><!-- doxytag: member="Fl_Text_Display::h_scrollbar_cb" ref="a3270b487f5973f200ac7854720c8cb5d" args="(Fl_Scrollbar *w, Fl_Text_Display *d)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#a3270b487f5973f200ac7854720c8cb5d">h_scrollbar_cb</a> (<a class="el" href="classFl__Scrollbar.html">Fl_Scrollbar</a> *w, <a class="el" href="classFl__Text__Display.html">Fl_Text_Display</a> *d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callbacks for drag or valueChanged on scrollbars. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#afeb531a6fb5cbf6ac542aefec50bf919">scroll_timer_cb</a> (void *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer callback for scroll events.  <a href="#afeb531a6fb5cbf6ac542aefec50bf919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e431e92a7160225b04058ab22c9fc1"></a><!-- doxytag: member="Fl_Text_Display::v_scrollbar_cb" ref="ab9e431e92a7160225b04058ab22c9fc1" args="(Fl_Scrollbar *w, Fl_Text_Display *d)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Text__Display.html#ab9e431e92a7160225b04058ab22c9fc1">v_scrollbar_cb</a> (<a class="el" href="classFl__Scrollbar.html">Fl_Scrollbar</a> *w, <a class="el" href="classFl__Text__Display.html">Fl_Text_Display</a> *d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callbacks for drag or valueChanged on scrollbars. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eae476ae76dcb942eb89f69979161b6"></a><!-- doxytag: member="Fl_Text_Display::damage_range1_end" ref="a5eae476ae76dcb942eb89f69979161b6" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>damage_range1_end</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43058a6dfad43ba8d94d0cfd445dbc5d"></a><!-- doxytag: member="Fl_Text_Display::damage_range1_start" ref="a43058a6dfad43ba8d94d0cfd445dbc5d" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>damage_range1_start</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a652b099379b52eb1b3a0c237d949b600"></a><!-- doxytag: member="Fl_Text_Display::damage_range2_end" ref="a652b099379b52eb1b3a0c237d949b600" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>damage_range2_end</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71a2755ace51641dabca67219fa16a76"></a><!-- doxytag: member="Fl_Text_Display::damage_range2_start" ref="a71a2755ace51641dabca67219fa16a76" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>damage_range2_start</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d3a5f34c05fcdfb606bc9dc41364318"></a><!-- doxytag: member="Fl_Text_Display::display_insert_position_hint" ref="a5d3a5f34c05fcdfb606bc9dc41364318" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>display_insert_position_hint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abecc6188d815dab119e22aa35c99594a"></a><!-- doxytag: member="Fl_Text_Display::dragging" ref="abecc6188d815dab119e22aa35c99594a" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>dragging</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8be3a7c43248f6eae8679ff43147bff"></a><!-- doxytag: member="Fl_Text_Display::dragPos" ref="ab8be3a7c43248f6eae8679ff43147bff" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>dragPos</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8977cb754adb98c0e8fcb6306e70691"></a><!-- doxytag: member="Fl_Text_Display::dragType" ref="aa8977cb754adb98c0e8fcb6306e70691" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>dragType</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcc65615ed62774c9e116f15d1d04c34"></a><!-- doxytag: member="Fl_Text_Display::mAbsTopLineNum" ref="adcc65615ed62774c9e116f15d1d04c34" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mAbsTopLineNum</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6bf5d1995a36d019b8e8be8a4c7800d"></a><!-- doxytag: member="Fl_Text_Display::mBuffer" ref="ae6bf5d1995a36d019b8e8be8a4c7800d" args="" -->
<a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mBuffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74edfdd68ef924ea07febf83b8b96f69"></a><!-- doxytag: member="Fl_Text_Display::mColumnScale" ref="a74edfdd68ef924ea07febf83b8b96f69" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>mColumnScale</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa430f76a726f576400b471895feee43f"></a><!-- doxytag: member="Fl_Text_Display::mContinuousWrap" ref="aa430f76a726f576400b471895feee43f" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mContinuousWrap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a932421e6d28f2e4851a5900b836fd106"></a><!-- doxytag: member="Fl_Text_Display::mCursor_color" ref="a932421e6d28f2e4851a5900b836fd106" args="" -->
<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mCursor_color</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43b33a899825b37c477e9eaac8243e3d"></a><!-- doxytag: member="Fl_Text_Display::mCursorOldY" ref="a43b33a899825b37c477e9eaac8243e3d" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mCursorOldY</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa8d5b25727d9c58fd35f77c75210acd"></a><!-- doxytag: member="Fl_Text_Display::mCursorOn" ref="aaa8d5b25727d9c58fd35f77c75210acd" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mCursorOn</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89656c2be101ee6e26b85a66b5c9a76c"></a><!-- doxytag: member="Fl_Text_Display::mCursorPos" ref="a89656c2be101ee6e26b85a66b5c9a76c" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mCursorPos</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d795428b38c1979857ab90c4dad8413"></a><!-- doxytag: member="Fl_Text_Display::mCursorPreferredXPos" ref="a8d795428b38c1979857ab90c4dad8413" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mCursorPreferredXPos</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4226736abd1bb51cdc9b8268ef4b3ef7"></a><!-- doxytag: member="Fl_Text_Display::mCursorStyle" ref="a4226736abd1bb51cdc9b8268ef4b3ef7" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mCursorStyle</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8154a4a3bdd47f3faa05857e05f5ca23"></a><!-- doxytag: member="Fl_Text_Display::mCursorToHint" ref="a8154a4a3bdd47f3faa05857e05f5ca23" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mCursorToHint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af99afe711ef5f691c9daf5e975ba1c2f"></a><!-- doxytag: member="Fl_Text_Display::mFirstChar" ref="af99afe711ef5f691c9daf5e975ba1c2f" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mFirstChar</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab52fe15b28cc5a962158b19ac9762618"></a><!-- doxytag: member="Fl_Text_Display::mHighlightCBArg" ref="ab52fe15b28cc5a962158b19ac9762618" args="" -->
void *&#160;</td><td class="memItemRight" valign="bottom"><b>mHighlightCBArg</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15bbc4686a0b8fd73cf3817cd4aa48de"></a><!-- doxytag: member="Fl_Text_Display::mHorizOffset" ref="a15bbc4686a0b8fd73cf3817cd4aa48de" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mHorizOffset</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2866695f8a1d84f7f3ddd5b6512a8354"></a><!-- doxytag: member="Fl_Text_Display::mHorizOffsetHint" ref="a2866695f8a1d84f7f3ddd5b6512a8354" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mHorizOffsetHint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac27c95e4bd15735d1b2b8ec756dc45b2"></a><!-- doxytag: member="Fl_Text_Display::mHScrollBar" ref="ac27c95e4bd15735d1b2b8ec756dc45b2" args="" -->
<a class="el" href="classFl__Scrollbar.html">Fl_Scrollbar</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mHScrollBar</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d1af297bd7831e5f0c85d206390b69"></a><!-- doxytag: member="Fl_Text_Display::mLastChar" ref="a41d1af297bd7831e5f0c85d206390b69" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mLastChar</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44bc21a37ff699717732209b4c6ef93b"></a><!-- doxytag: member="Fl_Text_Display::mLineNumLeft" ref="a44bc21a37ff699717732209b4c6ef93b" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mLineNumLeft</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb824c3011961eafc184bd887d4e522e"></a><!-- doxytag: member="Fl_Text_Display::mLineNumWidth" ref="adb824c3011961eafc184bd887d4e522e" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mLineNumWidth</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6ddde0486401efe96bf650eaef535b2"></a><!-- doxytag: member="Fl_Text_Display::mLineStarts" ref="ad6ddde0486401efe96bf650eaef535b2" args="" -->
int *&#160;</td><td class="memItemRight" valign="bottom"><b>mLineStarts</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38208c6d3a7b8c76b066a6d06798e1b1"></a><!-- doxytag: member="Fl_Text_Display::mMaxsize" ref="a38208c6d3a7b8c76b066a6d06798e1b1" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mMaxsize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af70be6e87e93c287b0c6942d8b7663b0"></a><!-- doxytag: member="Fl_Text_Display::mModifyingTabDistance" ref="af70be6e87e93c287b0c6942d8b7663b0" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mModifyingTabDistance</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa80c2dbf0860784fc15c39f4aa1eab0"></a><!-- doxytag: member="Fl_Text_Display::mNBufferLines" ref="afa80c2dbf0860784fc15c39f4aa1eab0" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mNBufferLines</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad943e7c14ad0517f8aa308e21123fed2"></a><!-- doxytag: member="Fl_Text_Display::mNeedAbsTopLineNum" ref="ad943e7c14ad0517f8aa308e21123fed2" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mNeedAbsTopLineNum</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e20a250574f5c3f0805d75d11d02e73"></a><!-- doxytag: member="Fl_Text_Display::mNLinesDeleted" ref="a9e20a250574f5c3f0805d75d11d02e73" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mNLinesDeleted</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4010db1efcce0aa9529f9280234e44ac"></a><!-- doxytag: member="Fl_Text_Display::mNStyles" ref="a4010db1efcce0aa9529f9280234e44ac" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mNStyles</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f1675c671e54d6faadfb10947faf9ef"></a><!-- doxytag: member="Fl_Text_Display::mNVisibleLines" ref="a5f1675c671e54d6faadfb10947faf9ef" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mNVisibleLines</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac49cb705eb353cae3fc58038ffb3da64"></a><!-- doxytag: member="Fl_Text_Display::mStyleBuffer" ref="ac49cb705eb353cae3fc58038ffb3da64" args="" -->
<a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mStyleBuffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e3dd2836c99301f1af8b4fc576d1485"></a><!-- doxytag: member="Fl_Text_Display::mStyleTable" ref="a3e3dd2836c99301f1af8b4fc576d1485" args="" -->
const <a class="el" href="structFl__Text__Display_1_1Style__Table__Entry.html">Style_Table_Entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mStyleTable</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33961c2850e6b78e48c17acc237ee353"></a><!-- doxytag: member="Fl_Text_Display::mSuppressResync" ref="a33961c2850e6b78e48c17acc237ee353" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mSuppressResync</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3e3eddb22f3ac494f3702038a17c088"></a><!-- doxytag: member="Fl_Text_Display::mTopLineNum" ref="ad3e3eddb22f3ac494f3702038a17c088" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mTopLineNum</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee9e956b7676854c3dc129b466c2f293"></a><!-- doxytag: member="Fl_Text_Display::mTopLineNumHint" ref="aee9e956b7676854c3dc129b466c2f293" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mTopLineNumHint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36dd3aa7f408daf75e07e5f4b484fe4b"></a><!-- doxytag: member="Fl_Text_Display::mUnfinishedHighlightCB" ref="a36dd3aa7f408daf75e07e5f4b484fe4b" args="" -->
Unfinished_Style_Cb&#160;</td><td class="memItemRight" valign="bottom"><b>mUnfinishedHighlightCB</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dbfd5704505302485b91c52b0049626"></a><!-- doxytag: member="Fl_Text_Display::mUnfinishedStyle" ref="a0dbfd5704505302485b91c52b0049626" args="" -->
char&#160;</td><td class="memItemRight" valign="bottom"><b>mUnfinishedStyle</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affabc12ab701eb4fec27e5e42f39383f"></a><!-- doxytag: member="Fl_Text_Display::mVScrollBar" ref="affabc12ab701eb4fec27e5e42f39383f" args="" -->
<a class="el" href="classFl__Scrollbar.html">Fl_Scrollbar</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mVScrollBar</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3581b09aac53dfece4e9dd170d752dc9"></a><!-- doxytag: member="Fl_Text_Display::mWrapMarginPix" ref="a3581b09aac53dfece4e9dd170d752dc9" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mWrapMarginPix</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa1463bc33aed27590759bc06492adbc"></a><!-- doxytag: member="Fl_Text_Display::scrollbar_align_" ref="aaa1463bc33aed27590759bc06492adbc" args="" -->
<a class="el" href="Enumerations_8H.html#a44e8bcd1e030e65e4f88cbae64a7c3e3">Fl_Align</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scrollbar_align_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5e1994bcbbd80d20431c890f780f1ed"></a><!-- doxytag: member="Fl_Text_Display::scrollbar_width_" ref="aa5e1994bcbbd80d20431c890f780f1ed" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>scrollbar_width_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a344596efee3f9bb6c557884c44e075"></a><!-- doxytag: member="Fl_Text_Display::shortcut_" ref="a9a344596efee3f9bb6c557884c44e075" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>shortcut_</b></td></tr>
<tr><td class="memItemLeft" ><a class="anchor" id="aca871e1334dcd061e73deb55336bd227"></a><!-- doxytag: member="Fl_Text_Display::text_area" ref="aca871e1334dcd061e73deb55336bd227" args="" -->
struct {</td></tr>
<tr><td class="memItemLeft" >&#160;&#160;&#160;int&#160;&#160;&#160;<b>h</b></td></tr>
<tr><td class="memItemLeft" >&#160;&#160;&#160;int&#160;&#160;&#160;<b>w</b></td></tr>
<tr><td class="memItemLeft" >&#160;&#160;&#160;int&#160;&#160;&#160;<b>x</b></td></tr>
<tr><td class="memItemLeft" >&#160;&#160;&#160;int&#160;&#160;&#160;<b>y</b></td></tr>
<tr><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>text_area</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e0781897bc4b33305f2fb5d50df5895"></a><!-- doxytag: member="Fl_Text_Display::textcolor_" ref="a0e0781897bc4b33305f2fb5d50df5895" args="" -->
<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td><td class="memItemRight" valign="bottom"><b>textcolor_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d99518d80972df1e61794318e9a3d14"></a><!-- doxytag: member="Fl_Text_Display::textfont_" ref="a3d99518d80972df1e61794318e9a3d14" args="" -->
<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>&#160;</td><td class="memItemRight" valign="bottom"><b>textfont_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74de945f5889cc038d80f9b9899dc8a7"></a><!-- doxytag: member="Fl_Text_Display::textsize_" ref="a74de945f5889cc038d80f9b9899dc8a7" args="" -->
<a class="el" href="Enumerations_8H.html#ad58927f5c691454480f7cd28362502f1">Fl_Fontsize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>textsize_</b></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c53f4ccece209c2d25b868862e2585e"></a><!-- doxytag: member="Fl_Text_Display::fl_text_drag_me" ref="a1c53f4ccece209c2d25b868862e2585e" args="(int pos, Fl_Text_Display *d)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>fl_text_drag_me</b> (int pos, <a class="el" href="classFl__Text__Display.html">Fl_Text_Display</a> *d)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Rich text display widget. </p>
<p>This is the FLTK text display widget. It allows the user to view multiple lines of text and supports highlighting and scrolling. The buffer that is displayed in the widget is managed by the <a class="el" href="classFl__Text__Buffer.html" title="This class manages unicode displayed in one or more Fl_Text_Display widgets.">Fl_Text_Buffer</a> class. A single Text Buffer can be displayed by multiple Text Displays. </p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a63da3d2f52097be3c1773ae06b96d84f"></a><!-- doxytag: member="Fl_Text_Display::@14" ref="a63da3d2f52097be3c1773ae06b96d84f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>text display cursor shapes enumeration </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a63da3d2f52097be3c1773ae06b96d84faa2a0731bec785c14eeb50bfdee224b6e"></a><!-- doxytag: member="NORMAL_CURSOR" ref="a63da3d2f52097be3c1773ae06b96d84faa2a0731bec785c14eeb50bfdee224b6e" args="" -->NORMAL_CURSOR</em>&nbsp;</td><td>
<p>I-beam. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a63da3d2f52097be3c1773ae06b96d84fa620b34373d9910508bcba51710122435"></a><!-- doxytag: member="CARET_CURSOR" ref="a63da3d2f52097be3c1773ae06b96d84fa620b34373d9910508bcba51710122435" args="" -->CARET_CURSOR</em>&nbsp;</td><td>
<p>caret under the text </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a63da3d2f52097be3c1773ae06b96d84fa44c221fb4a13dda486e5d94279f7933c"></a><!-- doxytag: member="DIM_CURSOR" ref="a63da3d2f52097be3c1773ae06b96d84fa44c221fb4a13dda486e5d94279f7933c" args="" -->DIM_CURSOR</em>&nbsp;</td><td>
<p>dim I-beam </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a63da3d2f52097be3c1773ae06b96d84fa0b298a0a850266321159bf9aff7517f6"></a><!-- doxytag: member="BLOCK_CURSOR" ref="a63da3d2f52097be3c1773ae06b96d84fa0b298a0a850266321159bf9aff7517f6" args="" -->BLOCK_CURSOR</em>&nbsp;</td><td>
<p>unfille box under the current character </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a63da3d2f52097be3c1773ae06b96d84faf91b386f9d018b5dfe3f42c5ae2207f4"></a><!-- doxytag: member="HEAVY_CURSOR" ref="a63da3d2f52097be3c1773ae06b96d84faf91b386f9d018b5dfe3f42c5ae2207f4" args="" -->HEAVY_CURSOR</em>&nbsp;</td><td>
<p>thick I-beam </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a63da3d2f52097be3c1773ae06b96d84faaaeb2657c5fc8b5f51a3c43c2143c744"></a><!-- doxytag: member="SIMPLE_CURSOR" ref="a63da3d2f52097be3c1773ae06b96d84faaaeb2657c5fc8b5f51a3c43c2143c744" args="" -->SIMPLE_CURSOR</em>&nbsp;</td><td>
<p>as cursor as <a class="el" href="classFl__Input.html" title="This is the FLTK text input widget.">Fl_Input</a> cursor </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a27dd400a525f9ae397450488e5030c8e"></a><!-- doxytag: member="Fl_Text_Display::@17" ref="a27dd400a525f9ae397450488e5030c8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>wrap types - used in <a class="el" href="classFl__Text__Display.html#ab9378d48b949f8fc7da04c6be4142c54" title="Set the new text wrap mode.">wrap_mode()</a> </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a27dd400a525f9ae397450488e5030c8eaa4c885d60a9b96851f7af56befe886a5"></a><!-- doxytag: member="WRAP_NONE" ref="a27dd400a525f9ae397450488e5030c8eaa4c885d60a9b96851f7af56befe886a5" args="" -->WRAP_NONE</em>&nbsp;</td><td>
<p>don't wrap text at all </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a27dd400a525f9ae397450488e5030c8ea2c56d51b13b897f186f6c50f25a77f05"></a><!-- doxytag: member="WRAP_AT_COLUMN" ref="a27dd400a525f9ae397450488e5030c8ea2c56d51b13b897f186f6c50f25a77f05" args="" -->WRAP_AT_COLUMN</em>&nbsp;</td><td>
<p>wrap text at the given text column </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a27dd400a525f9ae397450488e5030c8eacc749e9434872faa99a6b33e352e8605"></a><!-- doxytag: member="WRAP_AT_PIXEL" ref="a27dd400a525f9ae397450488e5030c8eacc749e9434872faa99a6b33e352e8605" args="" -->WRAP_AT_PIXEL</em>&nbsp;</td><td>
<p>wrap text at a pixel position </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a27dd400a525f9ae397450488e5030c8ea4d86a239285c1070d6381e678f2a9e59"></a><!-- doxytag: member="WRAP_AT_BOUNDS" ref="a27dd400a525f9ae397450488e5030c8ea4d86a239285c1070d6381e678f2a9e59" args="" -->WRAP_AT_BOUNDS</em>&nbsp;</td><td>
<p>wrap text so that it fits into the widget width </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a42c6300eda2d0eaca52d20f137530197"></a><!-- doxytag: member="Fl_Text_Display::Fl_Text_Display" ref="a42c6300eda2d0eaca52d20f137530197" args="(int X, int Y, int W, int H, const char *l=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Text_Display::Fl_Text_Display </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>l</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new text display widget. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">X,Y,W,H</td><td>position and size of widget </td></tr>
    <tr><td class="paramname">l</td><td>label text, defaults to none </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa473b5387fd9f06daea61036b8271b05"></a><!-- doxytag: member="Fl_Text_Display::~Fl_Text_Display" ref="aa473b5387fd9f06daea61036b8271b05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Text_Display::~Fl_Text_Display </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a text display and release its associated memory. </p>
<p>Note, the text BUFFER that the text display displays is a separate entity and is not freed, nor are the style buffer or style table. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a28a7977a99ba473260863c7dcb3a6baa"></a><!-- doxytag: member="Fl_Text_Display::absolute_top_line_number" ref="a28a7977a99ba473260863c7dcb3a6baa" args="(int oldFirstChar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::absolute_top_line_number </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oldFirstChar</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Line numbering stuff, currently unused. </p>
<p>Re-calculate absolute top line number for a change in scroll position. </p>

</div>
</div>
<a class="anchor" id="a0244a43078c78af8f528f933a6719490"></a><!-- doxytag: member="Fl_Text_Display::buffer" ref="a0244a43078c78af8f528f933a6719490" args="(Fl_Text_Buffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach a text buffer to display, replacing the current buffer (if any) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>attach this text buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f7aa5306cf532bcadddf95697ef2a4e"></a><!-- doxytag: member="Fl_Text_Display::buffer" ref="a4f7aa5306cf532bcadddf95697ef2a4e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a>* Fl_Text_Display::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current text buffer associated with the text widget. </p>
<p>Multiple text widgets can be associated with the same text buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>current text buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ae5a312a54d2f4bcbeb91e0ad76717eaa"></a><!-- doxytag: member="Fl_Text_Display::buffer" ref="ae5a312a54d2f4bcbeb91e0ad76717eaa" args="(Fl_Text_Buffer &amp;buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the current text buffer associated with the text widget. </p>
<p>Multiple text widgets can be associated with the same text buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>new text buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a517a780e90c5e8bdfd63590dd42feaee"></a><!-- doxytag: member="Fl_Text_Display::buffer_modified_cb" ref="a517a780e90c5e8bdfd63590dd42feaee" args="(int pos, int nInserted, int nDeleted, int nRestyled, const char *deletedText, void *cbArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::buffer_modified_cb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nInserted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDeleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRestyled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>deletedText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cbArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is called whenever the buffer is modified. </p>
<p>Callback attached to the text buffer to receive modification information</p>
<p>This callback can be used to adjust the display or update other setting. It is not advisable to change any buffers or text in this callback, or line counting may get out of sync.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>starting index of modification </td></tr>
    <tr><td class="paramname">nInserted</td><td>number of bytes we inserted (must be UTF-8 aligned!) </td></tr>
    <tr><td class="paramname">nDeleted</td><td>number of bytes deleted (must be UTF-8 aligned!) </td></tr>
    <tr><td class="paramname">nRestyled</td><td>?? </td></tr>
    <tr><td class="paramname">deletedText</td><td>this is what was removed, must not be NULL if nDeleted is set </td></tr>
    <tr><td class="paramname">cbArg</td><td>"this" pointer for static callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a250fa53b47bafa8cce35c05720e42787"></a><!-- doxytag: member="Fl_Text_Display::buffer_predelete_cb" ref="a250fa53b47bafa8cce35c05720e42787" args="(int pos, int nDeleted, void *cbArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::buffer_predelete_cb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDeleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cbArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is called before any characters are deleted. </p>
<p>Callback attached to the text buffer to receive delete information before the modifications are actually made.</p>
<p>This callback can be used to adjust the display or update other setting. It is not advisable to change any buffers or text in this callback, or line counting may get out of sync.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>starting index of deletion </td></tr>
    <tr><td class="paramname">nDeleted</td><td>number of bytes we will delete (must be UTF-8 aligned!) </td></tr>
    <tr><td class="paramname">cbArg</td><td>"this" pointer for static callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1b0ca46ee02ec0c59d1df188fc48f7d"></a><!-- doxytag: member="Fl_Text_Display::calc_last_char" ref="ac1b0ca46ee02ec0c59d1df188fc48f7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::calc_last_char </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update last display character index. </p>
<p>Given a <a class="el" href="classFl__Text__Display.html" title="Rich text display widget.">Fl_Text_Display</a> with a complete, up-to-date lineStarts array, update the lastChar entry to point to the last buffer position displayed. </p>

</div>
</div>
<a class="anchor" id="af2d8e613a81bfea815288b9d77874b4b"></a><!-- doxytag: member="Fl_Text_Display::calc_line_starts" ref="af2d8e613a81bfea815288b9d77874b4b" args="(int startLine, int endLine)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::calc_line_starts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endLine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the line start arrays. </p>
<p>Scan through the text in the "textD"'s buffer and recalculate the line starts array values beginning at index "startLine" and continuing through (including) "endLine". It assumes that the line starts entry preceding "startLine" (or mFirstChar if startLine is 0) is good, and re-counts newlines to fill in the requested entries. Out of range values for "startLine" and "endLine" are acceptable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startLine,endLine</td><td>range of lines to scan as line numbers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c43b4952161ceede34f9637d780ca22"></a><!-- doxytag: member="Fl_Text_Display::clear_rect" ref="a7c43b4952161ceede34f9637d780ca22" args="(int style, int x, int y, int width, int height) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::clear_rect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear a rectangle with the appropriate background color for <code>style</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>index into style table </td></tr>
    <tr><td class="paramname">X,Y,width,height</td><td>size and position of background area </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90d8bbadca12c9403b3cc3041ffe9a07"></a><!-- doxytag: member="Fl_Text_Display::col_to_x" ref="a90d8bbadca12c9403b3cc3041ffe9a07" args="(double col) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Fl_Text_Display::col_to_x </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a column number into an x pixel position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>an approximate column number based on the main font </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of pixels from the left margin to the left of an average sized character </dd></dl>

</div>
</div>
<a class="anchor" id="a4e72304db704275f1d9df60407d366c5"></a><!-- doxytag: member="Fl_Text_Display::count_lines" ref="a4e72304db704275f1d9df60407d366c5" args="(int start, int end, bool start_pos_is_line_start) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::count_lines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startPosIsLineStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count the number of lines between two positions. </p>
<p>Same as BufCountLines, but takes into account wrapping if wrapping is turned on. If the caller knows that <code>startPos</code> is at a line start, it can pass <code>startPosIsLineStart</code> as True to make the call more efficient by avoiding the additional step of scanning back to the last newline.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startPos</td><td>index to first character </td></tr>
    <tr><td class="paramname">endPos</td><td>index after last character </td></tr>
    <tr><td class="paramname">startPosIsLineStart</td><td>avoid scanning back to the line start </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of lines </dd></dl>

</div>
</div>
<a class="anchor" id="a17bfc3af03f82c18c7ebb6ef34ed2139"></a><!-- doxytag: member="Fl_Text_Display::cursor_color" ref="a17bfc3af03f82c18c7ebb6ef34ed2139" args="(Fl_Color n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::cursor_color </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the text cursor color. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>new cursor color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c6e9f81d0dfa49606fe5c2794313c2b"></a><!-- doxytag: member="Fl_Text_Display::cursor_color" ref="a1c6e9f81d0dfa49606fe5c2794313c2b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> Fl_Text_Display::cursor_color </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the text cursor color. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>cursor color </dd></dl>

</div>
</div>
<a class="anchor" id="a6f4751931de885d4907e659d97acab30"></a><!-- doxytag: member="Fl_Text_Display::cursor_style" ref="a6f4751931de885d4907e659d97acab30" args="(int style)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::cursor_style </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>style</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the text cursor style. </p>
<p>Sets the text cursor style to one of the following:</p>
<ul>
<li><a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84faa2a0731bec785c14eeb50bfdee224b6e" title="I-beam.">Fl_Text_Display::NORMAL_CURSOR</a> - Shows an I beam. </li>
<li><a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84fa620b34373d9910508bcba51710122435" title="caret under the text">Fl_Text_Display::CARET_CURSOR</a> - Shows a caret under the text. </li>
<li><a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84fa44c221fb4a13dda486e5d94279f7933c" title="dim I-beam">Fl_Text_Display::DIM_CURSOR</a> - Shows a dimmed I beam. </li>
<li><a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84fa0b298a0a850266321159bf9aff7517f6" title="unfille box under the current character">Fl_Text_Display::BLOCK_CURSOR</a> - Shows an unfilled box around the current character. </li>
<li><a class="el" href="classFl__Text__Display.html#a63da3d2f52097be3c1773ae06b96d84faf91b386f9d018b5dfe3f42c5ae2207f4" title="thick I-beam">Fl_Text_Display::HEAVY_CURSOR</a> - Shows a thick I beam.</li>
</ul>
<p>This call also switches the cursor on and may trigger a redraw.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>new cursor style </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5de2af1a6744d3f7be1fc7c53343f75"></a><!-- doxytag: member="Fl_Text_Display::display_insert" ref="ac5de2af1a6744d3f7be1fc7c53343f75" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::display_insert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scroll the display to bring insertion cursor into view. </p>
<p>Note: it would be nice to be able to do this without counting lines twice (<a class="el" href="classFl__Text__Display.html#ac59b0199f494e20eae3fb270bd20b0f9" title="Scrolls the current buffer to start at the specified line and column.">scroll_()</a> counts them too) and/or to count from the most efficient starting point, but the efficiency of this routine is not as important to the overall performance of the text display.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000047">Todo:</a></b></dt><dd>Unicode? </dd></dl>

</div>
</div>
<a class="anchor" id="aed2bc401bcb2effc9cf175499f960637"></a><!-- doxytag: member="Fl_Text_Display::draw" ref="aed2bc401bcb2effc9cf175499f960637" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::draw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw the widget. </p>
<p>This function tries to limit drawing to smaller areas if possible. </p>

<p>Reimplemented from <a class="el" href="classFl__Group.html#a96b778e518df02471139179d4c90157c">Fl_Group</a>.</p>

</div>
</div>
<a class="anchor" id="a5e5d522b89d167554ad059bc9a39b9b4"></a><!-- doxytag: member="Fl_Text_Display::draw_cursor" ref="a5e5d522b89d167554ad059bc9a39b9b4" args="(int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::draw_cursor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a cursor with top center at <code>X</code>, <code>Y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">X,Y</td><td>cursor position in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc77f4bedb15408180b704a91252af80"></a><!-- doxytag: member="Fl_Text_Display::draw_line_numbers" ref="afc77f4bedb15408180b704a91252af80" args="(bool clearAll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::draw_line_numbers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearAll</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Refresh the line number area. </p>
<p>If clearAll is False, writes only over the character cell areas. Setting clearAll to True will clear out any stray marks outside of the character cell area, which might have been left from before a resize or font change.</p>
<p>This function is not used. </p>

</div>
</div>
<a class="anchor" id="a63df8b065f442f04eb0653318e048612"></a><!-- doxytag: member="Fl_Text_Display::draw_range" ref="a63df8b065f442f04eb0653318e048612" args="(int start, int end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::draw_range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endpos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a range of text. </p>
<p>Refresh all of the text between buffer positions <code>startpos</code> and <code>endpos</code> not including the character at the position <code>endpos</code>.</p>
<p>If <code>endpos</code> points beyond the end of the buffer, refresh the whole display after <code>startpos</code>, including blank lines which are not technically part of any range of characters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startpos</td><td>index of first character to draw </td></tr>
    <tr><td class="paramname">endpos</td><td>index after last character to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade98444bcc2c735d0c842c36ac753261"></a><!-- doxytag: member="Fl_Text_Display::draw_string" ref="ade98444bcc2c735d0c842c36ac753261" args="(int style, int x, int y, int toX, const char *string, int nChars) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::draw_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nChars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a text segment in a single style. </p>
<p>Draw a string or blank area according to parameter <code>style</code>, using the appropriate colors and drawing method for that style, with top left corner at <code>X</code>, <code>Y</code>. If style says to draw text, use <code>string</code> as source of characters, and draw <code>nChars</code>, if style is FILL, erase rectangle where text would have drawn from <code>X</code> to <code>toX</code> and from <code>Y</code> to the maximum y extent of the current font(s).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>index into style lookup table </td></tr>
    <tr><td class="paramname">X,Y</td><td>drawing origin </td></tr>
    <tr><td class="paramname">toX</td><td>rightmost position if this is a fill operation </td></tr>
    <tr><td class="paramname">string</td><td>text if this is a drawing operation </td></tr>
    <tr><td class="paramname">nChars</td><td>number of characters to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a03d48ca14949b0a1933fbee2c0e347"></a><!-- doxytag: member="Fl_Text_Display::draw_text" ref="a8a03d48ca14949b0a1933fbee2c0e347" args="(int X, int Y, int W, int H)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::draw_text </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Refresh a rectangle of the text display. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">left,top</td><td>are in coordinates of the text drawing window. </td></tr>
    <tr><td class="paramname">width,height</td><td>size in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6288a3a93930c706c154ea065308c9d"></a><!-- doxytag: member="Fl_Text_Display::draw_vline" ref="ad6288a3a93930c706c154ea065308c9d" args="(int visLineNum, int leftClip, int rightClip, int leftCharIndex, int rightCharIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::draw_vline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>visLineNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>leftClip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rightClip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>leftCharIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rightCharIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a single line of text. </p>
<p>Draw the text on a single line represented by <code>visLineNum</code> (the number of lines down from the top of the display), limited by <code>leftClip</code> and <code>rightClip</code> window coordinates and <code>leftCharIndex</code> and <code>rightCharIndex</code> character positions (not including the character at position <code>rightCharIndex</code>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visLineNum</td><td>index of line in the visible line number lookup </td></tr>
    <tr><td class="paramname">leftClip,rightClip</td><td>pixel position of clipped area </td></tr>
    <tr><td class="paramname">leftCharIndex,rightCharIndex</td><td>index into line of segment that we want to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afae8c3242c762a29abbbe046c0b04c0b"></a><!-- doxytag: member="Fl_Text_Display::empty_vlines" ref="afae8c3242c762a29abbbe046c0b04c0b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::empty_vlines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if there are lines visible with no corresponding buffer text. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if there are empty lines </dd></dl>

</div>
</div>
<a class="anchor" id="ade1e3e8a41e7b7bb2d2cd0141b494419"></a><!-- doxytag: member="Fl_Text_Display::extend_range_for_styles" ref="ade1e3e8a41e7b7bb2d2cd0141b494419" args="(int *start, int *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::extend_range_for_styles </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>startpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>endpos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>I don't know what this does! </p>
<p>Extend the range of a redraw request (from *start to *end) with additional redraw requests resulting from changes to the attached style buffer (which contains auxiliary information for coloring or styling text).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startpos</td><td>?? </td></tr>
    <tr><td class="paramname">endpos</td><td>??</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000051">Todo:</a></b></dt><dd>Unicode? </dd></dl>

</div>
</div>
<a class="anchor" id="a4f32e3296254adb4482ebb6cd94a8776"></a><!-- doxytag: member="Fl_Text_Display::find_line_end" ref="a4f32e3296254adb4482ebb6cd94a8776" args="(int pos, bool start_pos_is_line_start, int *lineEnd, int *nextLineStart) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::find_line_end </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startPosIsLineStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lineEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nextLineStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds both the end of the current line and the start of the next line. </p>
<p>Why? In continuous wrap mode, if you need to know both, figuring out one from the other can be expensive or error prone. The problem comes when there's a trailing space or tab just before the end of the buffer. To translate an end of line value to or from the next lines start value, you need to know whether the trailing space or tab is being used as a line break or just a normal character, and to find that out would otherwise require counting all the way back to the beginning of the line.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startPos</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">startPosIsLineStart</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lineEnd</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nextLineStart</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a825d640ec72904f7fe27cae8881a0e5a"></a><!-- doxytag: member="Fl_Text_Display::find_wrap_range" ref="a825d640ec72904f7fe27cae8881a0e5a" args="(const char *deletedText, int pos, int nInserted, int nDeleted, int *modRangeStart, int *modRangeEnd, int *linesInserted, int *linesDeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::find_wrap_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>deletedText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nInserted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDeleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>modRangeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>modRangeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>linesInserted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>linesDeleted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapping calculations. </p>
<p>When continuous wrap is on, and the user inserts or deletes characters, wrapping can happen before and beyond the changed position. This routine finds the extent of the changes, and counts the deleted and inserted lines over that range. It also attempts to minimize the size of the range to what has to be counted and re-displayed, so the results can be useful both for delimiting where the line starts need to be recalculated, and for deciding what part of the text to redisplay.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">deletedText</td><td></td></tr>
    <tr><td class="paramname">pos</td><td></td></tr>
    <tr><td class="paramname">nInserted</td><td></td></tr>
    <tr><td class="paramname">nDeleted</td><td></td></tr>
    <tr><td class="paramname">modRangeStart</td><td></td></tr>
    <tr><td class="paramname">modRangeEnd</td><td></td></tr>
    <tr><td class="paramname">linesInserted</td><td></td></tr>
    <tr><td class="paramname">linesDeleted</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62c197577fe49f99a8e9444dc55abee3"></a><!-- doxytag: member="Fl_Text_Display::find_x" ref="a62c197577fe49f99a8e9444dc55abee3" args="(const char *s, int len, int style, int x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::find_x </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of the character that lies at the given x position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>UTF-8 text string </td></tr>
    <tr><td class="paramname">len</td><td>length of string </td></tr>
    <tr><td class="paramname">style</td><td>index into style lookup table </td></tr>
    <tr><td class="paramname">x</td><td>position in pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index into buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a143a93578e3e0154f0c91883f668edcb"></a><!-- doxytag: member="Fl_Text_Display::get_absolute_top_line_number" ref="a143a93578e3e0154f0c91883f668edcb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::get_absolute_top_line_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Line numbering stuff, currently unused. </p>
<p>Returns the absolute (non-wrapped) line number of the first line displayed. Returns 0 if the absolute top line number is not being maintained. </p>

</div>
</div>
<a class="anchor" id="a196ac7e28c59f672b19ddf59a3045495"></a><!-- doxytag: member="Fl_Text_Display::handle_vline" ref="a196ac7e28c59f672b19ddf59a3045495" args="(int mode, int lineStart, int lineLen, int leftChar, int rightChar, int topClip, int bottomClip, int leftClip, int rightClip) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::handle_vline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>leftChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rightChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bottomClip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>leftClip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rightClip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Universal pixel machine. </p>
<p>We use a single function that handles all line layout, measuring, and drawing </p>
<ul>
<li>draw a text range </li>
<li>return the width of a text range in pixels </li>
<li>return the index of a character that is at a pixel position</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>DRAW_LINE, GET_WIDTH, FIND_INDEX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lineStartPos</td><td>index of first character </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lineLen</td><td>size of string in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leftChar,rightChar</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td>drawing position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottomClip,leftClip,rightClip</td><td>stop work when we reach the clipped area. rightClip is the X position that we search in FIND_INDEX. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">DRAW_LINE</td><td>index of last drawn character </td></tr>
    <tr><td class="paramname">GET_WIDTH</td><td>width in pixels of text segment if we would draw it </td></tr>
    <tr><td class="paramname">FIND_INDEX</td><td>index of character at given x position in window coordinates </td></tr>
    <tr><td class="paramname">FIND_INDEX_FROM_ZERO</td><td>index of character at given x position without scrolling and widget offsets </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000049">Todo:</a></b></dt><dd><p class="startdd">we need to handle hidden hyphens and tabs here! </p>
<p>we handle all styles and selections </p>
<p class="enddd">we must provide code to get pixel positions of the middle of a character as well </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae09d61739b737a32868ffe0295a25dec"></a><!-- doxytag: member="Fl_Text_Display::highlight_data" ref="ae09d61739b737a32868ffe0295a25dec" args="(Fl_Text_Buffer *styleBuffer, const Style_Table_Entry *styleTable, int nStyles, char unfinishedStyle, Unfinished_Style_Cb unfinishedHighlightCB, void *cbArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::highlight_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> *&#160;</td>
          <td class="paramname"><em>styleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFl__Text__Display_1_1Style__Table__Entry.html">Style_Table_Entry</a> *&#160;</td>
          <td class="paramname"><em>styleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStyles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>unfinishedStyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Unfinished_Style_Cb&#160;</td>
          <td class="paramname"><em>unfinishedHighlightCB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cbArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach (or remove) highlight information in text display and redisplay. </p>
<p>Highlighting information consists of a style buffer which parallels the normal text buffer, but codes font and color information for the display; a style table which translates style buffer codes (indexed by buffer character - 'A') into fonts and colors; and a callback mechanism for as-needed highlighting, triggered by a style buffer entry of "unfinishedStyle". Style buffer can trigger additional redisplay during a normal buffer modification if the buffer contains a primary <a class="el" href="classFl__Text__Selection.html" title="This is an internal class for Fl_Text_Buffer to manage text selections.">Fl_Text_Selection</a> (see extendRangeForStyleMods for more information on this protocol).</p>
<p>Style buffers, tables and their associated memory are managed by the caller.</p>
<p>Styles are ranged from 65 ('A') to 126.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">styleBuffer</td><td>this buffer works in parallel to the text buffer. For every character in the text buffer, the stye buffer has a byte at the same offset that contains an index into an array of possible styles. </td></tr>
    <tr><td class="paramname">styleTable</td><td>a list of styles indexed by the style buffer </td></tr>
    <tr><td class="paramname">nStyles</td><td>number of styles in the style table </td></tr>
    <tr><td class="paramname">unfinishedStyle</td><td>if this style is found, the callback below is called </td></tr>
    <tr><td class="paramname">unfinishedHighlightCB</td><td>if a character with an unfinished style is found, this callback will be called </td></tr>
    <tr><td class="paramname">cbArg</td><td>and optional argument for the callback above, usually a pointer to the Text Display. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf32ac6b607867a251aa91cf2f13aca9"></a><!-- doxytag: member="Fl_Text_Display::in_selection" ref="aaf32ac6b607867a251aa91cf2f13aca9" args="(int x, int y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::in_selection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a pixel position is within the primary selection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">X,Y</td><td>pixel position to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if position (X, Y) is inside of the primary <a class="el" href="classFl__Text__Selection.html" title="This is an internal class for Fl_Text_Buffer to manage text selections.">Fl_Text_Selection</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9a813cdf8fd1f142882a4c8b6a9d2bbf"></a><!-- doxytag: member="Fl_Text_Display::insert" ref="a9a813cdf8fd1f142882a4c8b6a9d2bbf" args="(const char *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::insert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts "text" at the current cursor location. </p>
<p>This has the same effect as inserting the text into the buffer using BufInsert and then moving the insert position after the newly inserted text, except that it's optimized to do less redrawing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>new text in UTF-8 encoding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa18e615713b30b870045fc370758b510"></a><!-- doxytag: member="Fl_Text_Display::insert_position" ref="aa18e615713b30b870045fc370758b510" args="(int newPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::insert_position </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the position of the text insertion cursor for text display. </p>
<p>Move the insertion cursor in front of the character at <code>newPos</code>. This function may trigger a redraw. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newPos</td><td>new caret position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5e458b9b9d23caba4204313977b52f5"></a><!-- doxytag: member="Fl_Text_Display::insert_position" ref="ae5e458b9b9d23caba4204313977b52f5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::insert_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the position of the text insertion cursor for text display. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>insert position index into text buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a4197811e367c6752f8638fca4306cd27"></a><!-- doxytag: member="Fl_Text_Display::line_end" ref="a4197811e367c6752f8638fca4306cd27" args="(int startPos, bool startPosIsLineStart) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::line_end </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startPosIsLineStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the end of a line. </p>
<p>Same as BufEndOfLine, but takes into account line breaks when wrapping is turned on. If the caller knows that <code>startPos</code> is at a line start, it can pass "startPosIsLineStart" as True to make the call more efficient by avoiding the additional step of scanning back to the last newline.</p>
<p>Note that the definition of the end of a line is less clear when continuous wrap is on. With continuous wrap off, it's just a pointer to the newline that ends the line. When it's on, it's the character beyond the last <b>displayable</b> character on the line, where a whitespace character which has been "converted" to a newline for wrapping is not considered displayable. Also note that a line can be wrapped at a non-whitespace character if the line had no whitespace. In this case, this routine returns a pointer to the start of the next line. This is also consistent with the model used by visLineLength.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startPos</td><td>index to starting character </td></tr>
    <tr><td class="paramname">startPosIsLineStart</td><td>avoid scanning back to the line start </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new position as index </dd></dl>

</div>
</div>
<a class="anchor" id="a9e03500119c9fbfb6c8a65bcbaf15b52"></a><!-- doxytag: member="Fl_Text_Display::line_start" ref="a9e03500119c9fbfb6c8a65bcbaf15b52" args="(int pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::line_start </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the beginning of a line. </p>
<p>Same as BufStartOfLine, but returns the character after last wrap point rather than the last newline.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>index to starting character </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new position as index </dd></dl>

</div>
</div>
<a class="anchor" id="aaf897728ed0a1951d481f67121686c08"></a><!-- doxytag: member="Fl_Text_Display::longest_vline" ref="aaf897728ed0a1951d481f67121686c08" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::longest_vline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the longest line of all visible lines. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the width of the longest visible line in pixels </dd></dl>

</div>
</div>
<a class="anchor" id="a5cdad865b3cf584ac4e1f6c023361f40"></a><!-- doxytag: member="Fl_Text_Display::maintain_absolute_top_line_number" ref="a5cdad865b3cf584ac4e1f6c023361f40" args="(int state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::maintain_absolute_top_line_number </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Line numbering stuff, currently unused. </p>
<p>In continuous wrap mode, internal line numbers are calculated after wrapping. A separate non-wrapped line count is maintained when line numbering is turned on. There is some performance cost to maintaining this line count, so normally absolute line numbers are not tracked if line numbering is off. This routine allows callers to specify that they still want this line count maintained (for use via TextDPosToLineAndCol). More specifically, this allows the line number reported in the statistics line to be calibrated in absolute lines, rather than post-wrapped lines. </p>

</div>
</div>
<a class="anchor" id="a8863dc5a072667a1c1f8f32d15ea61eb"></a><!-- doxytag: member="Fl_Text_Display::maintaining_absolute_top_line_number" ref="a8863dc5a072667a1c1f8f32d15ea61eb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::maintaining_absolute_top_line_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Line numbering stuff, currently unused. </p>
<p>Return true if a separate absolute top line number is being maintained (for displaying line numbers or showing in the statistics line). </p>

</div>
</div>
<a class="anchor" id="a6ad436a0dfea7f5f69476e570492873d"></a><!-- doxytag: member="Fl_Text_Display::measure_deleted_lines" ref="a6ad436a0dfea7f5f69476e570492873d" args="(int pos, int nDeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::measure_deleted_lines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDeleted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapping calculations. </p>
<p>This is a stripped-down version of the findWrapRange() function above, intended to be used to calculate the number of "deleted" lines during a buffer modification. It is called _before_ the modification takes place.</p>
<p>This function should only be called in continuous wrap mode with a non-fixed font width. In that case, it is impossible to calculate the number of deleted lines, because the necessary style information is no longer available _after_ the modification. In other cases, we can still perform the calculation afterwards (possibly even more efficiently).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td></td></tr>
    <tr><td class="paramname">nDeleted</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8960753a62e1179935732d7e53379b6"></a><!-- doxytag: member="Fl_Text_Display::measure_proportional_character" ref="ab8960753a62e1179935732d7e53379b6" args="(const char *s, int colNum, int pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Fl_Text_Display::measure_proportional_character </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xPix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapping calculations. </p>
<p>Measure the width in pixels of the first character of string "s" at a particular column "colNum" and buffer position "pos". This is for measuring characters in proportional or mixed-width highlighting fonts.</p>
<p>A note about proportional and mixed-width fonts: the mixed width and proportional font code in nedit does not get much use in general editing, because nedit doesn't allow per-language-mode fonts, and editing programs in a proportional font is usually a bad idea, so very few users would choose a proportional font as a default. There are still probably mixed- width syntax highlighting cases where things don't redraw properly for insertion/deletion, though static display and wrapping and resizing should now be solid because they are now used for online help display.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>text string </td></tr>
    <tr><td class="paramname">xPix</td><td>x pixel position needed for calculating tab widths </td></tr>
    <tr><td class="paramname">pos</td><td>offset within string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>width of character in pixels </dd></dl>

</div>
</div>
<a class="anchor" id="ab2a1b7f4dc1a2b8b9adb2af95067042e"></a><!-- doxytag: member="Fl_Text_Display::measure_vline" ref="ab2a1b7f4dc1a2b8b9adb2af95067042e" args="(int visLineNum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::measure_vline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>visLineNum</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the width in pixels of the displayed line pointed to by "visLineNum". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visLineNum</td><td>index into visible lines array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>width of line in pixels </dd></dl>

</div>
</div>
<a class="anchor" id="a1fe1ed3d39556253238235fd0a57d2bd"></a><!-- doxytag: member="Fl_Text_Display::move_down" ref="a1fe1ed3d39556253238235fd0a57d2bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::move_down </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the current insert position down one line. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the cursor moved, 0 if the beginning of the text was reached </dd></dl>

</div>
</div>
<a class="anchor" id="a41c90322a2be857fb6362c783a9d3450"></a><!-- doxytag: member="Fl_Text_Display::move_left" ref="a41c90322a2be857fb6362c783a9d3450" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::move_left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the current insert position left one character. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the cursor moved, 0 if the beginning of the text was reached </dd></dl>

</div>
</div>
<a class="anchor" id="a43532a8c0a8698087cb349b0b3e5f192"></a><!-- doxytag: member="Fl_Text_Display::move_right" ref="a43532a8c0a8698087cb349b0b3e5f192" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::move_right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the current insert position right one character. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the cursor moved, 0 if the end of the text was reached </dd></dl>

</div>
</div>
<a class="anchor" id="a62d586abbef6563adbf06c40eaa71c7d"></a><!-- doxytag: member="Fl_Text_Display::move_up" ref="a62d586abbef6563adbf06c40eaa71c7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::move_up </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the current insert position up one line. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the cursor moved, 0 if the beginning of the text was reached </dd></dl>

</div>
</div>
<a class="anchor" id="a5c79f7dacb4d5e15925a276876661620"></a><!-- doxytag: member="Fl_Text_Display::offset_line_starts" ref="a5c79f7dacb4d5e15925a276876661620" args="(int newTopLineNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::offset_line_starts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newTopLineNum</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset line start counters for a new vertical scroll position. </p>
<p>Offset the line starts array, mTopLineNum, mFirstChar and lastChar, for a new vertical scroll position given by newTopLineNum. If any currently displayed lines will still be visible, salvage the line starts values, otherwise, count lines from the nearest known line start (start or end of buffer, or the closest value in the mLineStarts array)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newTopLineNum</td><td>index into buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae612b71447f03a6ad1f46ae8c1cc9f38"></a><!-- doxytag: member="Fl_Text_Display::overstrike" ref="ae612b71447f03a6ad1f46ae8c1cc9f38" args="(const char *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::overstrike </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces text at the current insert position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>new text in UTF-8 encoding</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000042">Todo:</a></b></dt><dd>Unicode? Find out exactly what we do here and simplify. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d404e6e08bc81c351c58452f204cf65"></a><!-- doxytag: member="Fl_Text_Display::position_style" ref="a2d404e6e08bc81c351c58452f204cf65" args="(int lineStartPos, int lineLen, int lineIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::position_style </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the correct style for a character. </p>
<p>Determine the drawing method to use to draw a specific character from "buf". <code>lineStartPos</code> gives the character index where the line begins, <code>lineIndex</code>, the number of characters past the beginning of the line, and <code>lineIndex</code> the number of displayed characters past the beginning of the line. Passing <code>lineStartPos</code> of -1 returns the drawing style for "no text".</p>
<p>Why not just: position_style(pos)? Because style applies to blank areas of the window beyond the text boundaries, and because this routine must also decide whether a position is inside of a rectangular <a class="el" href="classFl__Text__Selection.html" title="This is an internal class for Fl_Text_Buffer to manage text selections.">Fl_Text_Selection</a>, and do so efficiently, without re-counting character positions from the start of the line.</p>
<p>Note that style is a somewhat incorrect name, drawing method would be more appropriate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lineStartPos</td><td>beginning of this line </td></tr>
    <tr><td class="paramname">lineLen</td><td>number of bytes in line </td></tr>
    <tr><td class="paramname">lineIndex</td><td>position of character within line </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>style for the given character </dd></dl>

</div>
</div>
<a class="anchor" id="a880bd82c591f21d433b297165d423993"></a><!-- doxytag: member="Fl_Text_Display::position_to_line" ref="a880bd82c591f21d433b297165d423993" args="(int pos, int *lineNum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::position_to_line </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lineNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a position index into a line number offset. </p>
<p>Find the line number of position <code>pos</code> relative to the first line of displayed text. Returns 0 if the line is not displayed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>?? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lineNum</td><td>?? </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>?? </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000048">Todo:</a></b></dt><dd>What does this do? </dd></dl>

</div>
</div>
<a class="anchor" id="a5f1f409a0f725f993788095e20ff9e64"></a><!-- doxytag: member="Fl_Text_Display::position_to_linecol" ref="a5f1f409a0f725f993788095e20ff9e64" args="(int pos, int *lineNum, int *column) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::position_to_linecol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lineNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the line and column number of position <code>pos</code>. </p>
<p>This only works for displayed lines. If the line is not displayed, the function returns 0 (without the mLineStarts array it could turn in to very long calculation involving scanning large amounts of text in the buffer). If continuous wrap mode is on, returns the absolute line number (as opposed to the wrapped line number which is used for scrolling).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>character index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lineNum</td><td>absolute (unwrapped) line number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">column</td><td>character offset to the beginning of the line </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if <code>pos</code> is off screen, line number otherwise </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000043">Todo:</a></b></dt><dd>a column number makes little sense in the UTF-8/variable font width environment. We will have to further define what exactly we want to return. Please check the functions that call this particular function. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7a473cf89362a9c44788451d8f6bdcb"></a><!-- doxytag: member="Fl_Text_Display::position_to_xy" ref="ad7a473cf89362a9c44788451d8f6bdcb" args="(int pos, int *x, int *y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::position_to_xy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a character index into a pixel position. </p>
<p>Translate a buffer text position to the XY location where the top left of the cursor would be positioned to point to that character. Returns 0 if the position is not displayed because it is <em><b>vertically</b> out</em> of view. If the position is horizontally out of view, returns the X coordinate where the position would be if it were visible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>character index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X,Y</td><td>pixel position of character on screen </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if character vertically out of view, X &amp; Y positions otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a6ec6a8ca047a45805522efbc301c786a"></a><!-- doxytag: member="Fl_Text_Display::redisplay_range" ref="a6ec6a8ca047a45805522efbc301c786a" args="(int start, int end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::redisplay_range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endpos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks text from start to end as needing a redraw. </p>
<p>This function will trigger a damage event and later a redraw of parts of the widget. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startpos</td><td>index of first character needing redraw </td></tr>
    <tr><td class="paramname">endpos</td><td>index after last character needing redraw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29cca6a03ac20b1af20913c5a0e25fe7"></a><!-- doxytag: member="Fl_Text_Display::reset_absolute_top_line_number" ref="a29cca6a03ac20b1af20913c5a0e25fe7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::reset_absolute_top_line_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Line numbering stuff, probably unused. </p>
<p>Count lines from the beginning of the buffer to reestablish the absolute (non-wrapped) top line number. If mode is not continuous wrap, or the number is not being maintained, does nothing. </p>

</div>
</div>
<a class="anchor" id="af7f084870d9d94439520886008fcdddd"></a><!-- doxytag: member="Fl_Text_Display::resize" ref="af7f084870d9d94439520886008fcdddd" args="(int X, int Y, int W, int H)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the size of the displayed text area. </p>
<p>Calling this function will trigger a recalculation of all lines visible and of all scrollbar sizes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">X,Y,W,H</td><td>new position and size of this widget </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classFl__Group.html#aaec24e2eec53dcea00d1d1f63d5495d3">Fl_Group</a>.</p>

</div>
</div>
<a class="anchor" id="ab979d92ae92c3209cabd187028d61029"></a><!-- doxytag: member="Fl_Text_Display::rewind_lines" ref="ab979d92ae92c3209cabd187028d61029" args="(int startPos, int nLines)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::rewind_lines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Skip a number of lines back. </p>
<p>Same as BufCountBackwardNLines, but takes into account line breaks when wrapping is turned on.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startPos</td><td>index to starting character </td></tr>
    <tr><td class="paramname">nLines</td><td>number of lines to skip back </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new position as index </dd></dl>

</div>
</div>
<a class="anchor" id="aa6705c216c0626763f3f34d3e318d465"></a><!-- doxytag: member="Fl_Text_Display::scroll" ref="aa6705c216c0626763f3f34d3e318d465" args="(int topLineNum, int horizOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::scroll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>topLineNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>horizOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scrolls the current buffer to start at the specified line and column. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">topLineNum</td><td>top line number </td></tr>
    <tr><td class="paramname">horizOffset</td><td>column number </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000050">Todo:</a></b></dt><dd>Column numbers make little sense here. </dd></dl>

</div>
</div>
<a class="anchor" id="ac59b0199f494e20eae3fb270bd20b0f9"></a><!-- doxytag: member="Fl_Text_Display::scroll_" ref="ac59b0199f494e20eae3fb270bd20b0f9" args="(int topLineNum, int horizOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::scroll_ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>topLineNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>horizOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scrolls the current buffer to start at the specified line and column. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">topLineNum</td><td>top line number </td></tr>
    <tr><td class="paramname">horizOffset</td><td>in pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if nothing changed, 1 if we scrolled </dd></dl>

</div>
</div>
<a class="anchor" id="afeb531a6fb5cbf6ac542aefec50bf919"></a><!-- doxytag: member="Fl_Text_Display::scroll_timer_cb" ref="afeb531a6fb5cbf6ac542aefec50bf919" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::scroll_timer_cb </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Timer callback for scroll events. </p>
<p>This timer event scrolls the text view proportionally to how far the mouse pointer has left the text area. This allows for smooth scrolling without "wiggeling" the mouse. </p>

</div>
</div>
<a class="anchor" id="a2111071b2535ddc7f10e6c46fcd9829c"></a><!-- doxytag: member="Fl_Text_Display::scrollbar_align" ref="a2111071b2535ddc7f10e6c46fcd9829c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Enumerations_8H.html#a44e8bcd1e030e65e4f88cbae64a7c3e3">Fl_Align</a> Fl_Text_Display::scrollbar_align </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the scrollbar alignment type. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>scrollbar alignment </dd></dl>

</div>
</div>
<a class="anchor" id="a4b14388f53b951244edcfab51c2a1e18"></a><!-- doxytag: member="Fl_Text_Display::scrollbar_align" ref="a4b14388f53b951244edcfab51c2a1e18" args="(Fl_Align a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::scrollbar_align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#a44e8bcd1e030e65e4f88cbae64a7c3e3">Fl_Align</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the scrollbar alignment type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>new scrollbar alignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adec55f9b0265039ecb39de3b3de3106c"></a><!-- doxytag: member="Fl_Text_Display::scrollbar_width" ref="adec55f9b0265039ecb39de3b3de3106c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::scrollbar_width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the width/height of the scrollbars. </p>
<p>/return width of scrollbars </p>

</div>
</div>
<a class="anchor" id="a3947903141cbc6f4b125e9aef5f5d388"></a><!-- doxytag: member="Fl_Text_Display::scrollbar_width" ref="a3947903141cbc6f4b125e9aef5f5d388" args="(int W)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::scrollbar_width </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the width/height of the scrollbars. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>width of scrollbars </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ec453b6dc9cc468619688c5bdf3dc95"></a><!-- doxytag: member="Fl_Text_Display::shortcut" ref="a3ec453b6dc9cc468619688c5bdf3dc95" args="(int s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::shortcut </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>FIXME : get set methods pointing on shortcut_ have no effects as shortcut_ is unused in this class and derived! </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the new shortcut key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a769f409cf39034170ff1e30f1cd40603"></a><!-- doxytag: member="Fl_Text_Display::shortcut" ref="a769f409cf39034170ff1e30f1cd40603" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::shortcut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd>FIXME : get set methods pointing on shortcut_ have no effects as shortcut_ is unused in this class and derived! </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current shortcut key </dd></dl>

</div>
</div>
<a class="anchor" id="a2e19af56aacc79cbefe426ca6255099d"></a><!-- doxytag: member="Fl_Text_Display::show_cursor" ref="a2e19af56aacc79cbefe426ca6255099d" args="(int b=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::show_cursor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shows the text cursor. </p>
<p>This function may trigger a redraw. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>show(1) or hide(0) the text cursor (caret). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadc28a301981f02edc3d57913f56b766"></a><!-- doxytag: member="Fl_Text_Display::show_insert_position" ref="aadc28a301981f02edc3d57913f56b766" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::show_insert_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scrolls the text buffer to show the current insert position. </p>
<p>This function triggers a complete recalculation, ending in a call to <a class="el" href="classFl__Text__Display.html#ac5de2af1a6744d3f7be1fc7c53343f75" title="Scroll the display to bring insertion cursor into view.">Fl_Text_Display::display_insert()</a> </p>

</div>
</div>
<a class="anchor" id="adf4a0d3ffb4ebdd34954d1781516653c"></a><!-- doxytag: member="Fl_Text_Display::skip_lines" ref="adf4a0d3ffb4ebdd34954d1781516653c" args="(int startPos, int nLines, bool startPosIsLineStart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::skip_lines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startPosIsLineStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Skip a number of lines forward. </p>
<p>Same as BufCountForwardNLines, but takes into account line breaks when wrapping is turned on. If the caller knows that startPos is at a line start, it can pass "startPosIsLineStart" as True to make the call more efficient by avoiding the additional step of scanning back to the last newline.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startPos</td><td>index to starting character </td></tr>
    <tr><td class="paramname">nLines</td><td>number of lines to skip ahead </td></tr>
    <tr><td class="paramname">startPosIsLineStart</td><td>avoid scanning back to the line start </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new position as index </dd></dl>

</div>
</div>
<a class="anchor" id="a5655bc66b7e94fa4c3aea557dc38829f"></a><!-- doxytag: member="Fl_Text_Display::string_width" ref="a5655bc66b7e94fa4c3aea557dc38829f" args="(const char *string, int length, int style) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Fl_Text_Display::string_width </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the width of a string in the font of a particular style. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>the text </td></tr>
    <tr><td class="paramname">length</td><td>number of bytes in string </td></tr>
    <tr><td class="paramname">style</td><td>index into style table </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>width of text segment in pixels </dd></dl>

</div>
</div>
<a class="anchor" id="a488d0c6fd2b649129ef8afb3cdbfdacf"></a><!-- doxytag: member="Fl_Text_Display::textcolor" ref="a488d0c6fd2b649129ef8afb3cdbfdacf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> Fl_Text_Display::textcolor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the default color of text in the widget. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>text color unless overridden by a style </dd></dl>

</div>
</div>
<a class="anchor" id="a2572e2a4e5bccd59fb94e46b1329e4cf"></a><!-- doxytag: member="Fl_Text_Display::textcolor" ref="a2572e2a4e5bccd59fb94e46b1329e4cf" args="(Fl_Color n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::textcolor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the default color of text in the widget. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>new text color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9f3a2baf49a29d5824d1fa8f379b12f"></a><!-- doxytag: member="Fl_Text_Display::textfont" ref="ab9f3a2baf49a29d5824d1fa8f379b12f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a> Fl_Text_Display::textfont </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the default font used when drawing text in the widget. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>current text font face unless overridden by a style </dd></dl>

</div>
</div>
<a class="anchor" id="a8bcd59e82106e198bae05ca073cacdf1"></a><!-- doxytag: member="Fl_Text_Display::textfont" ref="a8bcd59e82106e198bae05ca073cacdf1" args="(Fl_Font s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::textfont </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the default font used when drawing text in the widget. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>default text font face </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00f7c0a58a3efd71a8379762dd20c299"></a><!-- doxytag: member="Fl_Text_Display::textsize" ref="a00f7c0a58a3efd71a8379762dd20c299" args="(Fl_Fontsize s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::textsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ad58927f5c691454480f7cd28362502f1">Fl_Fontsize</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the default size of text in the widget. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new text size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd9c2020efb6c323cb0099634564114d"></a><!-- doxytag: member="Fl_Text_Display::textsize" ref="acd9c2020efb6c323cb0099634564114d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Enumerations_8H.html#ad58927f5c691454480f7cd28362502f1">Fl_Fontsize</a> Fl_Text_Display::textsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the default size of text in the widget. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>current text height unless overridden by a style </dd></dl>

</div>
</div>
<a class="anchor" id="a392b252cf45bc123e58c2542578637d7"></a><!-- doxytag: member="Fl_Text_Display::update_h_scrollbar" ref="a392b252cf45bc123e58c2542578637d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::update_h_scrollbar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update vertical scrollbar. </p>
<p>Update the minimum, maximum, slider size, page increment, and value for the horizontal scrollbar. </p>

</div>
</div>
<a class="anchor" id="af80c4c92503b0b713e666b9c1a9742f1"></a><!-- doxytag: member="Fl_Text_Display::update_line_starts" ref="af80c4c92503b0b713e666b9c1a9742f1" args="(int pos, int charsInserted, int charsDeleted, int linesInserted, int linesDeleted, int *scrolled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::update_line_starts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>charsInserted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>charsDeleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linesInserted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linesDeleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>scrolled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update line start arrays and variables. </p>
<p>Update the line starts array, mTopLineNum, mFirstChar and lastChar for this text display after a modification to the text buffer, given by the position <code>pos</code> where the change began, and the numbers of characters and lines inserted and deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>index into buffer of recent changes </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">charsInserted</td><td>number of bytes(!) inserted </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">charsDeleted</td><td>number of bytes(!) deleted </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">linesInserted</td><td>number of lines </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">linesDeleted</td><td>number of lines </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scrolled</td><td>set to 1 if the text display needs to be scrolled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a261e2e626a6448307fe718c7868b24d9"></a><!-- doxytag: member="Fl_Text_Display::update_v_scrollbar" ref="a261e2e626a6448307fe718c7868b24d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::update_v_scrollbar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update vertical scrollbar. </p>
<p>Update the minimum, maximum, slider size, page increment, and value for vertical scrollbar. </p>

</div>
</div>
<a class="anchor" id="a92718ec9315484ff7f8a20f045b04a9f"></a><!-- doxytag: member="Fl_Text_Display::vline_length" ref="a92718ec9315484ff7f8a20f045b04a9f" args="(int visLineNum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::vline_length </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>visLineNum</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count number of bytes in a visible line. </p>
<p>Return the length of a line (number of bytes) by examining entries in the line starts array rather than by scanning for newlines.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visLineNum</td><td>index of line in visible line array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes in this line </dd></dl>

</div>
</div>
<a class="anchor" id="aced100368efe93b732e85d3c40e39f57"></a><!-- doxytag: member="Fl_Text_Display::word_end" ref="aced100368efe93b732e85d3c40e39f57" args="(int pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::word_end </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the insert position to the end of the current word. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>start calculation at this index </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index of first character after the end of the word </dd></dl>

</div>
</div>
<a class="anchor" id="a32bd1f0db8cacae6d499e02657b81e0c"></a><!-- doxytag: member="Fl_Text_Display::word_start" ref="a32bd1f0db8cacae6d499e02657b81e0c" args="(int pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::word_start </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the insert position to the beginning of the current word. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>start calculation at this index </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>beginning of the words </dd></dl>

</div>
</div>
<a class="anchor" id="ab9378d48b949f8fc7da04c6be4142c54"></a><!-- doxytag: member="Fl_Text_Display::wrap_mode" ref="ab9378d48b949f8fc7da04c6be4142c54" args="(int wrap, int wrap_margin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::wrap_mode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrapMargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the new text wrap mode. </p>
<p>If <code>wrap</code> mode is not zero, this call enables automatic word wrapping at column <code>wrapMargin</code>. Word-wrapping does not change the text buffer itself, only the way the text is displayed. Different Text Displays can have different wrap modes, even if they share the same Text Buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrap</td><td>new wrap mode is WRAP_NONE (don't wrap text at all), WRAP_AT_COLUMN (wrap text at the given text column), WRAP_AT_PIXEL (wrap text at a pixel position), or WRAP_AT_BOUNDS (wrap text so that it fits into the widget width) </td></tr>
    <tr><td class="paramname">wrapMargin</td><td>in WRAP_AT_COLUMN mode, text will wrap at the n'th character. For variable width fonts, an average character width is calculated. The column width is calculated using the current textfont or the first style when this function is called. If the font size changes, this function must be called again. In WRAP_AT_PIXEL mode, this is the pixel position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd>we need new wrap modes to wrap at the window edge and based on pixel width or average character width. </dd></dl>

</div>
</div>
<a class="anchor" id="a7528dcb2c809f4b74ab7fe6c7f25afd3"></a><!-- doxytag: member="Fl_Text_Display::wrap_uses_character" ref="a7528dcb2c809f4b74ab7fe6c7f25afd3" args="(int lineEndPos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::wrap_uses_character </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineEndPos</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the line break is caused by a \n or by line wrapping. </p>
<p>Line breaks in continuous wrap mode usually happen at newlines or whitespace. This line-terminating character is not included in line width measurements and has a special status as a non-visible character. However, lines with no whitespace are wrapped without the benefit of a line terminating character, and this distinction causes endless trouble with all of the text display code which was originally written without continuous wrap mode and always expects to wrap at a newline character.</p>
<p>Given the position of the end of the line, as returned by TextDEndOfLine or BufEndOfLine, this returns true if there is a line terminating character, and false if there's not. On the last character in the buffer, this function can't tell for certain whether a trailing space was used as a wrap point, and just guesses that it wasn't. So if an exact accounting is necessary, don't use this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lineEndPos</td><td>index of character where the line wraps </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if a \n character causes the line wrap </dd></dl>

</div>
</div>
<a class="anchor" id="a9692b3f913292d43c63436fd87d49353"></a><!-- doxytag: member="Fl_Text_Display::wrapped_column" ref="a9692b3f913292d43c63436fd87d49353" args="(int row, int column) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::wrapped_column </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nobody knows what this function does. </p>
<p>Correct a column number based on an unconstrained position (as returned by TextDXYToUnconstrainedPosition) to be relative to the last actual newline in the buffer before the row and column position given, rather than the last line start created by line wrapping. This is an adapter for rectangular selections and code written before continuous wrap mode, which thinks that the unconstrained column is the number of characters from the last newline. Obviously this is time consuming, because it invloves character re-counting.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td></td></tr>
    <tr><td class="paramname">column</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>something unknown </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000044">Todo:</a></b></dt><dd>What does this do and how is it useful? Column numbers mean little in this context. Which functions depend on this one?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000045">Todo:</a></b></dt><dd>Unicode? </dd></dl>

</div>
</div>
<a class="anchor" id="ac5f548980bf86c92e24274aeecfadd19"></a><!-- doxytag: member="Fl_Text_Display::wrapped_line_counter" ref="ac5f548980bf86c92e24274aeecfadd19" args="(Fl_Text_Buffer *buf, int startPos, int maxPos, int maxLines, bool startPosIsLineStart, int styleBufOffset, int *retPos, int *retLines, int *retLineStart, int *retLineEnd, bool countLastLineMissingNewLine=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::wrapped_line_counter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Text__Buffer.html">Fl_Text_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startPosIsLineStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>styleBufOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>retPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>retLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>retLineStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>retLineEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>countLastLineMissingNewLine</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapping calculations. </p>
<p>Count forward from startPos to either maxPos or maxLines (whichever is reached first), and return all relevant positions and line count. The provided textBuffer may differ from the actual text buffer of the widget. In that case it must be a (partial) copy of the actual text buffer and the styleBufOffset argument must indicate the starting position of the copy, to take into account the correct style information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">startPos</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxPos</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxLines</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">startPosIsLineStart</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">styleBufOffset</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retPos</td><td>Position where counting ended. When counting lines, the position returned is the start of the line "maxLines" lines beyond "startPos". </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retLines</td><td>Number of line breaks counted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retLineStart</td><td>Start of the line where counting ended </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retLineEnd</td><td>End position of the last line traversed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">countLastLineMissingNewLine</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33f4ffada5a80e4a1d339cd224f05a29"></a><!-- doxytag: member="Fl_Text_Display::wrapped_row" ref="a33f4ffada5a80e4a1d339cd224f05a29" args="(int row) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::wrapped_row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nobody knows what this function does. </p>
<p>Correct a row number from an unconstrained position (as returned by TextDXYToUnconstrainedPosition) to a straight number of newlines from the top line of the display. Because rectangular selections are based on newlines, rather than display wrapping, and anywhere a rectangular selection needs a row, it needs it in terms of un-wrapped lines.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>something unknown </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000046">Todo:</a></b></dt><dd>What does this do and how is it useful? Column numbers mean little in this context. Which functions depend on this one? </dd></dl>

</div>
</div>
<a class="anchor" id="aa2999f9788fbee4e9de826725cd63e7a"></a><!-- doxytag: member="Fl_Text_Display::x_to_col" ref="aa2999f9788fbee4e9de826725cd63e7a" args="(double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Fl_Text_Display::x_to_col </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert an x pixel position into a column number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>number of pixels from the left margin </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an approximate column number based on the main font </dd></dl>

</div>
</div>
<a class="anchor" id="a53327590afe31328051d4daa4cc5af75"></a><!-- doxytag: member="Fl_Text_Display::xy_to_position" ref="a53327590afe31328051d4daa4cc5af75" args="(int x, int y, int PosType=CHARACTER_POS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Text_Display::xy_to_position </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posType</em> = <code>CHARACTER_POS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translate a pixel position into a character index. </p>
<p>Translate window coordinates to the nearest (insert cursor or character cell) text position. The parameter <code>posType</code> specifies how to interpret the position: CURSOR_POS means translate the coordinates to the nearest cursor position, and CHARACTER_POS means return the position of the character closest to (<code>X</code>, <code>Y</code>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">X,Y</td><td>pixel position </td></tr>
    <tr><td class="paramname">posType</td><td>CURSOR_POS or CHARACTER_POS </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index into text buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a15a1515596be691c897f88ff1cac5f8f"></a><!-- doxytag: member="Fl_Text_Display::xy_to_rowcol" ref="a15a1515596be691c897f88ff1cac5f8f" args="(int x, int y, int *row, int *column, int PosType=CHARACTER_POS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Text_Display::xy_to_rowcol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posType</em> = <code>CHARACTER_POS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translate pixel coordinates into row and column. </p>
<p>Translate window coordinates to the nearest row and column number for positioning the cursor. This, of course, makes no sense when the font is proportional, since there are no absolute columns. The parameter posType specifies how to interpret the position: CURSOR_POS means translate the coordinates to the nearest position between characters, and CHARACTER_POS means translate the position to the nearest character cell.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">X,Y</td><td>pixel coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">row,column</td><td>neares row and column </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">posType</td><td>CURSOR_POS or CHARACTER_POS </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Fl__Text__Display_8H_source.html">Fl_Text_Display.H</a></li>
<li>Fl_Text_Display.cxx</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classFl__Text__Display.html">Fl_Text_Display</a>      </li>

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>


</body>
</html>
